



GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu








GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu






GitLab


















Projects
Groups
Snippets



GitLab






GitLab









Projects
Groups
Snippets






Projects
Groups
Snippets















/




















/














/










Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help





Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help

Support

Community forum


Keyboard shortcuts
?


Submit feedback

Contribute to GitLab



Sign in


Sign in
Toggle navigation
Menu

Menu




H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar








Open sidebar



Joshua Garcia heros
Commits

1cd34e9e















Commit
1cd34e9e


authored
Jan 07, 2015
by


Johannes Lerch



Browse files




cleaning code







parent
ec76098b













Changes
13




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPath.java



0 â†’ 100644







View file @ 1cd34e9e













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.collect.Sets;





















@SuppressWarnings("unchecked")










public class AccessPath<FieldRef> {





















 private FieldRef[] accesses;










 private Set<FieldRef>[] exclusions;










 










 public AccessPath() {










 accesses = (FieldRef[]) new Object[0];










 exclusions = new Set[0];










 }










 










 AccessPath(FieldRef[] accesses, Set<FieldRef>[] exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean hasExclusions() {










 return exclusions.length > 0;










 }










 










 public boolean isAccessInExclusions(FieldRef... fieldReferences) {










 for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 if(exclusions[i].contains(fieldReferences[i]))










 return true;










 } 










 return false;










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException();





















 FieldRef[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 Set<FieldRef>[] newExclusionsArray = exclusions.length < fieldReferences.length ? exclusions : Arrays.copyOfRange(exclusions, fieldReferences.length, exclusions.length); 










 return new AccessPath<FieldRef>(newAccesses, newExclusionsArray);










 }





















 public ExclusionSet getExclusions(int index) {










 return new ExclusionSet(index);










 }










 










 public AccessPath<FieldRef> appendExcludedFieldReference(FieldRef... fieldReferences) {










 Set<FieldRef>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);










 newExclusionsArray[exclusions.length] = Sets.newHashSet(fieldReferences);










 return new AccessPath<>(accesses, newExclusionsArray);










 }










 










 public boolean isPrefixOf(AccessPath<FieldRef> accessPath) {










 if(accesses.length > accessPath.accesses.length)










 return false;










 










 if(accesses.length + exclusions.length > accessPath.accesses.length + accessPath.exclusions.length)










 return false;










 










 for(int i=0; i<accesses.length; i++) {










 if(!accesses[i].equals(accessPath.accesses[i]))










 return false;










 }










 










 for(int i=0; i<exclusions.length; i++) {










 if(i+accesses.length < accessPath.accesses.length) {










 if(exclusions[i].contains(accessPath.accesses[i+accesses.length]))










 return false;










 }










 else {










 if(!exclusions[i].containsAll(accessPath.exclusions[i+accesses.length - accessPath.accesses.length]))










 return false;










 }










 }










 










 return true;










 }










 










 public FieldRef[] getDeltaTo(AccessPath<FieldRef> accPath) {










 if(isPrefixOf(accPath))










 return Arrays.copyOfRange(accPath.accesses, accesses.length, accPath.accesses.length);










 else










 throw new IllegalArgumentException("Given AccessPath must be a prefix of the current AccessPath");










 }










 










 public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {










 Set<FieldRef>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];










 for(int i=0; i<newExclusionArray.length; i++) {










 newExclusionArray[i] = Sets.newHashSet();










 if(i<exclusions.length)










 newExclusionArray[i].addAll(exclusions[i]);










 if(i<accPath.exclusions.length)










 newExclusionArray[i].addAll(accPath.exclusions[i]);










 }










 return new AccessPath<>(accesses, newExclusionArray);










 }










 










 public boolean isEmpty() {










 return exclusions.length == 0 && accesses.length == 0;










 }










 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + Arrays.hashCode(exclusions);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof AccessPath))










 return false;










 AccessPath other = (AccessPath) obj;










 if (!Arrays.equals(accesses, other.accesses))










 return false;










 if (!Arrays.equals(exclusions, other.exclusions))










 return false;










 return true;










 }





















 @Override










 public String toString() {










 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 for(Set<FieldRef> exclusion : exclusions) {










 result += "^" + Joiner.on(",").join(exclusion);










 }










 return result;










 }










 










 public class ExclusionSet {










 private int index;










 










 private ExclusionSet(int index) {










 this.index = index;










 }










 










 public AccessPath<FieldRef> addExclusion(FieldRef exclusion) {










 HashSet<FieldRef> newExclusions = Sets.newHashSet(exclusions[index]);










 newExclusions.add(exclusion);










 Set<FieldRef>[] newExclusionsArray = exclusions.clone();










 newExclusionsArray[index] = newExclusions;










 return new AccessPath<FieldRef>(accesses, newExclusionsArray);










 }










 }










}














src/heros/alias/AccessPathUtil.java








View file @ 1cd34e9e






......@@ -14,91 +14,57 @@ import java.util.ArrayList;




















import com.google.common.base.Optional;





















import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;





















public class AccessPathUtil {





















 public static <D extends FieldSensitiveFact<?, D>> boolean isPrefixOf(D prefixCandidate, D fact) {










 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> boolean isPrefixOf(D prefixCandidate, D fact) {










 if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue()))










 return false; 










 return false;










 










 FieldReference[] prefixAccessPath = prefixCandidate.getAccessPath();










 FieldReference[] factAccessPath = fact.getAccessPath();










 










 for(int i=0; i<prefixAccessPath.length; i++) {










 if(i < factAccessPath.length) {










 if(!prefixAccessPath[i].includes(factAccessPath[i]))










 return false;










 }










 else if(!(prefixAccessPath[i] instanceof Any))










 return false; 










 }










 










 return true;










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }










 










 public static <D extends FieldSensitiveFact<?, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 FieldReference[] concreteAccessPath = sourceFact.getAccessPath();










 FieldReference[] abstractAccessPath = summary.getSourceFact().getAccessPath();










 FieldReference[] targetAccessPath = summary.getTargetFact().getAccessPath();










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 FieldRef[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(targetAccessPath.isAccessInExclusions(delta))










 return Optional.absent();










 










 ArrayList<FieldReference> result = new ArrayList<>(targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length);










 int lastSpecificField = -1;










 for(int i=0; i< targetAccessPath.length; i++) {










 result.add(targetAccessPath[i]);










 if(targetAccessPath[i] instanceof SpecificFieldReference)










 lastSpecificField = i;










 }










 AccessPath<FieldRef> result = targetAccessPath.addFieldReference(delta);










 result = result.mergeExcludedFieldReferences(concreteAccessPath);










 










 for(int i=abstractAccessPath.length; i<concreteAccessPath.length; i++) {










 if(lastSpecificField+1 < result.size()) {










 Optional<? extends FieldReference> mergedFieldRef = concreteAccessPath[i].merge((Any) result.get(lastSpecificField+1));










 if(!mergedFieldRef.isPresent())










 return Optional.absent();










 










 result.set(lastSpecificField+1, mergedFieldRef.get());










 lastSpecificField++;










 } else {










 result.add(concreteAccessPath[i]);










 }










 }










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result.toArray(new FieldReference[result.size()])));










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <D extends FieldSensitiveFact<?, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {










 FieldReference[] accessPath = new FieldReference[fact.getAccessPath().length+fieldRefs.length];










 System.arraycopy(fact.getAccessPath(), 0, accessPath, 0, fact.getAccessPath().length);










 System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);










 return fact.cloneWithAccessPath(accessPath);










 }










//	public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {










//		FieldReference[] accessPath = new FieldReference[fact.getAccessPath().length+fieldRefs.length];










//		System.arraycopy(fact.getAccessPath(), 0, accessPath, 0, fact.getAccessPath().length);










//		System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);










//		return fact.cloneWithAccessPath(accessPath);










//	}










 










 public static <D extends FieldSensitiveFact<?, D>> D concretizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {










 if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))










 throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));










 










 FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();










 FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();










 FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();










 










 FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];





















 //copy old access path










 System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










 










 //copy delta access path that was omitted while creating the abstracted source fact










 System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










 










 return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










 }










 










 public static FieldReference[] getAccessPathDelta(FieldReference[] prefixAccessPath, FieldReference[] accessPath) {










 FieldReference[] result = new FieldReference[accessPath.length - prefixAccessPath.length];










 System.arraycopy(accessPath, prefixAccessPath.length, result, 0, result.length);










 return result;










 }










//	public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D concretizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {










//		if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))










//			throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));










//		










//		FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();










//		FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();










//		FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();










//		










//		FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];










//










//		//copy old access path










//		System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










//		










//		//copy delta access path that was omitted while creating the abstracted source fact










//		System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










//		










//		return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










//	}










}














src/heros/alias/FieldReference.java

deleted


100644 â†’ 0







View file @ ec76098b













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch, Johannes SpÃ¤th.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch, Johannes SpÃ¤th - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FieldReference.Any;





















import java.util.ArrayList;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.base.Optional;










import com.google.common.collect.Sets;





















public interface FieldReference {





















 boolean includes(FieldReference fieldReference);










 










 boolean isIncludedBy(SpecificFieldReference specificFieldRef);










 










 boolean isIncludedBy(Any anyFieldRef);










 










 Optional<? extends FieldReference> merge(Any fieldReference);










 










 public static class Any implements FieldReference {










 private Set<String> excludedFieldNames = Sets.newHashSet();










 










 public Any(String...excludedFieldNames) {










 for (int i = 0; i < excludedFieldNames.length; i++) {










 this.excludedFieldNames.add(excludedFieldNames[i]);










 }










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return false;










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return true;










 }










 










 public Optional<Any> merge(Any fieldReference) {










 ArrayList<String> list = new ArrayList<>(excludedFieldNames);










 list.addAll(fieldReference.excludedFieldNames);










 return Optional.of(new Any(list.toArray(new String[list.size()])));










 }










 










 @Override










 public String toString() {










 if(excludedFieldNames.size() == 0)










 return "";










 else if (excludedFieldNames.size() == 1)










 return "^" + excludedFieldNames.iterator().next();










 else










 return "^{" + Joiner.on(",").join(excludedFieldNames) +"}";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime










 * result










 + ((excludedFieldNames == null) ? 0 : excludedFieldNames










 .hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 Any other = (Any) obj;










 if (excludedFieldNames == null) {










 if (other.excludedFieldNames != null)










 return false;










 } else if (!excludedFieldNames.equals(other.excludedFieldNames))










 return false;










 return true;










 }










 }










 










 public static class SpecificFieldReference implements FieldReference {










 private String fieldName;





















 public SpecificFieldReference(String fieldName) {










 this.fieldName = fieldName;










 }





















 @Override










 public String toString() {










 return fieldName;










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return specificFieldRef.fieldName.equals(fieldName);










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return !anyFieldRef.excludedFieldNames.contains(fieldName);










 }










 










 public Optional<SpecificFieldReference> merge(Any fieldReference) {










 if(fieldReference.excludedFieldNames.contains(fieldName))










 return Optional.absent();










 else 










 return Optional.of(this);










 }










 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result










 + ((fieldName == null) ? 0 : fieldName.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 SpecificFieldReference other = (SpecificFieldReference) obj;










 if (fieldName == null) {










 if (other.fieldName != null)










 return false;










 } else if (!fieldName.equals(other.fieldName))










 return false;










 return true;










 }





















 }










}














src/heros/alias/FieldSensitiveFact.java








View file @ 1cd34e9e






......@@ -12,12 +12,12 @@ package heros.alias;




















import heros.solver.LinkedNode;





















public interface FieldSensitiveFact<BaseValue, D> extends LinkedNode<FieldSensitiveFact<BaseValue, D>>{










public interface FieldSensitiveFact<BaseValue, FieldRef, D> extends LinkedNode<D>{





















 BaseValue getBaseValue();










 










 FieldReference[] getAccessPath();










 AccessPath<FieldRef> getAccessPath();










 










 D cloneWithAccessPath(FieldReference... accessPath);










 D cloneWithAccessPath(AccessPath<FieldRef> accessPath);










 










}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 1cd34e9e






......@@ -10,14 +10,12 @@









 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPathUtil.cloneWithConcatenatedAccessPath;










import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.FlowFunction.Constraint;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.IFDSSolver;










import heros.solver.PathEdge;



......@@ -38,7 +36,7 @@ import com.google.common.base.Predicate;









import com.google.common.cache.CacheBuilder;










import com.google.common.collect.Sets;





















public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact<BaseValue, D>, M, I extends InterproceduralCFG<N, M>> {










public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {
































 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel



......@@ -75,7 +73,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 protected final MyConcurrentHashMap<M, Set<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, Set<PathEdge<N,D>>>();










 










 @DontSynchronize("stateless")










 protected final FlowFunctions<N, D, M> flowFunctions;










 protected final FlowFunctions<N, FieldRef, D, M> flowFunctions;










 










 @DontSynchronize("only used by single thread")










 protected final Map<N,Set<D>> initialSeeds;



......@@ -97,7 +95,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * Creates a solver for the given problem, which caches flow functions and edge functions.










	 * The solver must then be started by calling {@link #solve()}.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,D,M,I> tabulationProblem) {










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef, D,M,I> tabulationProblem) {










 this(tabulationProblem, DEFAULT_CACHE_BUILDER);










 }














......@@ -107,14 +105,14 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.










	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {










 if(logger.isDebugEnabled())










 flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();










 this.zeroValue = tabulationProblem.zeroValue();










 this.icfg = tabulationProblem.interproceduralCFG(); 










 /*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?










				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/ 










 FlowFunctions<N, D, M> flowFunctions = tabulationProblem.flowFunctions(); 










 FlowFunctions<N, FieldRef, D, M> flowFunctions = tabulationProblem.flowFunctions(); 










 /*if(flowFunctionCacheBuilder!=null) {










			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);










			flowFunctions = ffCache;



......@@ -222,16 +220,16 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 Collection<M> callees = icfg.getCalleesOfCallAt(n);










 for(M sCalledProcN: callees) { //still line 14










 //compute the call-flow function










 FlowFunction<D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 Set<AnnotatedFact<D>> res = computeCallFlowFunction(function, d1, d2);










 FlowFunction<FieldRef, D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 Set<AnnotatedFact<FieldRef, D>> res = computeCallFlowFunction(function, d1, d2);










 










 Collection<N> startPointsOf = icfg.getStartPointsOf(sCalledProcN);










 //for each result node of the call-flow function










 for(AnnotatedFact<D> d3: res) {










 for(AnnotatedFact<FieldRef, D> d3: res) {










 //for each callee's start point(s)










 for(N sP: startPointsOf) {










 //create initial self-loop










 D abstractStartPointFact = d3.getFact().cloneWithAccessPath();










 D abstractStartPointFact = d3.getFact().cloneWithAccessPath(new AccessPath<FieldRef>());










 propagate(abstractStartPointFact, sP, abstractStartPointFact, n, false); //line 15










 }










 



......@@ -260,9 +258,9 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, d4.get(), n)) {










 for(AnnotatedFact<FieldRef, D> d5: computeReturnFlowFunction(retFunction, d4.get(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 }



......@@ -275,8 +273,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //line 17-19 of Naeem/Lhotak/Rodriguez		










 //process intra-procedural flows along call-to-return flow functions










 for (N returnSiteN : returnSiteNs) {










 FlowFunction<D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 for(AnnotatedFact<D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))










 FlowFunction<FieldRef, D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 for(AnnotatedFact<FieldRef, D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))










 propagate(d1, returnSiteN, d3.getFact(), n, false);










 }










 }



......@@ -299,20 +297,22 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 for(final PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource())) {










 logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);










 










 FieldReference[] accessPathDelta = AccessPathUtil.getAccessPathDelta(










 incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());










 










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), accessPathDelta)) {










 propagate(zeroValue.equals(incomingEdge.getCallerSourceFact()) ? zeroValue : AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta), null, false);










 } else {










 pauseEdge(AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta));










 }










 final FieldRef[] delta = incomingEdge.getCalleeSourceFact().getAccessPath().getDeltaTo(edge.factAtSource().getAccessPath()); 










 Constraint<FieldRef> constraint = new Constraint<FieldRef>() {










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(delta).mergeExcludedFieldReferences(edge.factAtSource().getAccessPath());










 }










 };










 










 propagateConstrained(constraint, new PathEdge<N,D>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact()), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact())));










 }










 }










 }



......@@ -325,8 +325,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the callee's start node










	 */










 protected Set<AnnotatedFact<D>> computeCallFlowFunction










 (FlowFunction<D> callFlowFunction, D d1, D d2) {










 protected Set<AnnotatedFact<FieldRef, D>> computeCallFlowFunction










 (FlowFunction<FieldRef, D> callFlowFunction, D d1, D d2) {










 return callFlowFunction.computeTargets(d2);










 }














......@@ -339,8 +339,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<AnnotatedFact<D>> computeCallToReturnFlowFunction










 (FlowFunction<D> callToReturnFlowFunction, D d1, D d2) {










 protected Set<AnnotatedFact<FieldRef, D>> computeCallToReturnFlowFunction










 (FlowFunction<FieldRef, D> callToReturnFlowFunction, D d1, D d2) {










 return callToReturnFlowFunction.computeTargets(d2);










 }










 



......@@ -376,15 +376,15 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact())) {










 Optional<D> concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 if(concreteCalleeExitFact.isPresent()) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact.get(), callSite);










 Set<AnnotatedFact<FieldRef, D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact.get(), callSite);










 










 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 for (AnnotatedFact<FieldRef, D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }



......@@ -401,9 +401,9 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);










 for(N c: callers) {










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 Set<AnnotatedFact<D>> targets = computeReturnFlowFunction(retFunction, d2, c);










 for(AnnotatedFact<D> d5: targets)










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 Set<AnnotatedFact<FieldRef, D>> targets = computeReturnFlowFunction(retFunction, d2, c);










 for(AnnotatedFact<FieldRef, D> d5: targets)










 propagate(zeroValue, retSiteC, d5.getFact(), c, true);










 }










 }



......@@ -411,7 +411,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //this might be undesirable if the flow function has a side effect such as registering a taint;










 //instead we thus call the return flow function will a null caller










 if(callers.isEmpty()) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);










 retFunction.computeTargets(d2);










 }










 }



......@@ -425,8 +425,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param callSite The call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<AnnotatedFact<D>> computeReturnFlowFunction










 (FlowFunction<D> retFunction, D d2, N callSite) {










 protected Set<AnnotatedFact<FieldRef, D>> computeReturnFlowFunction










 (FlowFunction<FieldRef, D> retFunction, D d2, N callSite) {










 return retFunction.computeTargets(d2);










 }














......@@ -441,44 +441,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 final D d2 = edge.factAtTarget();










 










 for (N m : icfg.getSuccsOf(n)) {










 FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<AnnotatedFact<D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (AnnotatedFact<D> d3 : res) {










 //TODO: double check if concurrency issues may arise










 










 //if reading field f










 // if d1.f element of incoming edges:










 //    create and propagate (d1.f, d2.f)










 // else 










 //	  create and set (d1.f, d2.f) on hold










 //	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold










 










 if(d3.getReadField() != null) {










 SpecificFieldReference fieldRef = new SpecificFieldReference(d3.getReadField());










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(concretizedSourceValue, m, d3.getFact(), null, false);










 } else {










 pauseEdge(concretizedSourceValue, m, d3.getFact());










 }










 }










 else if(d3.getWrittenField() != null) {










 //TODO: double check if concurrency issues may arise










 










 // if writing field f










 // create edge e = (d1, d2.*\{f})










 // if d2.*\{f} element of incoming edges










 // 		continue with e










 // else 










 //		put e on hold










 // always kill (d1, d2)










 










 Any fieldRef = new Any(d3.getWrittenField());










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(d1, m, d3.getFact(), null, false);










 } else {










 pauseEdge(d1, m, d3.getFact());










 }










 FlowFunction<FieldRef, D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<AnnotatedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (AnnotatedFact<FieldRef, D> d3 : res) {










 if(d3.getConstraint() != null) {










 propagateConstrained(d3.getConstraint(), new PathEdge<>(applyConstraint(d3.getConstraint(), d1), m, d3.getFact()));










 }










 else










 propagate(d1, m, d3.getFact(), null, false);



......@@ -486,44 +453,54 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 }










 }










 










 private void pauseEdge(D sourceValue, N targetStmt, D targetValue) {










 M method = icfg.getMethodOf(targetStmt);










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 if(edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue))) {










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 }










 private D applyConstraint(Constraint<FieldRef> constraint, D fact) {










 if(fact.equals(zeroValue))










 return zeroValue;










 else










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath()));










 }










 










 private boolean propagateConstrained(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge) {










 M calleeMethod = icfg.getMethodOf(pathEdge.getTarget());










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, pathEdge.factAtSource(), constraint);





















 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, FieldReference... fieldRef) {










 M calleeMethod = icfg.getMethodOf(targetStmt);










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, calleeSourceFact, fieldRef);










 










 if(calleeSourceFact.equals(zeroValue))










 return true;










 










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 if(!incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue).isEmpty()) {










 return true;










 }










 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, concretizedSourceValue); 










 for (IncomingEdge<D, N> incomingEdge : inc) {










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), fieldRef)) {










 propagate(incomingEdge.getCallerSourceFact().equals(zeroValue) ? 










 incomingEdge.getCallerSourceFact() : 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef), null, false); 










 return true;










 boolean propagate = false;










 if(pathEdge.factAtSource().equals(zeroValue))










 propagate = true;










 else {










 Set<N> callSitesWithInterest = Sets.newHashSet();










 for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixedWith(calleeMethod, pathEdge.factAtSource())) {










 callSitesWithInterest.add(incEdge.getCallSite());










 }










 else {










 pauseEdge(cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef));










 propagate = !callSitesWithInterest.isEmpty();










 










 for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixesOf(calleeMethod, pathEdge.factAtSource())) {










 boolean equal = incEdge.getCalleeSourceFact().equals(pathEdge.factAtSource()); //TODO: write test case for this










 if(!equal && !callSitesWithInterest.contains(incEdge.getCallSite())) {










 PathEdge<N,D> callerEdge = new PathEdge<>(










 applyConstraint(constraint, incEdge.getCallerSourceFact()), 










 incEdge.getCallSite(), 










 applyConstraint(constraint, incEdge.getCallerCallSiteFact()));










 propagate |= propagateConstrained(constraint, callerEdge);










 }










 }










 }










 










 return false;










 if(propagate) {










 propagate(pathEdge.factAtSource(), pathEdge.getTarget(), pathEdge.factAtTarget(), null, false);










 return true;










 } else {










 pauseEdge(pathEdge);










 return false;










 }










 }










 










 private void pauseEdge(PathEdge<N,D> edge) {










 M method = icfg.getMethodOf(edge.getTarget());










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 if(edges.add(edge)) {










 logger.trace("PAUSED: {}: {}", method, edge);










 }










 }










 










 /**



......@@ -534,8 +511,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param d1 The abstraction at the current node










	 * @return The set of abstractions at the successor node










	 */










 protected Set<AnnotatedFact<D>> computeNormalFlowFunction










 (FlowFunction<D> flowFunction, D d1, D d2) {










 protected Set<AnnotatedFact<FieldRef, D>> computeNormalFlowFunction










 (FlowFunction<FieldRef, D> flowFunction, D d1, D d2) {










 return flowFunction.computeTargets(d2);










 }










 



......














src/heros/alias/FlowFunction.java








View file @ 1cd34e9e






......@@ -10,8 +10,6 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FieldReference.SpecificFieldReference;





















import java.util.LinkedHashSet;










import java.util.Set;














......@@ -33,18 +31,18 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {










public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<AnnotatedFact<D>> computeTargets(D source);










 Set<AnnotatedFact<FieldRef, D>> computeTargets(D source);










 










 public static class AnnotatedFact<D extends FieldSensitiveFact<?, D>> {










 //TODO: rename to ConstrainedFact










 public static class AnnotatedFact<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 private D fact;










 private String readField;










 private String writtenField;










 private Constraint<FieldRef> constraint;










 










 //TODO: Refactor API to make things more intuitive










 /**



......@@ -53,31 +51,25 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









		 * @param readField Giving a field reference here means the base value of a field access was tainted, i.e., we have to concretize the source value










		 * @param writtenField










		 */










 public AnnotatedFact(D fact, String readField, String writtenField) {










 public AnnotatedFact(D fact, Constraint<FieldRef> constraint) {










 this.fact = fact;










 this.readField = readField;










 this.writtenField = writtenField;










 this.constraint = constraint;










 }










 










 public D getFact() {










 return fact;










 }










 










 public String getReadField() {










 return readField;










 }










 










 public String getWrittenField() {










 return writtenField;










 public Constraint<FieldRef> getConstraint() {










 return constraint;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((constraint == null) ? 0 : constraint.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((readField == null) ? 0 : readField.hashCode());










 result = prime * result + ((writtenField == null) ? 0 : writtenField.hashCode());










 return result;










 }














......@@ -90,27 +82,66 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 if (!(obj instanceof AnnotatedFact))










 return false;










 AnnotatedFact other = (AnnotatedFact) obj;










 if (constraint == null) {










 if (other.constraint != null)










 return false;










 } else if (!constraint.equals(other.constraint))










 return false;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (readField == null) {










 if (other.readField != null)










 return false;










 } else if (!readField.equals(other.readField))










 return false;










 if (writtenField == null) {










 if (other.writtenField != null)










 return false;










 } else if (!writtenField.equals(other.writtenField))










 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return fact.toString()+"<"+readField+","+writtenField+">";










 return fact.toString()+"<"+constraint+">";










 }










 }










 










 public interface Constraint<FieldRef> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath);










 }










 










 public class WriteFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 private FieldRef fieldRef;





















 public WriteFieldConstraint(FieldRef fieldRef) {










 this.fieldRef = fieldRef;










 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 if(accPath.hasExclusions())










 return accPath.getExclusions(0).addExclusion(fieldRef);










 else










 return accPath.appendExcludedFieldReference(fieldRef);










 }










 










 @Override










 public String toString() {










 return "^"+fieldRef.toString();










 }










 }










 










 public class ReadFieldConstraint<FieldRef> implements Constraint<FieldRef> {





















 private FieldRef fieldRef;





















 public ReadFieldConstraint(FieldRef fieldRef) {










 this.fieldRef = fieldRef;










 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(fieldRef);










 }










 










 @Override










 public String toString() {










 return fieldRef.toString();










 }










 }










}














src/heros/alias/FlowFunctions.java








View file @ 1cd34e9e






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......@@ -40,7 +40,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<F> getNormalFlowFunction(Stmt curr, Stmt succ);










 public FlowFunction<FieldRef, F> getNormalFlowFunction(Stmt curr, Stmt succ);





















 










 /**



......@@ -52,7 +52,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);










 public FlowFunction<FieldRef, F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a



......@@ -82,7 +82,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 *            does not contain a caller for the method that is returned from.










	 * @return










	 */










 public FlowFunction<F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);










 public FlowFunction<FieldRef, F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a



......@@ -102,7 +102,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);










 public FlowFunction<FieldRef, F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);





















 










 



......














src/heros/alias/IFDSTabulationProblem.java








View file @ 1cd34e9e






......@@ -28,7 +28,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,D extends FieldSensitiveFact<?, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......@@ -37,7 +37,7 @@ public interface IFDSTabulationProblem<N,D extends FieldSensitiveFact<?, D>,M, I









	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 FlowFunctions<N,D,M> flowFunctions();










 FlowFunctions<N,FieldRef,D,M> flowFunctions();










 










 /**










	 * Returns the interprocedural control-flow graph which this problem is computed over.



......














src/heros/solver/CountLatch.java








View file @ 1cd34e9e






......@@ -72,7 +72,7 @@ public class CountLatch {









 }





















 public void awaitZero() throws InterruptedException {










 sync.acquireSharedInterruptibly(1);










 sync.acquireShared(1);










 }





















 public boolean awaitZero(long timeout, TimeUnit unit) throws InterruptedException {



......














test/heros/alias/AccessPathUtilTest.java








View file @ 1cd34e9e






......@@ -53,21 +53,22 @@ public class AccessPathUtilTest {









 










 @Test










 public void testDifferentExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.g")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.h")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.f.g")));










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a.g.g")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a.f.h")));










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^g")));










 }





















 @Test



......@@ -76,10 +77,15 @@ public class AccessPathUtilTest {









 }










 










 @Test










 public void testExclusionDoesNotRequireFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 assertTrue(isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 public void testExclusionRequiresFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a"), new Fact("a^f")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a")));










 










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 assertFalse(isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g^h")));










 assertFalse(isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 }










 










 @Test



......@@ -133,19 +139,4 @@ public class AccessPathUtilTest {









 public void testNullOnImpossibleSubsumption() {










 assertFalse(applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).isPresent());










 }










 










 @Test










 public void testConcretizeCallerSourceFact() {










 assertEquals(new Fact("0.f"), AccessPathUtil.concretizeCallerSourceFact(new IncomingEdge<>(new Fact("2"), null, new Fact("0"), null), new Fact("2.f")));










 }










 










 @Test










 public void testConcretizeCallerSourceFactIdentity() {










 assertEquals(new Fact("0.f"), AccessPathUtil.concretizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2.f")));










 }










 










 @Test(expected=IllegalArgumentException.class)










 public void testConcretizeCallerSourceFactNoPrefix() {










 AccessPathUtil.concretizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2"));










 }










}














test/heros/alias/Fact.java








View file @ 1cd34e9e






......@@ -20,15 +20,16 @@ import com.google.common.base.Joiner;









import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, Fact> {










public class Fact implements FieldSensitiveFact<String, String, Fact> {





















 public final String baseValue;










 public final FieldReference[] accessPath;










 public final AccessPath<String> accessPath;










 










 public Fact(String name) {










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 ArrayList<FieldReference> accessPath = Lists.newArrayList();










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();










 baseValue = name.substring(0, firstSeparator);



......@@ -39,23 +40,25 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 String identifier = matcher.group(2);










 










 if(separator.equals(".")) {










 accessPath.add(new FieldReference.SpecificFieldReference(identifier));










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(identifier);










 } else {










 accessPath.add(new FieldReference.Any(identifier.split(",")));










 addedExclusions=true;










 accessPath = accessPath.appendExcludedFieldReference(identifier.split(","));










 }










 }










 this.accessPath = accessPath.toArray(new FieldReference[accessPath.size()]);










 this.accessPath = accessPath;










 }










 










 public Fact(String baseValue, FieldReference[] accessPath) {










 public Fact(String baseValue, AccessPath<String> accessPath) {










 this.baseValue = baseValue;










 this.accessPath = accessPath;










 }





















 










 @Override










 public String toString() {










 return "[Fact "+baseValue+(accessPath.length>0 ? "."+Joiner.on(".").join(accessPath) : "" )+"]";










 return "[Fact "+baseValue+(accessPath.isEmpty() ? "" : accessPath)+"]";










 }





















 @Override



......@@ -64,30 +67,26 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 }





















 @Override










 public FieldReference[] getAccessPath() {










 public AccessPath<String> getAccessPath() {










 return accessPath;










 }
































 @Override










 public void addNeighbor(FieldSensitiveFact<String, Fact> originalAbstraction) {










 public void addNeighbor(Fact originalAbstraction) {










 










 }
































 @Override










 public void setCallingContext(FieldSensitiveFact<String, Fact> callingContext) {










 public void setCallingContext(Fact callingContext) {










 










 }
































 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accessPath);










 result = prime * result










 + ((baseValue == null) ? 0 : baseValue.hashCode());










 result = prime * result + ((accessPath == null) ? 0 : accessPath.hashCode());










 result = prime * result + ((baseValue == null) ? 0 : baseValue.hashCode());










 return result;










 }














......@@ -97,10 +96,13 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 if (!(obj instanceof Fact))










 return false;










 Fact other = (Fact) obj;










 if (!Arrays.equals(accessPath, other.accessPath))










 if (accessPath == null) {










 if (other.accessPath != null)










 return false;










 } else if (!accessPath.equals(other.accessPath))










 return false;










 if (baseValue == null) {










 if (other.baseValue != null)



......@@ -110,11 +112,8 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 return true;










 }






















































 @Override










 public Fact cloneWithAccessPath(FieldReference... accessPath) {










 public Fact cloneWithAccessPath(AccessPath<String> accessPath) {










 return new Fact(baseValue, accessPath);










 }










 



......














test/heros/alias/FieldSensitiveSolverTest.java








View file @ 1cd34e9e






......@@ -245,7 +245,7 @@ public class FieldSensitiveSolverTest {









 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2")));










 callSite("b").calls("bar", flow("1.f", "2"), flow("1.f^f", "2^f")));










 










 helper.method("bar",










 startPoints("c"),



......@@ -255,6 +255,44 @@ public class FieldSensitiveSolverTest {









 helper.runSolver(false, "a");










 }










 










 @Test










 public void pauseOnTransitiveExclusion() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("2", "3")));










 










 helper.method("xyz",










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", writeField("f"), "3^f")),










 normalStmt("e").succ("f")); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumePausedOnTransitiveExclusion() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("2", "3"), flow("2^f", "3^f")));










 










 helper.method("xyz",










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", writeField("f"), "3^f"), flow("3", "4")),










 callSite("e").calls("bar", flow("4", "2.g"), kill("3^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeEdgePausedOnOverwrittenField() {










 helper.method("foo",



......@@ -277,12 +315,12 @@ public class FieldSensitiveSolverTest {









 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")));










 callSite("e").calls("bar", flow("4", "2"), flow("4^f", "2^f")).retSite("f", kill("4"), kill("4^f") /*unwanted call2ret*/));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("3^f"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }



......














test/heros/alias/TestHelper.java








View file @ 1cd34e9e






......@@ -12,6 +12,7 @@ package heros.alias;




















import static org.junit.Assert.assertTrue;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.FlowFunction.Constraint;










import heros.alias.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.solver.IFDSSolver;



......@@ -89,22 +90,22 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static Pair<String, String> readField(String fieldName) {










 return new Pair<String, String>(fieldName, null);










 public static Constraint<String> readField(String fieldName) {










 return new FlowFunction.ReadFieldConstraint<String>(fieldName);










 }










 










 public static Pair<String, String> writeField(String fieldName) {










 return new Pair<String, String>(null, fieldName);










 public static Constraint<String> writeField(String fieldName) {










 return new FlowFunction.WriteFieldConstraint<String>(fieldName);










 }










 










 public static ExpectedFlowFunction flow(String source, Pair<String, String> fieldAccess, String... targets) {










 return flow(1, source, fieldAccess, targets);










 public static ExpectedFlowFunction flow(String source, Constraint<String> constraint, String... targets) {










 return flow(1, source, constraint, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Pair<String, String> fieldAccess, String... targets) {










 AnnotatedFact<Fact>[] targetFacts = new AnnotatedFact[targets.length];










 public static ExpectedFlowFunction flow(int times, String source, Constraint<String> constraint, String... targets) {










 AnnotatedFact<String, Fact>[] targetFacts = new AnnotatedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new AnnotatedFact<Fact>(new Fact(targets[i]), fieldAccess.getO1(), fieldAccess.getO2());










 targetFacts[i] = new AnnotatedFact<String, Fact>(new Fact(targets[i]), constraint);










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 }



......@@ -114,7 +115,7 @@ public class TestHelper {









 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new Pair<String, String>(null, null), targets);










 return flow(times, source, null, targets);










 }










 










 public static int times(int times) {



......@@ -301,11 +302,11 @@ public class TestHelper {









 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final AnnotatedFact<Fact>[] targets;










 public final AnnotatedFact<String, Fact>[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, AnnotatedFact<Fact>... targets) {










 public ExpectedFlowFunction(int times, Fact source, AnnotatedFact<String, Fact>... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;



......@@ -437,11 +438,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, Fact, Method>() {










 public FlowFunctions<Statement, String, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, String, Fact, Method>() {





















 @Override










 public FlowFunction<Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 public FlowFunction<String, Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -453,7 +454,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 public FlowFunction<String, Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr) && edge.succUnit.equals(succ)) {










 return createFlowFunction(edge);



......@@ -463,7 +464,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 public FlowFunction<String, Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -473,7 +474,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 public FlowFunction<String, Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -482,11 +483,11 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<Fact>() {










 private FlowFunction<String, Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<String, Fact>() {










 @Override










 public Set<AnnotatedFact<Fact>> computeTargets(Fact source) {










 Set<AnnotatedFact<Fact>> result = Sets.newHashSet();










 public Set<AnnotatedFact<String, Fact>> computeTargets(Fact source) {










 Set<AnnotatedFact<String, Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {



......@@ -509,17 +510,17 @@ public class TestHelper {









 }





















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 FieldSensitiveIFDSSolver<Statement, String,Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement, String,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 FieldSensitiveIFDSSolver<Statement, String, String, Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement,String,  String,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 solver.solve();










 assertAllFlowFunctionsUsed();










 }










 










 










 private IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 private IFDSTabulationProblem<Statement, String, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, Method> icfg = buildIcfg();










 final FlowFunctions<Statement, Fact, Method> flowFunctions = flowFunctions();










 final FlowFunctions<Statement, String, Fact, Method> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>() {










 return new IFDSTabulationProblem<Statement,String,  Fact, Method, InterproceduralCFG<Statement, Method>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -542,7 +543,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 public FlowFunctions<Statement,String,  Fact, Method> flowFunctions() {










 return flowFunctions;










 }














......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar


H


heros


H
H
heros




Project information




Project information




Activity


Labels


Members






Project information


Project information




Project information


Activity


Activity

Labels


Labels

Members


Members




Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare






Repository


Repository




Repository


Files


Files

Commits


Commits

Branches


Branches

Tags


Tags

Contributors


Contributors

Graph


Graph

Compare


Compare




Issues

0



Issues

0



List


Boards


Service Desk


Milestones






Issues
0


Issues

0



Issues

0
0

List


List

Boards


Boards

Service Desk


Service Desk

Milestones


Milestones




Merge requests

0



Merge requests

0





Merge requests
0


Merge requests

0



Merge requests

0
0




CI/CD




CI/CD




Pipelines


Jobs


Schedules






CI/CD


CI/CD




CI/CD


Pipelines


Pipelines

Jobs


Jobs

Schedules


Schedules




Deployments




Deployments




Environments


Releases






Deployments


Deployments




Deployments


Environments


Environments

Releases


Releases




Monitor




Monitor




Incidents






Monitor


Monitor




Monitor


Incidents


Incidents




Analytics




Analytics




Value stream


CI/CD


Repository






Analytics


Analytics




Analytics


Value stream


Value stream

CI/CD


CI/CD

Repository


Repository




Wiki




Wiki






Wiki


Wiki




Wiki


Activity

Graph

Create a new issue

Jobs

Commits

Issue Boards
Collapse sidebarClose sidebar




Open sidebar



Joshua Garcia heros
Commits

1cd34e9e















Commit
1cd34e9e


authored
Jan 07, 2015
by


Johannes Lerch



Browse files




cleaning code







parent
ec76098b













Changes
13




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPath.java



0 â†’ 100644







View file @ 1cd34e9e













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.collect.Sets;





















@SuppressWarnings("unchecked")










public class AccessPath<FieldRef> {





















 private FieldRef[] accesses;










 private Set<FieldRef>[] exclusions;










 










 public AccessPath() {










 accesses = (FieldRef[]) new Object[0];










 exclusions = new Set[0];










 }










 










 AccessPath(FieldRef[] accesses, Set<FieldRef>[] exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean hasExclusions() {










 return exclusions.length > 0;










 }










 










 public boolean isAccessInExclusions(FieldRef... fieldReferences) {










 for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 if(exclusions[i].contains(fieldReferences[i]))










 return true;










 } 










 return false;










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException();





















 FieldRef[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 Set<FieldRef>[] newExclusionsArray = exclusions.length < fieldReferences.length ? exclusions : Arrays.copyOfRange(exclusions, fieldReferences.length, exclusions.length); 










 return new AccessPath<FieldRef>(newAccesses, newExclusionsArray);










 }





















 public ExclusionSet getExclusions(int index) {










 return new ExclusionSet(index);










 }










 










 public AccessPath<FieldRef> appendExcludedFieldReference(FieldRef... fieldReferences) {










 Set<FieldRef>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);










 newExclusionsArray[exclusions.length] = Sets.newHashSet(fieldReferences);










 return new AccessPath<>(accesses, newExclusionsArray);










 }










 










 public boolean isPrefixOf(AccessPath<FieldRef> accessPath) {










 if(accesses.length > accessPath.accesses.length)










 return false;










 










 if(accesses.length + exclusions.length > accessPath.accesses.length + accessPath.exclusions.length)










 return false;










 










 for(int i=0; i<accesses.length; i++) {










 if(!accesses[i].equals(accessPath.accesses[i]))










 return false;










 }










 










 for(int i=0; i<exclusions.length; i++) {










 if(i+accesses.length < accessPath.accesses.length) {










 if(exclusions[i].contains(accessPath.accesses[i+accesses.length]))










 return false;










 }










 else {










 if(!exclusions[i].containsAll(accessPath.exclusions[i+accesses.length - accessPath.accesses.length]))










 return false;










 }










 }










 










 return true;










 }










 










 public FieldRef[] getDeltaTo(AccessPath<FieldRef> accPath) {










 if(isPrefixOf(accPath))










 return Arrays.copyOfRange(accPath.accesses, accesses.length, accPath.accesses.length);










 else










 throw new IllegalArgumentException("Given AccessPath must be a prefix of the current AccessPath");










 }










 










 public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {










 Set<FieldRef>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];










 for(int i=0; i<newExclusionArray.length; i++) {










 newExclusionArray[i] = Sets.newHashSet();










 if(i<exclusions.length)










 newExclusionArray[i].addAll(exclusions[i]);










 if(i<accPath.exclusions.length)










 newExclusionArray[i].addAll(accPath.exclusions[i]);










 }










 return new AccessPath<>(accesses, newExclusionArray);










 }










 










 public boolean isEmpty() {










 return exclusions.length == 0 && accesses.length == 0;










 }










 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + Arrays.hashCode(exclusions);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof AccessPath))










 return false;










 AccessPath other = (AccessPath) obj;










 if (!Arrays.equals(accesses, other.accesses))










 return false;










 if (!Arrays.equals(exclusions, other.exclusions))










 return false;










 return true;










 }





















 @Override










 public String toString() {










 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 for(Set<FieldRef> exclusion : exclusions) {










 result += "^" + Joiner.on(",").join(exclusion);










 }










 return result;










 }










 










 public class ExclusionSet {










 private int index;










 










 private ExclusionSet(int index) {










 this.index = index;










 }










 










 public AccessPath<FieldRef> addExclusion(FieldRef exclusion) {










 HashSet<FieldRef> newExclusions = Sets.newHashSet(exclusions[index]);










 newExclusions.add(exclusion);










 Set<FieldRef>[] newExclusionsArray = exclusions.clone();










 newExclusionsArray[index] = newExclusions;










 return new AccessPath<FieldRef>(accesses, newExclusionsArray);










 }










 }










}














src/heros/alias/AccessPathUtil.java








View file @ 1cd34e9e






......@@ -14,91 +14,57 @@ import java.util.ArrayList;




















import com.google.common.base.Optional;





















import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;





















public class AccessPathUtil {





















 public static <D extends FieldSensitiveFact<?, D>> boolean isPrefixOf(D prefixCandidate, D fact) {










 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> boolean isPrefixOf(D prefixCandidate, D fact) {










 if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue()))










 return false; 










 return false;










 










 FieldReference[] prefixAccessPath = prefixCandidate.getAccessPath();










 FieldReference[] factAccessPath = fact.getAccessPath();










 










 for(int i=0; i<prefixAccessPath.length; i++) {










 if(i < factAccessPath.length) {










 if(!prefixAccessPath[i].includes(factAccessPath[i]))










 return false;










 }










 else if(!(prefixAccessPath[i] instanceof Any))










 return false; 










 }










 










 return true;










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }










 










 public static <D extends FieldSensitiveFact<?, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 FieldReference[] concreteAccessPath = sourceFact.getAccessPath();










 FieldReference[] abstractAccessPath = summary.getSourceFact().getAccessPath();










 FieldReference[] targetAccessPath = summary.getTargetFact().getAccessPath();










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 FieldRef[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(targetAccessPath.isAccessInExclusions(delta))










 return Optional.absent();










 










 ArrayList<FieldReference> result = new ArrayList<>(targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length);










 int lastSpecificField = -1;










 for(int i=0; i< targetAccessPath.length; i++) {










 result.add(targetAccessPath[i]);










 if(targetAccessPath[i] instanceof SpecificFieldReference)










 lastSpecificField = i;










 }










 AccessPath<FieldRef> result = targetAccessPath.addFieldReference(delta);










 result = result.mergeExcludedFieldReferences(concreteAccessPath);










 










 for(int i=abstractAccessPath.length; i<concreteAccessPath.length; i++) {










 if(lastSpecificField+1 < result.size()) {










 Optional<? extends FieldReference> mergedFieldRef = concreteAccessPath[i].merge((Any) result.get(lastSpecificField+1));










 if(!mergedFieldRef.isPresent())










 return Optional.absent();










 










 result.set(lastSpecificField+1, mergedFieldRef.get());










 lastSpecificField++;










 } else {










 result.add(concreteAccessPath[i]);










 }










 }










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result.toArray(new FieldReference[result.size()])));










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <D extends FieldSensitiveFact<?, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {










 FieldReference[] accessPath = new FieldReference[fact.getAccessPath().length+fieldRefs.length];










 System.arraycopy(fact.getAccessPath(), 0, accessPath, 0, fact.getAccessPath().length);










 System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);










 return fact.cloneWithAccessPath(accessPath);










 }










//	public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {










//		FieldReference[] accessPath = new FieldReference[fact.getAccessPath().length+fieldRefs.length];










//		System.arraycopy(fact.getAccessPath(), 0, accessPath, 0, fact.getAccessPath().length);










//		System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);










//		return fact.cloneWithAccessPath(accessPath);










//	}










 










 public static <D extends FieldSensitiveFact<?, D>> D concretizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {










 if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))










 throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));










 










 FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();










 FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();










 FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();










 










 FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];





















 //copy old access path










 System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










 










 //copy delta access path that was omitted while creating the abstracted source fact










 System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










 










 return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










 }










 










 public static FieldReference[] getAccessPathDelta(FieldReference[] prefixAccessPath, FieldReference[] accessPath) {










 FieldReference[] result = new FieldReference[accessPath.length - prefixAccessPath.length];










 System.arraycopy(accessPath, prefixAccessPath.length, result, 0, result.length);










 return result;










 }










//	public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D concretizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {










//		if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))










//			throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));










//		










//		FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();










//		FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();










//		FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();










//		










//		FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];










//










//		//copy old access path










//		System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










//		










//		//copy delta access path that was omitted while creating the abstracted source fact










//		System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










//		










//		return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










//	}










}














src/heros/alias/FieldReference.java

deleted


100644 â†’ 0







View file @ ec76098b













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch, Johannes SpÃ¤th.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch, Johannes SpÃ¤th - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FieldReference.Any;





















import java.util.ArrayList;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.base.Optional;










import com.google.common.collect.Sets;





















public interface FieldReference {





















 boolean includes(FieldReference fieldReference);










 










 boolean isIncludedBy(SpecificFieldReference specificFieldRef);










 










 boolean isIncludedBy(Any anyFieldRef);










 










 Optional<? extends FieldReference> merge(Any fieldReference);










 










 public static class Any implements FieldReference {










 private Set<String> excludedFieldNames = Sets.newHashSet();










 










 public Any(String...excludedFieldNames) {










 for (int i = 0; i < excludedFieldNames.length; i++) {










 this.excludedFieldNames.add(excludedFieldNames[i]);










 }










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return false;










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return true;










 }










 










 public Optional<Any> merge(Any fieldReference) {










 ArrayList<String> list = new ArrayList<>(excludedFieldNames);










 list.addAll(fieldReference.excludedFieldNames);










 return Optional.of(new Any(list.toArray(new String[list.size()])));










 }










 










 @Override










 public String toString() {










 if(excludedFieldNames.size() == 0)










 return "";










 else if (excludedFieldNames.size() == 1)










 return "^" + excludedFieldNames.iterator().next();










 else










 return "^{" + Joiner.on(",").join(excludedFieldNames) +"}";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime










 * result










 + ((excludedFieldNames == null) ? 0 : excludedFieldNames










 .hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 Any other = (Any) obj;










 if (excludedFieldNames == null) {










 if (other.excludedFieldNames != null)










 return false;










 } else if (!excludedFieldNames.equals(other.excludedFieldNames))










 return false;










 return true;










 }










 }










 










 public static class SpecificFieldReference implements FieldReference {










 private String fieldName;





















 public SpecificFieldReference(String fieldName) {










 this.fieldName = fieldName;










 }





















 @Override










 public String toString() {










 return fieldName;










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return specificFieldRef.fieldName.equals(fieldName);










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return !anyFieldRef.excludedFieldNames.contains(fieldName);










 }










 










 public Optional<SpecificFieldReference> merge(Any fieldReference) {










 if(fieldReference.excludedFieldNames.contains(fieldName))










 return Optional.absent();










 else 










 return Optional.of(this);










 }










 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result










 + ((fieldName == null) ? 0 : fieldName.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 SpecificFieldReference other = (SpecificFieldReference) obj;










 if (fieldName == null) {










 if (other.fieldName != null)










 return false;










 } else if (!fieldName.equals(other.fieldName))










 return false;










 return true;










 }





















 }










}














src/heros/alias/FieldSensitiveFact.java








View file @ 1cd34e9e






......@@ -12,12 +12,12 @@ package heros.alias;




















import heros.solver.LinkedNode;





















public interface FieldSensitiveFact<BaseValue, D> extends LinkedNode<FieldSensitiveFact<BaseValue, D>>{










public interface FieldSensitiveFact<BaseValue, FieldRef, D> extends LinkedNode<D>{





















 BaseValue getBaseValue();










 










 FieldReference[] getAccessPath();










 AccessPath<FieldRef> getAccessPath();










 










 D cloneWithAccessPath(FieldReference... accessPath);










 D cloneWithAccessPath(AccessPath<FieldRef> accessPath);










 










}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 1cd34e9e






......@@ -10,14 +10,12 @@









 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPathUtil.cloneWithConcatenatedAccessPath;










import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.FlowFunction.Constraint;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.IFDSSolver;










import heros.solver.PathEdge;



......@@ -38,7 +36,7 @@ import com.google.common.base.Predicate;









import com.google.common.cache.CacheBuilder;










import com.google.common.collect.Sets;





















public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact<BaseValue, D>, M, I extends InterproceduralCFG<N, M>> {










public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {
































 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel



......@@ -75,7 +73,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 protected final MyConcurrentHashMap<M, Set<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, Set<PathEdge<N,D>>>();










 










 @DontSynchronize("stateless")










 protected final FlowFunctions<N, D, M> flowFunctions;










 protected final FlowFunctions<N, FieldRef, D, M> flowFunctions;










 










 @DontSynchronize("only used by single thread")










 protected final Map<N,Set<D>> initialSeeds;



......@@ -97,7 +95,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * Creates a solver for the given problem, which caches flow functions and edge functions.










	 * The solver must then be started by calling {@link #solve()}.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,D,M,I> tabulationProblem) {










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef, D,M,I> tabulationProblem) {










 this(tabulationProblem, DEFAULT_CACHE_BUILDER);










 }














......@@ -107,14 +105,14 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.










	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {










 if(logger.isDebugEnabled())










 flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();










 this.zeroValue = tabulationProblem.zeroValue();










 this.icfg = tabulationProblem.interproceduralCFG(); 










 /*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?










				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/ 










 FlowFunctions<N, D, M> flowFunctions = tabulationProblem.flowFunctions(); 










 FlowFunctions<N, FieldRef, D, M> flowFunctions = tabulationProblem.flowFunctions(); 










 /*if(flowFunctionCacheBuilder!=null) {










			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);










			flowFunctions = ffCache;



......@@ -222,16 +220,16 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 Collection<M> callees = icfg.getCalleesOfCallAt(n);










 for(M sCalledProcN: callees) { //still line 14










 //compute the call-flow function










 FlowFunction<D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 Set<AnnotatedFact<D>> res = computeCallFlowFunction(function, d1, d2);










 FlowFunction<FieldRef, D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 Set<AnnotatedFact<FieldRef, D>> res = computeCallFlowFunction(function, d1, d2);










 










 Collection<N> startPointsOf = icfg.getStartPointsOf(sCalledProcN);










 //for each result node of the call-flow function










 for(AnnotatedFact<D> d3: res) {










 for(AnnotatedFact<FieldRef, D> d3: res) {










 //for each callee's start point(s)










 for(N sP: startPointsOf) {










 //create initial self-loop










 D abstractStartPointFact = d3.getFact().cloneWithAccessPath();










 D abstractStartPointFact = d3.getFact().cloneWithAccessPath(new AccessPath<FieldRef>());










 propagate(abstractStartPointFact, sP, abstractStartPointFact, n, false); //line 15










 }










 



......@@ -260,9 +258,9 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, d4.get(), n)) {










 for(AnnotatedFact<FieldRef, D> d5: computeReturnFlowFunction(retFunction, d4.get(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 }



......@@ -275,8 +273,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //line 17-19 of Naeem/Lhotak/Rodriguez		










 //process intra-procedural flows along call-to-return flow functions










 for (N returnSiteN : returnSiteNs) {










 FlowFunction<D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 for(AnnotatedFact<D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))










 FlowFunction<FieldRef, D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 for(AnnotatedFact<FieldRef, D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))










 propagate(d1, returnSiteN, d3.getFact(), n, false);










 }










 }



......@@ -299,20 +297,22 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 for(final PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource())) {










 logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);










 










 FieldReference[] accessPathDelta = AccessPathUtil.getAccessPathDelta(










 incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());










 










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), accessPathDelta)) {










 propagate(zeroValue.equals(incomingEdge.getCallerSourceFact()) ? zeroValue : AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta), null, false);










 } else {










 pauseEdge(AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta));










 }










 final FieldRef[] delta = incomingEdge.getCalleeSourceFact().getAccessPath().getDeltaTo(edge.factAtSource().getAccessPath()); 










 Constraint<FieldRef> constraint = new Constraint<FieldRef>() {










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(delta).mergeExcludedFieldReferences(edge.factAtSource().getAccessPath());










 }










 };










 










 propagateConstrained(constraint, new PathEdge<N,D>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact()), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact())));










 }










 }










 }



......@@ -325,8 +325,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the callee's start node










	 */










 protected Set<AnnotatedFact<D>> computeCallFlowFunction










 (FlowFunction<D> callFlowFunction, D d1, D d2) {










 protected Set<AnnotatedFact<FieldRef, D>> computeCallFlowFunction










 (FlowFunction<FieldRef, D> callFlowFunction, D d1, D d2) {










 return callFlowFunction.computeTargets(d2);










 }














......@@ -339,8 +339,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<AnnotatedFact<D>> computeCallToReturnFlowFunction










 (FlowFunction<D> callToReturnFlowFunction, D d1, D d2) {










 protected Set<AnnotatedFact<FieldRef, D>> computeCallToReturnFlowFunction










 (FlowFunction<FieldRef, D> callToReturnFlowFunction, D d1, D d2) {










 return callToReturnFlowFunction.computeTargets(d2);










 }










 



......@@ -376,15 +376,15 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact())) {










 Optional<D> concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 if(concreteCalleeExitFact.isPresent()) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact.get(), callSite);










 Set<AnnotatedFact<FieldRef, D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact.get(), callSite);










 










 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 for (AnnotatedFact<FieldRef, D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }



......@@ -401,9 +401,9 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);










 for(N c: callers) {










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 Set<AnnotatedFact<D>> targets = computeReturnFlowFunction(retFunction, d2, c);










 for(AnnotatedFact<D> d5: targets)










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 Set<AnnotatedFact<FieldRef, D>> targets = computeReturnFlowFunction(retFunction, d2, c);










 for(AnnotatedFact<FieldRef, D> d5: targets)










 propagate(zeroValue, retSiteC, d5.getFact(), c, true);










 }










 }



......@@ -411,7 +411,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //this might be undesirable if the flow function has a side effect such as registering a taint;










 //instead we thus call the return flow function will a null caller










 if(callers.isEmpty()) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);










 retFunction.computeTargets(d2);










 }










 }



......@@ -425,8 +425,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param callSite The call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<AnnotatedFact<D>> computeReturnFlowFunction










 (FlowFunction<D> retFunction, D d2, N callSite) {










 protected Set<AnnotatedFact<FieldRef, D>> computeReturnFlowFunction










 (FlowFunction<FieldRef, D> retFunction, D d2, N callSite) {










 return retFunction.computeTargets(d2);










 }














......@@ -441,44 +441,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 final D d2 = edge.factAtTarget();










 










 for (N m : icfg.getSuccsOf(n)) {










 FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<AnnotatedFact<D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (AnnotatedFact<D> d3 : res) {










 //TODO: double check if concurrency issues may arise










 










 //if reading field f










 // if d1.f element of incoming edges:










 //    create and propagate (d1.f, d2.f)










 // else 










 //	  create and set (d1.f, d2.f) on hold










 //	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold










 










 if(d3.getReadField() != null) {










 SpecificFieldReference fieldRef = new SpecificFieldReference(d3.getReadField());










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(concretizedSourceValue, m, d3.getFact(), null, false);










 } else {










 pauseEdge(concretizedSourceValue, m, d3.getFact());










 }










 }










 else if(d3.getWrittenField() != null) {










 //TODO: double check if concurrency issues may arise










 










 // if writing field f










 // create edge e = (d1, d2.*\{f})










 // if d2.*\{f} element of incoming edges










 // 		continue with e










 // else 










 //		put e on hold










 // always kill (d1, d2)










 










 Any fieldRef = new Any(d3.getWrittenField());










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(d1, m, d3.getFact(), null, false);










 } else {










 pauseEdge(d1, m, d3.getFact());










 }










 FlowFunction<FieldRef, D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<AnnotatedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (AnnotatedFact<FieldRef, D> d3 : res) {










 if(d3.getConstraint() != null) {










 propagateConstrained(d3.getConstraint(), new PathEdge<>(applyConstraint(d3.getConstraint(), d1), m, d3.getFact()));










 }










 else










 propagate(d1, m, d3.getFact(), null, false);



......@@ -486,44 +453,54 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 }










 }










 










 private void pauseEdge(D sourceValue, N targetStmt, D targetValue) {










 M method = icfg.getMethodOf(targetStmt);










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 if(edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue))) {










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 }










 private D applyConstraint(Constraint<FieldRef> constraint, D fact) {










 if(fact.equals(zeroValue))










 return zeroValue;










 else










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath()));










 }










 










 private boolean propagateConstrained(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge) {










 M calleeMethod = icfg.getMethodOf(pathEdge.getTarget());










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, pathEdge.factAtSource(), constraint);





















 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, FieldReference... fieldRef) {










 M calleeMethod = icfg.getMethodOf(targetStmt);










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, calleeSourceFact, fieldRef);










 










 if(calleeSourceFact.equals(zeroValue))










 return true;










 










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 if(!incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue).isEmpty()) {










 return true;










 }










 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, concretizedSourceValue); 










 for (IncomingEdge<D, N> incomingEdge : inc) {










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), fieldRef)) {










 propagate(incomingEdge.getCallerSourceFact().equals(zeroValue) ? 










 incomingEdge.getCallerSourceFact() : 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef), null, false); 










 return true;










 boolean propagate = false;










 if(pathEdge.factAtSource().equals(zeroValue))










 propagate = true;










 else {










 Set<N> callSitesWithInterest = Sets.newHashSet();










 for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixedWith(calleeMethod, pathEdge.factAtSource())) {










 callSitesWithInterest.add(incEdge.getCallSite());










 }










 else {










 pauseEdge(cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef));










 propagate = !callSitesWithInterest.isEmpty();










 










 for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixesOf(calleeMethod, pathEdge.factAtSource())) {










 boolean equal = incEdge.getCalleeSourceFact().equals(pathEdge.factAtSource()); //TODO: write test case for this










 if(!equal && !callSitesWithInterest.contains(incEdge.getCallSite())) {










 PathEdge<N,D> callerEdge = new PathEdge<>(










 applyConstraint(constraint, incEdge.getCallerSourceFact()), 










 incEdge.getCallSite(), 










 applyConstraint(constraint, incEdge.getCallerCallSiteFact()));










 propagate |= propagateConstrained(constraint, callerEdge);










 }










 }










 }










 










 return false;










 if(propagate) {










 propagate(pathEdge.factAtSource(), pathEdge.getTarget(), pathEdge.factAtTarget(), null, false);










 return true;










 } else {










 pauseEdge(pathEdge);










 return false;










 }










 }










 










 private void pauseEdge(PathEdge<N,D> edge) {










 M method = icfg.getMethodOf(edge.getTarget());










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 if(edges.add(edge)) {










 logger.trace("PAUSED: {}: {}", method, edge);










 }










 }










 










 /**



......@@ -534,8 +511,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param d1 The abstraction at the current node










	 * @return The set of abstractions at the successor node










	 */










 protected Set<AnnotatedFact<D>> computeNormalFlowFunction










 (FlowFunction<D> flowFunction, D d1, D d2) {










 protected Set<AnnotatedFact<FieldRef, D>> computeNormalFlowFunction










 (FlowFunction<FieldRef, D> flowFunction, D d1, D d2) {










 return flowFunction.computeTargets(d2);










 }










 



......














src/heros/alias/FlowFunction.java








View file @ 1cd34e9e






......@@ -10,8 +10,6 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FieldReference.SpecificFieldReference;





















import java.util.LinkedHashSet;










import java.util.Set;














......@@ -33,18 +31,18 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {










public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<AnnotatedFact<D>> computeTargets(D source);










 Set<AnnotatedFact<FieldRef, D>> computeTargets(D source);










 










 public static class AnnotatedFact<D extends FieldSensitiveFact<?, D>> {










 //TODO: rename to ConstrainedFact










 public static class AnnotatedFact<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 private D fact;










 private String readField;










 private String writtenField;










 private Constraint<FieldRef> constraint;










 










 //TODO: Refactor API to make things more intuitive










 /**



......@@ -53,31 +51,25 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









		 * @param readField Giving a field reference here means the base value of a field access was tainted, i.e., we have to concretize the source value










		 * @param writtenField










		 */










 public AnnotatedFact(D fact, String readField, String writtenField) {










 public AnnotatedFact(D fact, Constraint<FieldRef> constraint) {










 this.fact = fact;










 this.readField = readField;










 this.writtenField = writtenField;










 this.constraint = constraint;










 }










 










 public D getFact() {










 return fact;










 }










 










 public String getReadField() {










 return readField;










 }










 










 public String getWrittenField() {










 return writtenField;










 public Constraint<FieldRef> getConstraint() {










 return constraint;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((constraint == null) ? 0 : constraint.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((readField == null) ? 0 : readField.hashCode());










 result = prime * result + ((writtenField == null) ? 0 : writtenField.hashCode());










 return result;










 }














......@@ -90,27 +82,66 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 if (!(obj instanceof AnnotatedFact))










 return false;










 AnnotatedFact other = (AnnotatedFact) obj;










 if (constraint == null) {










 if (other.constraint != null)










 return false;










 } else if (!constraint.equals(other.constraint))










 return false;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (readField == null) {










 if (other.readField != null)










 return false;










 } else if (!readField.equals(other.readField))










 return false;










 if (writtenField == null) {










 if (other.writtenField != null)










 return false;










 } else if (!writtenField.equals(other.writtenField))










 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return fact.toString()+"<"+readField+","+writtenField+">";










 return fact.toString()+"<"+constraint+">";










 }










 }










 










 public interface Constraint<FieldRef> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath);










 }










 










 public class WriteFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 private FieldRef fieldRef;





















 public WriteFieldConstraint(FieldRef fieldRef) {










 this.fieldRef = fieldRef;










 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 if(accPath.hasExclusions())










 return accPath.getExclusions(0).addExclusion(fieldRef);










 else










 return accPath.appendExcludedFieldReference(fieldRef);










 }










 










 @Override










 public String toString() {










 return "^"+fieldRef.toString();










 }










 }










 










 public class ReadFieldConstraint<FieldRef> implements Constraint<FieldRef> {





















 private FieldRef fieldRef;





















 public ReadFieldConstraint(FieldRef fieldRef) {










 this.fieldRef = fieldRef;










 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(fieldRef);










 }










 










 @Override










 public String toString() {










 return fieldRef.toString();










 }










 }










}














src/heros/alias/FlowFunctions.java








View file @ 1cd34e9e






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......@@ -40,7 +40,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<F> getNormalFlowFunction(Stmt curr, Stmt succ);










 public FlowFunction<FieldRef, F> getNormalFlowFunction(Stmt curr, Stmt succ);





















 










 /**



......@@ -52,7 +52,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);










 public FlowFunction<FieldRef, F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a



......@@ -82,7 +82,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 *            does not contain a caller for the method that is returned from.










	 * @return










	 */










 public FlowFunction<F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);










 public FlowFunction<FieldRef, F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a



......@@ -102,7 +102,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);










 public FlowFunction<FieldRef, F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);





















 










 



......














src/heros/alias/IFDSTabulationProblem.java








View file @ 1cd34e9e






......@@ -28,7 +28,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,D extends FieldSensitiveFact<?, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......@@ -37,7 +37,7 @@ public interface IFDSTabulationProblem<N,D extends FieldSensitiveFact<?, D>,M, I









	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 FlowFunctions<N,D,M> flowFunctions();










 FlowFunctions<N,FieldRef,D,M> flowFunctions();










 










 /**










	 * Returns the interprocedural control-flow graph which this problem is computed over.



......














src/heros/solver/CountLatch.java








View file @ 1cd34e9e






......@@ -72,7 +72,7 @@ public class CountLatch {









 }





















 public void awaitZero() throws InterruptedException {










 sync.acquireSharedInterruptibly(1);










 sync.acquireShared(1);










 }





















 public boolean awaitZero(long timeout, TimeUnit unit) throws InterruptedException {



......














test/heros/alias/AccessPathUtilTest.java








View file @ 1cd34e9e






......@@ -53,21 +53,22 @@ public class AccessPathUtilTest {









 










 @Test










 public void testDifferentExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.g")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.h")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.f.g")));










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a.g.g")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a.f.h")));










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^g")));










 }





















 @Test



......@@ -76,10 +77,15 @@ public class AccessPathUtilTest {









 }










 










 @Test










 public void testExclusionDoesNotRequireFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 assertTrue(isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 public void testExclusionRequiresFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a"), new Fact("a^f")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a")));










 










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 assertFalse(isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g^h")));










 assertFalse(isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 }










 










 @Test



......@@ -133,19 +139,4 @@ public class AccessPathUtilTest {









 public void testNullOnImpossibleSubsumption() {










 assertFalse(applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).isPresent());










 }










 










 @Test










 public void testConcretizeCallerSourceFact() {










 assertEquals(new Fact("0.f"), AccessPathUtil.concretizeCallerSourceFact(new IncomingEdge<>(new Fact("2"), null, new Fact("0"), null), new Fact("2.f")));










 }










 










 @Test










 public void testConcretizeCallerSourceFactIdentity() {










 assertEquals(new Fact("0.f"), AccessPathUtil.concretizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2.f")));










 }










 










 @Test(expected=IllegalArgumentException.class)










 public void testConcretizeCallerSourceFactNoPrefix() {










 AccessPathUtil.concretizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2"));










 }










}














test/heros/alias/Fact.java








View file @ 1cd34e9e






......@@ -20,15 +20,16 @@ import com.google.common.base.Joiner;









import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, Fact> {










public class Fact implements FieldSensitiveFact<String, String, Fact> {





















 public final String baseValue;










 public final FieldReference[] accessPath;










 public final AccessPath<String> accessPath;










 










 public Fact(String name) {










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 ArrayList<FieldReference> accessPath = Lists.newArrayList();










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();










 baseValue = name.substring(0, firstSeparator);



......@@ -39,23 +40,25 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 String identifier = matcher.group(2);










 










 if(separator.equals(".")) {










 accessPath.add(new FieldReference.SpecificFieldReference(identifier));










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(identifier);










 } else {










 accessPath.add(new FieldReference.Any(identifier.split(",")));










 addedExclusions=true;










 accessPath = accessPath.appendExcludedFieldReference(identifier.split(","));










 }










 }










 this.accessPath = accessPath.toArray(new FieldReference[accessPath.size()]);










 this.accessPath = accessPath;










 }










 










 public Fact(String baseValue, FieldReference[] accessPath) {










 public Fact(String baseValue, AccessPath<String> accessPath) {










 this.baseValue = baseValue;










 this.accessPath = accessPath;










 }





















 










 @Override










 public String toString() {










 return "[Fact "+baseValue+(accessPath.length>0 ? "."+Joiner.on(".").join(accessPath) : "" )+"]";










 return "[Fact "+baseValue+(accessPath.isEmpty() ? "" : accessPath)+"]";










 }





















 @Override



......@@ -64,30 +67,26 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 }





















 @Override










 public FieldReference[] getAccessPath() {










 public AccessPath<String> getAccessPath() {










 return accessPath;










 }
































 @Override










 public void addNeighbor(FieldSensitiveFact<String, Fact> originalAbstraction) {










 public void addNeighbor(Fact originalAbstraction) {










 










 }
































 @Override










 public void setCallingContext(FieldSensitiveFact<String, Fact> callingContext) {










 public void setCallingContext(Fact callingContext) {










 










 }
































 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accessPath);










 result = prime * result










 + ((baseValue == null) ? 0 : baseValue.hashCode());










 result = prime * result + ((accessPath == null) ? 0 : accessPath.hashCode());










 result = prime * result + ((baseValue == null) ? 0 : baseValue.hashCode());










 return result;










 }














......@@ -97,10 +96,13 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 if (!(obj instanceof Fact))










 return false;










 Fact other = (Fact) obj;










 if (!Arrays.equals(accessPath, other.accessPath))










 if (accessPath == null) {










 if (other.accessPath != null)










 return false;










 } else if (!accessPath.equals(other.accessPath))










 return false;










 if (baseValue == null) {










 if (other.baseValue != null)



......@@ -110,11 +112,8 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 return true;










 }






















































 @Override










 public Fact cloneWithAccessPath(FieldReference... accessPath) {










 public Fact cloneWithAccessPath(AccessPath<String> accessPath) {










 return new Fact(baseValue, accessPath);










 }










 



......














test/heros/alias/FieldSensitiveSolverTest.java








View file @ 1cd34e9e






......@@ -245,7 +245,7 @@ public class FieldSensitiveSolverTest {









 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2")));










 callSite("b").calls("bar", flow("1.f", "2"), flow("1.f^f", "2^f")));










 










 helper.method("bar",










 startPoints("c"),



......@@ -255,6 +255,44 @@ public class FieldSensitiveSolverTest {









 helper.runSolver(false, "a");










 }










 










 @Test










 public void pauseOnTransitiveExclusion() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("2", "3")));










 










 helper.method("xyz",










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", writeField("f"), "3^f")),










 normalStmt("e").succ("f")); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumePausedOnTransitiveExclusion() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("2", "3"), flow("2^f", "3^f")));










 










 helper.method("xyz",










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", writeField("f"), "3^f"), flow("3", "4")),










 callSite("e").calls("bar", flow("4", "2.g"), kill("3^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeEdgePausedOnOverwrittenField() {










 helper.method("foo",



......@@ -277,12 +315,12 @@ public class FieldSensitiveSolverTest {









 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")));










 callSite("e").calls("bar", flow("4", "2"), flow("4^f", "2^f")).retSite("f", kill("4"), kill("4^f") /*unwanted call2ret*/));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("3^f"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }



......














test/heros/alias/TestHelper.java








View file @ 1cd34e9e






......@@ -12,6 +12,7 @@ package heros.alias;




















import static org.junit.Assert.assertTrue;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.FlowFunction.Constraint;










import heros.alias.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.solver.IFDSSolver;



......@@ -89,22 +90,22 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static Pair<String, String> readField(String fieldName) {










 return new Pair<String, String>(fieldName, null);










 public static Constraint<String> readField(String fieldName) {










 return new FlowFunction.ReadFieldConstraint<String>(fieldName);










 }










 










 public static Pair<String, String> writeField(String fieldName) {










 return new Pair<String, String>(null, fieldName);










 public static Constraint<String> writeField(String fieldName) {










 return new FlowFunction.WriteFieldConstraint<String>(fieldName);










 }










 










 public static ExpectedFlowFunction flow(String source, Pair<String, String> fieldAccess, String... targets) {










 return flow(1, source, fieldAccess, targets);










 public static ExpectedFlowFunction flow(String source, Constraint<String> constraint, String... targets) {










 return flow(1, source, constraint, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Pair<String, String> fieldAccess, String... targets) {










 AnnotatedFact<Fact>[] targetFacts = new AnnotatedFact[targets.length];










 public static ExpectedFlowFunction flow(int times, String source, Constraint<String> constraint, String... targets) {










 AnnotatedFact<String, Fact>[] targetFacts = new AnnotatedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new AnnotatedFact<Fact>(new Fact(targets[i]), fieldAccess.getO1(), fieldAccess.getO2());










 targetFacts[i] = new AnnotatedFact<String, Fact>(new Fact(targets[i]), constraint);










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 }



......@@ -114,7 +115,7 @@ public class TestHelper {









 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new Pair<String, String>(null, null), targets);










 return flow(times, source, null, targets);










 }










 










 public static int times(int times) {



......@@ -301,11 +302,11 @@ public class TestHelper {









 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final AnnotatedFact<Fact>[] targets;










 public final AnnotatedFact<String, Fact>[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, AnnotatedFact<Fact>... targets) {










 public ExpectedFlowFunction(int times, Fact source, AnnotatedFact<String, Fact>... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;



......@@ -437,11 +438,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, Fact, Method>() {










 public FlowFunctions<Statement, String, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, String, Fact, Method>() {





















 @Override










 public FlowFunction<Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 public FlowFunction<String, Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -453,7 +454,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 public FlowFunction<String, Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr) && edge.succUnit.equals(succ)) {










 return createFlowFunction(edge);



......@@ -463,7 +464,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 public FlowFunction<String, Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -473,7 +474,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 public FlowFunction<String, Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -482,11 +483,11 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<Fact>() {










 private FlowFunction<String, Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<String, Fact>() {










 @Override










 public Set<AnnotatedFact<Fact>> computeTargets(Fact source) {










 Set<AnnotatedFact<Fact>> result = Sets.newHashSet();










 public Set<AnnotatedFact<String, Fact>> computeTargets(Fact source) {










 Set<AnnotatedFact<String, Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {



......@@ -509,17 +510,17 @@ public class TestHelper {









 }





















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 FieldSensitiveIFDSSolver<Statement, String,Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement, String,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 FieldSensitiveIFDSSolver<Statement, String, String, Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement,String,  String,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 solver.solve();










 assertAllFlowFunctionsUsed();










 }










 










 










 private IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 private IFDSTabulationProblem<Statement, String, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, Method> icfg = buildIcfg();










 final FlowFunctions<Statement, Fact, Method> flowFunctions = flowFunctions();










 final FlowFunctions<Statement, String, Fact, Method> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>() {










 return new IFDSTabulationProblem<Statement,String,  Fact, Method, InterproceduralCFG<Statement, Method>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -542,7 +543,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 public FlowFunctions<Statement,String,  Fact, Method> flowFunctions() {










 return flowFunctions;










 }














......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Open sidebar



Joshua Garcia heros
Commits

1cd34e9e







Open sidebar



Joshua Garcia heros
Commits

1cd34e9e




Open sidebar

Joshua Garcia heros
Commits

1cd34e9e


Joshua GarciaherosherosCommits
1cd34e9e








Commit
1cd34e9e


authored
Jan 07, 2015
by


Johannes Lerch



Browse files




cleaning code







parent
ec76098b













Changes
13




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPath.java



0 â†’ 100644







View file @ 1cd34e9e













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.collect.Sets;





















@SuppressWarnings("unchecked")










public class AccessPath<FieldRef> {





















 private FieldRef[] accesses;










 private Set<FieldRef>[] exclusions;










 










 public AccessPath() {










 accesses = (FieldRef[]) new Object[0];










 exclusions = new Set[0];










 }










 










 AccessPath(FieldRef[] accesses, Set<FieldRef>[] exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean hasExclusions() {










 return exclusions.length > 0;










 }










 










 public boolean isAccessInExclusions(FieldRef... fieldReferences) {










 for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 if(exclusions[i].contains(fieldReferences[i]))










 return true;










 } 










 return false;










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException();





















 FieldRef[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 Set<FieldRef>[] newExclusionsArray = exclusions.length < fieldReferences.length ? exclusions : Arrays.copyOfRange(exclusions, fieldReferences.length, exclusions.length); 










 return new AccessPath<FieldRef>(newAccesses, newExclusionsArray);










 }





















 public ExclusionSet getExclusions(int index) {










 return new ExclusionSet(index);










 }










 










 public AccessPath<FieldRef> appendExcludedFieldReference(FieldRef... fieldReferences) {










 Set<FieldRef>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);










 newExclusionsArray[exclusions.length] = Sets.newHashSet(fieldReferences);










 return new AccessPath<>(accesses, newExclusionsArray);










 }










 










 public boolean isPrefixOf(AccessPath<FieldRef> accessPath) {










 if(accesses.length > accessPath.accesses.length)










 return false;










 










 if(accesses.length + exclusions.length > accessPath.accesses.length + accessPath.exclusions.length)










 return false;










 










 for(int i=0; i<accesses.length; i++) {










 if(!accesses[i].equals(accessPath.accesses[i]))










 return false;










 }










 










 for(int i=0; i<exclusions.length; i++) {










 if(i+accesses.length < accessPath.accesses.length) {










 if(exclusions[i].contains(accessPath.accesses[i+accesses.length]))










 return false;










 }










 else {










 if(!exclusions[i].containsAll(accessPath.exclusions[i+accesses.length - accessPath.accesses.length]))










 return false;










 }










 }










 










 return true;










 }










 










 public FieldRef[] getDeltaTo(AccessPath<FieldRef> accPath) {










 if(isPrefixOf(accPath))










 return Arrays.copyOfRange(accPath.accesses, accesses.length, accPath.accesses.length);










 else










 throw new IllegalArgumentException("Given AccessPath must be a prefix of the current AccessPath");










 }










 










 public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {










 Set<FieldRef>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];










 for(int i=0; i<newExclusionArray.length; i++) {










 newExclusionArray[i] = Sets.newHashSet();










 if(i<exclusions.length)










 newExclusionArray[i].addAll(exclusions[i]);










 if(i<accPath.exclusions.length)










 newExclusionArray[i].addAll(accPath.exclusions[i]);










 }










 return new AccessPath<>(accesses, newExclusionArray);










 }










 










 public boolean isEmpty() {










 return exclusions.length == 0 && accesses.length == 0;










 }










 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + Arrays.hashCode(exclusions);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof AccessPath))










 return false;










 AccessPath other = (AccessPath) obj;










 if (!Arrays.equals(accesses, other.accesses))










 return false;










 if (!Arrays.equals(exclusions, other.exclusions))










 return false;










 return true;










 }





















 @Override










 public String toString() {










 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 for(Set<FieldRef> exclusion : exclusions) {










 result += "^" + Joiner.on(",").join(exclusion);










 }










 return result;










 }










 










 public class ExclusionSet {










 private int index;










 










 private ExclusionSet(int index) {










 this.index = index;










 }










 










 public AccessPath<FieldRef> addExclusion(FieldRef exclusion) {










 HashSet<FieldRef> newExclusions = Sets.newHashSet(exclusions[index]);










 newExclusions.add(exclusion);










 Set<FieldRef>[] newExclusionsArray = exclusions.clone();










 newExclusionsArray[index] = newExclusions;










 return new AccessPath<FieldRef>(accesses, newExclusionsArray);










 }










 }










}














src/heros/alias/AccessPathUtil.java








View file @ 1cd34e9e






......@@ -14,91 +14,57 @@ import java.util.ArrayList;




















import com.google.common.base.Optional;





















import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;





















public class AccessPathUtil {





















 public static <D extends FieldSensitiveFact<?, D>> boolean isPrefixOf(D prefixCandidate, D fact) {










 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> boolean isPrefixOf(D prefixCandidate, D fact) {










 if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue()))










 return false; 










 return false;










 










 FieldReference[] prefixAccessPath = prefixCandidate.getAccessPath();










 FieldReference[] factAccessPath = fact.getAccessPath();










 










 for(int i=0; i<prefixAccessPath.length; i++) {










 if(i < factAccessPath.length) {










 if(!prefixAccessPath[i].includes(factAccessPath[i]))










 return false;










 }










 else if(!(prefixAccessPath[i] instanceof Any))










 return false; 










 }










 










 return true;










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }










 










 public static <D extends FieldSensitiveFact<?, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 FieldReference[] concreteAccessPath = sourceFact.getAccessPath();










 FieldReference[] abstractAccessPath = summary.getSourceFact().getAccessPath();










 FieldReference[] targetAccessPath = summary.getTargetFact().getAccessPath();










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 FieldRef[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(targetAccessPath.isAccessInExclusions(delta))










 return Optional.absent();










 










 ArrayList<FieldReference> result = new ArrayList<>(targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length);










 int lastSpecificField = -1;










 for(int i=0; i< targetAccessPath.length; i++) {










 result.add(targetAccessPath[i]);










 if(targetAccessPath[i] instanceof SpecificFieldReference)










 lastSpecificField = i;










 }










 AccessPath<FieldRef> result = targetAccessPath.addFieldReference(delta);










 result = result.mergeExcludedFieldReferences(concreteAccessPath);










 










 for(int i=abstractAccessPath.length; i<concreteAccessPath.length; i++) {










 if(lastSpecificField+1 < result.size()) {










 Optional<? extends FieldReference> mergedFieldRef = concreteAccessPath[i].merge((Any) result.get(lastSpecificField+1));










 if(!mergedFieldRef.isPresent())










 return Optional.absent();










 










 result.set(lastSpecificField+1, mergedFieldRef.get());










 lastSpecificField++;










 } else {










 result.add(concreteAccessPath[i]);










 }










 }










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result.toArray(new FieldReference[result.size()])));










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <D extends FieldSensitiveFact<?, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {










 FieldReference[] accessPath = new FieldReference[fact.getAccessPath().length+fieldRefs.length];










 System.arraycopy(fact.getAccessPath(), 0, accessPath, 0, fact.getAccessPath().length);










 System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);










 return fact.cloneWithAccessPath(accessPath);










 }










//	public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {










//		FieldReference[] accessPath = new FieldReference[fact.getAccessPath().length+fieldRefs.length];










//		System.arraycopy(fact.getAccessPath(), 0, accessPath, 0, fact.getAccessPath().length);










//		System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);










//		return fact.cloneWithAccessPath(accessPath);










//	}










 










 public static <D extends FieldSensitiveFact<?, D>> D concretizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {










 if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))










 throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));










 










 FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();










 FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();










 FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();










 










 FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];





















 //copy old access path










 System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










 










 //copy delta access path that was omitted while creating the abstracted source fact










 System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










 










 return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










 }










 










 public static FieldReference[] getAccessPathDelta(FieldReference[] prefixAccessPath, FieldReference[] accessPath) {










 FieldReference[] result = new FieldReference[accessPath.length - prefixAccessPath.length];










 System.arraycopy(accessPath, prefixAccessPath.length, result, 0, result.length);










 return result;










 }










//	public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D concretizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {










//		if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))










//			throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));










//		










//		FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();










//		FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();










//		FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();










//		










//		FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];










//










//		//copy old access path










//		System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










//		










//		//copy delta access path that was omitted while creating the abstracted source fact










//		System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










//		










//		return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










//	}










}














src/heros/alias/FieldReference.java

deleted


100644 â†’ 0







View file @ ec76098b













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch, Johannes SpÃ¤th.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch, Johannes SpÃ¤th - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FieldReference.Any;





















import java.util.ArrayList;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.base.Optional;










import com.google.common.collect.Sets;





















public interface FieldReference {





















 boolean includes(FieldReference fieldReference);










 










 boolean isIncludedBy(SpecificFieldReference specificFieldRef);










 










 boolean isIncludedBy(Any anyFieldRef);










 










 Optional<? extends FieldReference> merge(Any fieldReference);










 










 public static class Any implements FieldReference {










 private Set<String> excludedFieldNames = Sets.newHashSet();










 










 public Any(String...excludedFieldNames) {










 for (int i = 0; i < excludedFieldNames.length; i++) {










 this.excludedFieldNames.add(excludedFieldNames[i]);










 }










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return false;










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return true;










 }










 










 public Optional<Any> merge(Any fieldReference) {










 ArrayList<String> list = new ArrayList<>(excludedFieldNames);










 list.addAll(fieldReference.excludedFieldNames);










 return Optional.of(new Any(list.toArray(new String[list.size()])));










 }










 










 @Override










 public String toString() {










 if(excludedFieldNames.size() == 0)










 return "";










 else if (excludedFieldNames.size() == 1)










 return "^" + excludedFieldNames.iterator().next();










 else










 return "^{" + Joiner.on(",").join(excludedFieldNames) +"}";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime










 * result










 + ((excludedFieldNames == null) ? 0 : excludedFieldNames










 .hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 Any other = (Any) obj;










 if (excludedFieldNames == null) {










 if (other.excludedFieldNames != null)










 return false;










 } else if (!excludedFieldNames.equals(other.excludedFieldNames))










 return false;










 return true;










 }










 }










 










 public static class SpecificFieldReference implements FieldReference {










 private String fieldName;





















 public SpecificFieldReference(String fieldName) {










 this.fieldName = fieldName;










 }





















 @Override










 public String toString() {










 return fieldName;










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return specificFieldRef.fieldName.equals(fieldName);










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return !anyFieldRef.excludedFieldNames.contains(fieldName);










 }










 










 public Optional<SpecificFieldReference> merge(Any fieldReference) {










 if(fieldReference.excludedFieldNames.contains(fieldName))










 return Optional.absent();










 else 










 return Optional.of(this);










 }










 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result










 + ((fieldName == null) ? 0 : fieldName.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 SpecificFieldReference other = (SpecificFieldReference) obj;










 if (fieldName == null) {










 if (other.fieldName != null)










 return false;










 } else if (!fieldName.equals(other.fieldName))










 return false;










 return true;










 }





















 }










}














src/heros/alias/FieldSensitiveFact.java








View file @ 1cd34e9e






......@@ -12,12 +12,12 @@ package heros.alias;




















import heros.solver.LinkedNode;





















public interface FieldSensitiveFact<BaseValue, D> extends LinkedNode<FieldSensitiveFact<BaseValue, D>>{










public interface FieldSensitiveFact<BaseValue, FieldRef, D> extends LinkedNode<D>{





















 BaseValue getBaseValue();










 










 FieldReference[] getAccessPath();










 AccessPath<FieldRef> getAccessPath();










 










 D cloneWithAccessPath(FieldReference... accessPath);










 D cloneWithAccessPath(AccessPath<FieldRef> accessPath);










 










}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 1cd34e9e






......@@ -10,14 +10,12 @@









 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPathUtil.cloneWithConcatenatedAccessPath;










import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.FlowFunction.Constraint;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.IFDSSolver;










import heros.solver.PathEdge;



......@@ -38,7 +36,7 @@ import com.google.common.base.Predicate;









import com.google.common.cache.CacheBuilder;










import com.google.common.collect.Sets;





















public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact<BaseValue, D>, M, I extends InterproceduralCFG<N, M>> {










public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {
































 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel



......@@ -75,7 +73,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 protected final MyConcurrentHashMap<M, Set<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, Set<PathEdge<N,D>>>();










 










 @DontSynchronize("stateless")










 protected final FlowFunctions<N, D, M> flowFunctions;










 protected final FlowFunctions<N, FieldRef, D, M> flowFunctions;










 










 @DontSynchronize("only used by single thread")










 protected final Map<N,Set<D>> initialSeeds;



......@@ -97,7 +95,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * Creates a solver for the given problem, which caches flow functions and edge functions.










	 * The solver must then be started by calling {@link #solve()}.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,D,M,I> tabulationProblem) {










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef, D,M,I> tabulationProblem) {










 this(tabulationProblem, DEFAULT_CACHE_BUILDER);










 }














......@@ -107,14 +105,14 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.










	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {










 if(logger.isDebugEnabled())










 flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();










 this.zeroValue = tabulationProblem.zeroValue();










 this.icfg = tabulationProblem.interproceduralCFG(); 










 /*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?










				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/ 










 FlowFunctions<N, D, M> flowFunctions = tabulationProblem.flowFunctions(); 










 FlowFunctions<N, FieldRef, D, M> flowFunctions = tabulationProblem.flowFunctions(); 










 /*if(flowFunctionCacheBuilder!=null) {










			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);










			flowFunctions = ffCache;



......@@ -222,16 +220,16 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 Collection<M> callees = icfg.getCalleesOfCallAt(n);










 for(M sCalledProcN: callees) { //still line 14










 //compute the call-flow function










 FlowFunction<D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 Set<AnnotatedFact<D>> res = computeCallFlowFunction(function, d1, d2);










 FlowFunction<FieldRef, D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 Set<AnnotatedFact<FieldRef, D>> res = computeCallFlowFunction(function, d1, d2);










 










 Collection<N> startPointsOf = icfg.getStartPointsOf(sCalledProcN);










 //for each result node of the call-flow function










 for(AnnotatedFact<D> d3: res) {










 for(AnnotatedFact<FieldRef, D> d3: res) {










 //for each callee's start point(s)










 for(N sP: startPointsOf) {










 //create initial self-loop










 D abstractStartPointFact = d3.getFact().cloneWithAccessPath();










 D abstractStartPointFact = d3.getFact().cloneWithAccessPath(new AccessPath<FieldRef>());










 propagate(abstractStartPointFact, sP, abstractStartPointFact, n, false); //line 15










 }










 



......@@ -260,9 +258,9 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, d4.get(), n)) {










 for(AnnotatedFact<FieldRef, D> d5: computeReturnFlowFunction(retFunction, d4.get(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 }



......@@ -275,8 +273,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //line 17-19 of Naeem/Lhotak/Rodriguez		










 //process intra-procedural flows along call-to-return flow functions










 for (N returnSiteN : returnSiteNs) {










 FlowFunction<D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 for(AnnotatedFact<D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))










 FlowFunction<FieldRef, D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 for(AnnotatedFact<FieldRef, D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))










 propagate(d1, returnSiteN, d3.getFact(), n, false);










 }










 }



......@@ -299,20 +297,22 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 for(final PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource())) {










 logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);










 










 FieldReference[] accessPathDelta = AccessPathUtil.getAccessPathDelta(










 incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());










 










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), accessPathDelta)) {










 propagate(zeroValue.equals(incomingEdge.getCallerSourceFact()) ? zeroValue : AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta), null, false);










 } else {










 pauseEdge(AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta));










 }










 final FieldRef[] delta = incomingEdge.getCalleeSourceFact().getAccessPath().getDeltaTo(edge.factAtSource().getAccessPath()); 










 Constraint<FieldRef> constraint = new Constraint<FieldRef>() {










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(delta).mergeExcludedFieldReferences(edge.factAtSource().getAccessPath());










 }










 };










 










 propagateConstrained(constraint, new PathEdge<N,D>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact()), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact())));










 }










 }










 }



......@@ -325,8 +325,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the callee's start node










	 */










 protected Set<AnnotatedFact<D>> computeCallFlowFunction










 (FlowFunction<D> callFlowFunction, D d1, D d2) {










 protected Set<AnnotatedFact<FieldRef, D>> computeCallFlowFunction










 (FlowFunction<FieldRef, D> callFlowFunction, D d1, D d2) {










 return callFlowFunction.computeTargets(d2);










 }














......@@ -339,8 +339,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<AnnotatedFact<D>> computeCallToReturnFlowFunction










 (FlowFunction<D> callToReturnFlowFunction, D d1, D d2) {










 protected Set<AnnotatedFact<FieldRef, D>> computeCallToReturnFlowFunction










 (FlowFunction<FieldRef, D> callToReturnFlowFunction, D d1, D d2) {










 return callToReturnFlowFunction.computeTargets(d2);










 }










 



......@@ -376,15 +376,15 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact())) {










 Optional<D> concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 if(concreteCalleeExitFact.isPresent()) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact.get(), callSite);










 Set<AnnotatedFact<FieldRef, D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact.get(), callSite);










 










 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 for (AnnotatedFact<FieldRef, D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }



......@@ -401,9 +401,9 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);










 for(N c: callers) {










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 Set<AnnotatedFact<D>> targets = computeReturnFlowFunction(retFunction, d2, c);










 for(AnnotatedFact<D> d5: targets)










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 Set<AnnotatedFact<FieldRef, D>> targets = computeReturnFlowFunction(retFunction, d2, c);










 for(AnnotatedFact<FieldRef, D> d5: targets)










 propagate(zeroValue, retSiteC, d5.getFact(), c, true);










 }










 }



......@@ -411,7 +411,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //this might be undesirable if the flow function has a side effect such as registering a taint;










 //instead we thus call the return flow function will a null caller










 if(callers.isEmpty()) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);










 retFunction.computeTargets(d2);










 }










 }



......@@ -425,8 +425,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param callSite The call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<AnnotatedFact<D>> computeReturnFlowFunction










 (FlowFunction<D> retFunction, D d2, N callSite) {










 protected Set<AnnotatedFact<FieldRef, D>> computeReturnFlowFunction










 (FlowFunction<FieldRef, D> retFunction, D d2, N callSite) {










 return retFunction.computeTargets(d2);










 }














......@@ -441,44 +441,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 final D d2 = edge.factAtTarget();










 










 for (N m : icfg.getSuccsOf(n)) {










 FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<AnnotatedFact<D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (AnnotatedFact<D> d3 : res) {










 //TODO: double check if concurrency issues may arise










 










 //if reading field f










 // if d1.f element of incoming edges:










 //    create and propagate (d1.f, d2.f)










 // else 










 //	  create and set (d1.f, d2.f) on hold










 //	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold










 










 if(d3.getReadField() != null) {










 SpecificFieldReference fieldRef = new SpecificFieldReference(d3.getReadField());










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(concretizedSourceValue, m, d3.getFact(), null, false);










 } else {










 pauseEdge(concretizedSourceValue, m, d3.getFact());










 }










 }










 else if(d3.getWrittenField() != null) {










 //TODO: double check if concurrency issues may arise










 










 // if writing field f










 // create edge e = (d1, d2.*\{f})










 // if d2.*\{f} element of incoming edges










 // 		continue with e










 // else 










 //		put e on hold










 // always kill (d1, d2)










 










 Any fieldRef = new Any(d3.getWrittenField());










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(d1, m, d3.getFact(), null, false);










 } else {










 pauseEdge(d1, m, d3.getFact());










 }










 FlowFunction<FieldRef, D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<AnnotatedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (AnnotatedFact<FieldRef, D> d3 : res) {










 if(d3.getConstraint() != null) {










 propagateConstrained(d3.getConstraint(), new PathEdge<>(applyConstraint(d3.getConstraint(), d1), m, d3.getFact()));










 }










 else










 propagate(d1, m, d3.getFact(), null, false);



......@@ -486,44 +453,54 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 }










 }










 










 private void pauseEdge(D sourceValue, N targetStmt, D targetValue) {










 M method = icfg.getMethodOf(targetStmt);










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 if(edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue))) {










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 }










 private D applyConstraint(Constraint<FieldRef> constraint, D fact) {










 if(fact.equals(zeroValue))










 return zeroValue;










 else










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath()));










 }










 










 private boolean propagateConstrained(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge) {










 M calleeMethod = icfg.getMethodOf(pathEdge.getTarget());










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, pathEdge.factAtSource(), constraint);





















 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, FieldReference... fieldRef) {










 M calleeMethod = icfg.getMethodOf(targetStmt);










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, calleeSourceFact, fieldRef);










 










 if(calleeSourceFact.equals(zeroValue))










 return true;










 










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 if(!incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue).isEmpty()) {










 return true;










 }










 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, concretizedSourceValue); 










 for (IncomingEdge<D, N> incomingEdge : inc) {










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), fieldRef)) {










 propagate(incomingEdge.getCallerSourceFact().equals(zeroValue) ? 










 incomingEdge.getCallerSourceFact() : 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef), null, false); 










 return true;










 boolean propagate = false;










 if(pathEdge.factAtSource().equals(zeroValue))










 propagate = true;










 else {










 Set<N> callSitesWithInterest = Sets.newHashSet();










 for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixedWith(calleeMethod, pathEdge.factAtSource())) {










 callSitesWithInterest.add(incEdge.getCallSite());










 }










 else {










 pauseEdge(cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef));










 propagate = !callSitesWithInterest.isEmpty();










 










 for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixesOf(calleeMethod, pathEdge.factAtSource())) {










 boolean equal = incEdge.getCalleeSourceFact().equals(pathEdge.factAtSource()); //TODO: write test case for this










 if(!equal && !callSitesWithInterest.contains(incEdge.getCallSite())) {










 PathEdge<N,D> callerEdge = new PathEdge<>(










 applyConstraint(constraint, incEdge.getCallerSourceFact()), 










 incEdge.getCallSite(), 










 applyConstraint(constraint, incEdge.getCallerCallSiteFact()));










 propagate |= propagateConstrained(constraint, callerEdge);










 }










 }










 }










 










 return false;










 if(propagate) {










 propagate(pathEdge.factAtSource(), pathEdge.getTarget(), pathEdge.factAtTarget(), null, false);










 return true;










 } else {










 pauseEdge(pathEdge);










 return false;










 }










 }










 










 private void pauseEdge(PathEdge<N,D> edge) {










 M method = icfg.getMethodOf(edge.getTarget());










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 if(edges.add(edge)) {










 logger.trace("PAUSED: {}: {}", method, edge);










 }










 }










 










 /**



......@@ -534,8 +511,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param d1 The abstraction at the current node










	 * @return The set of abstractions at the successor node










	 */










 protected Set<AnnotatedFact<D>> computeNormalFlowFunction










 (FlowFunction<D> flowFunction, D d1, D d2) {










 protected Set<AnnotatedFact<FieldRef, D>> computeNormalFlowFunction










 (FlowFunction<FieldRef, D> flowFunction, D d1, D d2) {










 return flowFunction.computeTargets(d2);










 }










 



......














src/heros/alias/FlowFunction.java








View file @ 1cd34e9e






......@@ -10,8 +10,6 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FieldReference.SpecificFieldReference;





















import java.util.LinkedHashSet;










import java.util.Set;














......@@ -33,18 +31,18 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {










public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<AnnotatedFact<D>> computeTargets(D source);










 Set<AnnotatedFact<FieldRef, D>> computeTargets(D source);










 










 public static class AnnotatedFact<D extends FieldSensitiveFact<?, D>> {










 //TODO: rename to ConstrainedFact










 public static class AnnotatedFact<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 private D fact;










 private String readField;










 private String writtenField;










 private Constraint<FieldRef> constraint;










 










 //TODO: Refactor API to make things more intuitive










 /**



......@@ -53,31 +51,25 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









		 * @param readField Giving a field reference here means the base value of a field access was tainted, i.e., we have to concretize the source value










		 * @param writtenField










		 */










 public AnnotatedFact(D fact, String readField, String writtenField) {










 public AnnotatedFact(D fact, Constraint<FieldRef> constraint) {










 this.fact = fact;










 this.readField = readField;










 this.writtenField = writtenField;










 this.constraint = constraint;










 }










 










 public D getFact() {










 return fact;










 }










 










 public String getReadField() {










 return readField;










 }










 










 public String getWrittenField() {










 return writtenField;










 public Constraint<FieldRef> getConstraint() {










 return constraint;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((constraint == null) ? 0 : constraint.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((readField == null) ? 0 : readField.hashCode());










 result = prime * result + ((writtenField == null) ? 0 : writtenField.hashCode());










 return result;










 }














......@@ -90,27 +82,66 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 if (!(obj instanceof AnnotatedFact))










 return false;










 AnnotatedFact other = (AnnotatedFact) obj;










 if (constraint == null) {










 if (other.constraint != null)










 return false;










 } else if (!constraint.equals(other.constraint))










 return false;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (readField == null) {










 if (other.readField != null)










 return false;










 } else if (!readField.equals(other.readField))










 return false;










 if (writtenField == null) {










 if (other.writtenField != null)










 return false;










 } else if (!writtenField.equals(other.writtenField))










 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return fact.toString()+"<"+readField+","+writtenField+">";










 return fact.toString()+"<"+constraint+">";










 }










 }










 










 public interface Constraint<FieldRef> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath);










 }










 










 public class WriteFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 private FieldRef fieldRef;





















 public WriteFieldConstraint(FieldRef fieldRef) {










 this.fieldRef = fieldRef;










 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 if(accPath.hasExclusions())










 return accPath.getExclusions(0).addExclusion(fieldRef);










 else










 return accPath.appendExcludedFieldReference(fieldRef);










 }










 










 @Override










 public String toString() {










 return "^"+fieldRef.toString();










 }










 }










 










 public class ReadFieldConstraint<FieldRef> implements Constraint<FieldRef> {





















 private FieldRef fieldRef;





















 public ReadFieldConstraint(FieldRef fieldRef) {










 this.fieldRef = fieldRef;










 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(fieldRef);










 }










 










 @Override










 public String toString() {










 return fieldRef.toString();










 }










 }










}














src/heros/alias/FlowFunctions.java








View file @ 1cd34e9e






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......@@ -40,7 +40,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<F> getNormalFlowFunction(Stmt curr, Stmt succ);










 public FlowFunction<FieldRef, F> getNormalFlowFunction(Stmt curr, Stmt succ);





















 










 /**



......@@ -52,7 +52,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);










 public FlowFunction<FieldRef, F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a



......@@ -82,7 +82,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 *            does not contain a caller for the method that is returned from.










	 * @return










	 */










 public FlowFunction<F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);










 public FlowFunction<FieldRef, F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a



......@@ -102,7 +102,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);










 public FlowFunction<FieldRef, F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);





















 










 



......














src/heros/alias/IFDSTabulationProblem.java








View file @ 1cd34e9e






......@@ -28,7 +28,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,D extends FieldSensitiveFact<?, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......@@ -37,7 +37,7 @@ public interface IFDSTabulationProblem<N,D extends FieldSensitiveFact<?, D>,M, I









	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 FlowFunctions<N,D,M> flowFunctions();










 FlowFunctions<N,FieldRef,D,M> flowFunctions();










 










 /**










	 * Returns the interprocedural control-flow graph which this problem is computed over.



......














src/heros/solver/CountLatch.java








View file @ 1cd34e9e






......@@ -72,7 +72,7 @@ public class CountLatch {









 }





















 public void awaitZero() throws InterruptedException {










 sync.acquireSharedInterruptibly(1);










 sync.acquireShared(1);










 }





















 public boolean awaitZero(long timeout, TimeUnit unit) throws InterruptedException {



......














test/heros/alias/AccessPathUtilTest.java








View file @ 1cd34e9e






......@@ -53,21 +53,22 @@ public class AccessPathUtilTest {









 










 @Test










 public void testDifferentExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.g")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.h")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.f.g")));










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a.g.g")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a.f.h")));










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^g")));










 }





















 @Test



......@@ -76,10 +77,15 @@ public class AccessPathUtilTest {









 }










 










 @Test










 public void testExclusionDoesNotRequireFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 assertTrue(isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 public void testExclusionRequiresFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a"), new Fact("a^f")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a")));










 










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 assertFalse(isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g^h")));










 assertFalse(isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 }










 










 @Test



......@@ -133,19 +139,4 @@ public class AccessPathUtilTest {









 public void testNullOnImpossibleSubsumption() {










 assertFalse(applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).isPresent());










 }










 










 @Test










 public void testConcretizeCallerSourceFact() {










 assertEquals(new Fact("0.f"), AccessPathUtil.concretizeCallerSourceFact(new IncomingEdge<>(new Fact("2"), null, new Fact("0"), null), new Fact("2.f")));










 }










 










 @Test










 public void testConcretizeCallerSourceFactIdentity() {










 assertEquals(new Fact("0.f"), AccessPathUtil.concretizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2.f")));










 }










 










 @Test(expected=IllegalArgumentException.class)










 public void testConcretizeCallerSourceFactNoPrefix() {










 AccessPathUtil.concretizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2"));










 }










}














test/heros/alias/Fact.java








View file @ 1cd34e9e






......@@ -20,15 +20,16 @@ import com.google.common.base.Joiner;









import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, Fact> {










public class Fact implements FieldSensitiveFact<String, String, Fact> {





















 public final String baseValue;










 public final FieldReference[] accessPath;










 public final AccessPath<String> accessPath;










 










 public Fact(String name) {










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 ArrayList<FieldReference> accessPath = Lists.newArrayList();










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();










 baseValue = name.substring(0, firstSeparator);



......@@ -39,23 +40,25 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 String identifier = matcher.group(2);










 










 if(separator.equals(".")) {










 accessPath.add(new FieldReference.SpecificFieldReference(identifier));










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(identifier);










 } else {










 accessPath.add(new FieldReference.Any(identifier.split(",")));










 addedExclusions=true;










 accessPath = accessPath.appendExcludedFieldReference(identifier.split(","));










 }










 }










 this.accessPath = accessPath.toArray(new FieldReference[accessPath.size()]);










 this.accessPath = accessPath;










 }










 










 public Fact(String baseValue, FieldReference[] accessPath) {










 public Fact(String baseValue, AccessPath<String> accessPath) {










 this.baseValue = baseValue;










 this.accessPath = accessPath;










 }





















 










 @Override










 public String toString() {










 return "[Fact "+baseValue+(accessPath.length>0 ? "."+Joiner.on(".").join(accessPath) : "" )+"]";










 return "[Fact "+baseValue+(accessPath.isEmpty() ? "" : accessPath)+"]";










 }





















 @Override



......@@ -64,30 +67,26 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 }





















 @Override










 public FieldReference[] getAccessPath() {










 public AccessPath<String> getAccessPath() {










 return accessPath;










 }
































 @Override










 public void addNeighbor(FieldSensitiveFact<String, Fact> originalAbstraction) {










 public void addNeighbor(Fact originalAbstraction) {










 










 }
































 @Override










 public void setCallingContext(FieldSensitiveFact<String, Fact> callingContext) {










 public void setCallingContext(Fact callingContext) {










 










 }
































 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accessPath);










 result = prime * result










 + ((baseValue == null) ? 0 : baseValue.hashCode());










 result = prime * result + ((accessPath == null) ? 0 : accessPath.hashCode());










 result = prime * result + ((baseValue == null) ? 0 : baseValue.hashCode());










 return result;










 }














......@@ -97,10 +96,13 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 if (!(obj instanceof Fact))










 return false;










 Fact other = (Fact) obj;










 if (!Arrays.equals(accessPath, other.accessPath))










 if (accessPath == null) {










 if (other.accessPath != null)










 return false;










 } else if (!accessPath.equals(other.accessPath))










 return false;










 if (baseValue == null) {










 if (other.baseValue != null)



......@@ -110,11 +112,8 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 return true;










 }






















































 @Override










 public Fact cloneWithAccessPath(FieldReference... accessPath) {










 public Fact cloneWithAccessPath(AccessPath<String> accessPath) {










 return new Fact(baseValue, accessPath);










 }










 



......














test/heros/alias/FieldSensitiveSolverTest.java








View file @ 1cd34e9e






......@@ -245,7 +245,7 @@ public class FieldSensitiveSolverTest {









 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2")));










 callSite("b").calls("bar", flow("1.f", "2"), flow("1.f^f", "2^f")));










 










 helper.method("bar",










 startPoints("c"),



......@@ -255,6 +255,44 @@ public class FieldSensitiveSolverTest {









 helper.runSolver(false, "a");










 }










 










 @Test










 public void pauseOnTransitiveExclusion() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("2", "3")));










 










 helper.method("xyz",










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", writeField("f"), "3^f")),










 normalStmt("e").succ("f")); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumePausedOnTransitiveExclusion() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("2", "3"), flow("2^f", "3^f")));










 










 helper.method("xyz",










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", writeField("f"), "3^f"), flow("3", "4")),










 callSite("e").calls("bar", flow("4", "2.g"), kill("3^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeEdgePausedOnOverwrittenField() {










 helper.method("foo",



......@@ -277,12 +315,12 @@ public class FieldSensitiveSolverTest {









 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")));










 callSite("e").calls("bar", flow("4", "2"), flow("4^f", "2^f")).retSite("f", kill("4"), kill("4^f") /*unwanted call2ret*/));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("3^f"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }



......














test/heros/alias/TestHelper.java








View file @ 1cd34e9e






......@@ -12,6 +12,7 @@ package heros.alias;




















import static org.junit.Assert.assertTrue;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.FlowFunction.Constraint;










import heros.alias.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.solver.IFDSSolver;



......@@ -89,22 +90,22 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static Pair<String, String> readField(String fieldName) {










 return new Pair<String, String>(fieldName, null);










 public static Constraint<String> readField(String fieldName) {










 return new FlowFunction.ReadFieldConstraint<String>(fieldName);










 }










 










 public static Pair<String, String> writeField(String fieldName) {










 return new Pair<String, String>(null, fieldName);










 public static Constraint<String> writeField(String fieldName) {










 return new FlowFunction.WriteFieldConstraint<String>(fieldName);










 }










 










 public static ExpectedFlowFunction flow(String source, Pair<String, String> fieldAccess, String... targets) {










 return flow(1, source, fieldAccess, targets);










 public static ExpectedFlowFunction flow(String source, Constraint<String> constraint, String... targets) {










 return flow(1, source, constraint, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Pair<String, String> fieldAccess, String... targets) {










 AnnotatedFact<Fact>[] targetFacts = new AnnotatedFact[targets.length];










 public static ExpectedFlowFunction flow(int times, String source, Constraint<String> constraint, String... targets) {










 AnnotatedFact<String, Fact>[] targetFacts = new AnnotatedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new AnnotatedFact<Fact>(new Fact(targets[i]), fieldAccess.getO1(), fieldAccess.getO2());










 targetFacts[i] = new AnnotatedFact<String, Fact>(new Fact(targets[i]), constraint);










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 }



......@@ -114,7 +115,7 @@ public class TestHelper {









 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new Pair<String, String>(null, null), targets);










 return flow(times, source, null, targets);










 }










 










 public static int times(int times) {



......@@ -301,11 +302,11 @@ public class TestHelper {









 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final AnnotatedFact<Fact>[] targets;










 public final AnnotatedFact<String, Fact>[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, AnnotatedFact<Fact>... targets) {










 public ExpectedFlowFunction(int times, Fact source, AnnotatedFact<String, Fact>... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;



......@@ -437,11 +438,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, Fact, Method>() {










 public FlowFunctions<Statement, String, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, String, Fact, Method>() {





















 @Override










 public FlowFunction<Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 public FlowFunction<String, Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -453,7 +454,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 public FlowFunction<String, Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr) && edge.succUnit.equals(succ)) {










 return createFlowFunction(edge);



......@@ -463,7 +464,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 public FlowFunction<String, Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -473,7 +474,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 public FlowFunction<String, Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -482,11 +483,11 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<Fact>() {










 private FlowFunction<String, Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<String, Fact>() {










 @Override










 public Set<AnnotatedFact<Fact>> computeTargets(Fact source) {










 Set<AnnotatedFact<Fact>> result = Sets.newHashSet();










 public Set<AnnotatedFact<String, Fact>> computeTargets(Fact source) {










 Set<AnnotatedFact<String, Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {



......@@ -509,17 +510,17 @@ public class TestHelper {









 }





















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 FieldSensitiveIFDSSolver<Statement, String,Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement, String,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 FieldSensitiveIFDSSolver<Statement, String, String, Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement,String,  String,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 solver.solve();










 assertAllFlowFunctionsUsed();










 }










 










 










 private IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 private IFDSTabulationProblem<Statement, String, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, Method> icfg = buildIcfg();










 final FlowFunctions<Statement, Fact, Method> flowFunctions = flowFunctions();










 final FlowFunctions<Statement, String, Fact, Method> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>() {










 return new IFDSTabulationProblem<Statement,String,  Fact, Method, InterproceduralCFG<Statement, Method>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -542,7 +543,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 public FlowFunctions<Statement,String,  Fact, Method> flowFunctions() {










 return flowFunctions;










 }














......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










Commit
1cd34e9e


authored
Jan 07, 2015
by


Johannes Lerch



Browse files




cleaning code







parent
ec76098b













Changes
13




Hide whitespace changes

Inline
Side-by-side















src/heros/alias/AccessPath.java



0 â†’ 100644







View file @ 1cd34e9e













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.collect.Sets;





















@SuppressWarnings("unchecked")










public class AccessPath<FieldRef> {





















 private FieldRef[] accesses;










 private Set<FieldRef>[] exclusions;










 










 public AccessPath() {










 accesses = (FieldRef[]) new Object[0];










 exclusions = new Set[0];










 }










 










 AccessPath(FieldRef[] accesses, Set<FieldRef>[] exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean hasExclusions() {










 return exclusions.length > 0;










 }










 










 public boolean isAccessInExclusions(FieldRef... fieldReferences) {










 for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 if(exclusions[i].contains(fieldReferences[i]))










 return true;










 } 










 return false;










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException();





















 FieldRef[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 Set<FieldRef>[] newExclusionsArray = exclusions.length < fieldReferences.length ? exclusions : Arrays.copyOfRange(exclusions, fieldReferences.length, exclusions.length); 










 return new AccessPath<FieldRef>(newAccesses, newExclusionsArray);










 }





















 public ExclusionSet getExclusions(int index) {










 return new ExclusionSet(index);










 }










 










 public AccessPath<FieldRef> appendExcludedFieldReference(FieldRef... fieldReferences) {










 Set<FieldRef>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);










 newExclusionsArray[exclusions.length] = Sets.newHashSet(fieldReferences);










 return new AccessPath<>(accesses, newExclusionsArray);










 }










 










 public boolean isPrefixOf(AccessPath<FieldRef> accessPath) {










 if(accesses.length > accessPath.accesses.length)










 return false;










 










 if(accesses.length + exclusions.length > accessPath.accesses.length + accessPath.exclusions.length)










 return false;










 










 for(int i=0; i<accesses.length; i++) {










 if(!accesses[i].equals(accessPath.accesses[i]))










 return false;










 }










 










 for(int i=0; i<exclusions.length; i++) {










 if(i+accesses.length < accessPath.accesses.length) {










 if(exclusions[i].contains(accessPath.accesses[i+accesses.length]))










 return false;










 }










 else {










 if(!exclusions[i].containsAll(accessPath.exclusions[i+accesses.length - accessPath.accesses.length]))










 return false;










 }










 }










 










 return true;










 }










 










 public FieldRef[] getDeltaTo(AccessPath<FieldRef> accPath) {










 if(isPrefixOf(accPath))










 return Arrays.copyOfRange(accPath.accesses, accesses.length, accPath.accesses.length);










 else










 throw new IllegalArgumentException("Given AccessPath must be a prefix of the current AccessPath");










 }










 










 public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {










 Set<FieldRef>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];










 for(int i=0; i<newExclusionArray.length; i++) {










 newExclusionArray[i] = Sets.newHashSet();










 if(i<exclusions.length)










 newExclusionArray[i].addAll(exclusions[i]);










 if(i<accPath.exclusions.length)










 newExclusionArray[i].addAll(accPath.exclusions[i]);










 }










 return new AccessPath<>(accesses, newExclusionArray);










 }










 










 public boolean isEmpty() {










 return exclusions.length == 0 && accesses.length == 0;










 }










 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + Arrays.hashCode(exclusions);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof AccessPath))










 return false;










 AccessPath other = (AccessPath) obj;










 if (!Arrays.equals(accesses, other.accesses))










 return false;










 if (!Arrays.equals(exclusions, other.exclusions))










 return false;










 return true;










 }





















 @Override










 public String toString() {










 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 for(Set<FieldRef> exclusion : exclusions) {










 result += "^" + Joiner.on(",").join(exclusion);










 }










 return result;










 }










 










 public class ExclusionSet {










 private int index;










 










 private ExclusionSet(int index) {










 this.index = index;










 }










 










 public AccessPath<FieldRef> addExclusion(FieldRef exclusion) {










 HashSet<FieldRef> newExclusions = Sets.newHashSet(exclusions[index]);










 newExclusions.add(exclusion);










 Set<FieldRef>[] newExclusionsArray = exclusions.clone();










 newExclusionsArray[index] = newExclusions;










 return new AccessPath<FieldRef>(accesses, newExclusionsArray);










 }










 }










}














src/heros/alias/AccessPathUtil.java








View file @ 1cd34e9e






......@@ -14,91 +14,57 @@ import java.util.ArrayList;




















import com.google.common.base.Optional;





















import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;





















public class AccessPathUtil {





















 public static <D extends FieldSensitiveFact<?, D>> boolean isPrefixOf(D prefixCandidate, D fact) {










 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> boolean isPrefixOf(D prefixCandidate, D fact) {










 if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue()))










 return false; 










 return false;










 










 FieldReference[] prefixAccessPath = prefixCandidate.getAccessPath();










 FieldReference[] factAccessPath = fact.getAccessPath();










 










 for(int i=0; i<prefixAccessPath.length; i++) {










 if(i < factAccessPath.length) {










 if(!prefixAccessPath[i].includes(factAccessPath[i]))










 return false;










 }










 else if(!(prefixAccessPath[i] instanceof Any))










 return false; 










 }










 










 return true;










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }










 










 public static <D extends FieldSensitiveFact<?, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 FieldReference[] concreteAccessPath = sourceFact.getAccessPath();










 FieldReference[] abstractAccessPath = summary.getSourceFact().getAccessPath();










 FieldReference[] targetAccessPath = summary.getTargetFact().getAccessPath();










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 FieldRef[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(targetAccessPath.isAccessInExclusions(delta))










 return Optional.absent();










 










 ArrayList<FieldReference> result = new ArrayList<>(targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length);










 int lastSpecificField = -1;










 for(int i=0; i< targetAccessPath.length; i++) {










 result.add(targetAccessPath[i]);










 if(targetAccessPath[i] instanceof SpecificFieldReference)










 lastSpecificField = i;










 }










 AccessPath<FieldRef> result = targetAccessPath.addFieldReference(delta);










 result = result.mergeExcludedFieldReferences(concreteAccessPath);










 










 for(int i=abstractAccessPath.length; i<concreteAccessPath.length; i++) {










 if(lastSpecificField+1 < result.size()) {










 Optional<? extends FieldReference> mergedFieldRef = concreteAccessPath[i].merge((Any) result.get(lastSpecificField+1));










 if(!mergedFieldRef.isPresent())










 return Optional.absent();










 










 result.set(lastSpecificField+1, mergedFieldRef.get());










 lastSpecificField++;










 } else {










 result.add(concreteAccessPath[i]);










 }










 }










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result.toArray(new FieldReference[result.size()])));










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <D extends FieldSensitiveFact<?, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {










 FieldReference[] accessPath = new FieldReference[fact.getAccessPath().length+fieldRefs.length];










 System.arraycopy(fact.getAccessPath(), 0, accessPath, 0, fact.getAccessPath().length);










 System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);










 return fact.cloneWithAccessPath(accessPath);










 }










//	public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {










//		FieldReference[] accessPath = new FieldReference[fact.getAccessPath().length+fieldRefs.length];










//		System.arraycopy(fact.getAccessPath(), 0, accessPath, 0, fact.getAccessPath().length);










//		System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);










//		return fact.cloneWithAccessPath(accessPath);










//	}










 










 public static <D extends FieldSensitiveFact<?, D>> D concretizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {










 if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))










 throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));










 










 FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();










 FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();










 FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();










 










 FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];





















 //copy old access path










 System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










 










 //copy delta access path that was omitted while creating the abstracted source fact










 System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










 










 return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










 }










 










 public static FieldReference[] getAccessPathDelta(FieldReference[] prefixAccessPath, FieldReference[] accessPath) {










 FieldReference[] result = new FieldReference[accessPath.length - prefixAccessPath.length];










 System.arraycopy(accessPath, prefixAccessPath.length, result, 0, result.length);










 return result;










 }










//	public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D concretizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {










//		if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))










//			throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));










//		










//		FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();










//		FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();










//		FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();










//		










//		FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];










//










//		//copy old access path










//		System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










//		










//		//copy delta access path that was omitted while creating the abstracted source fact










//		System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










//		










//		return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










//	}










}














src/heros/alias/FieldReference.java

deleted


100644 â†’ 0







View file @ ec76098b













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch, Johannes SpÃ¤th.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch, Johannes SpÃ¤th - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FieldReference.Any;





















import java.util.ArrayList;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.base.Optional;










import com.google.common.collect.Sets;





















public interface FieldReference {





















 boolean includes(FieldReference fieldReference);










 










 boolean isIncludedBy(SpecificFieldReference specificFieldRef);










 










 boolean isIncludedBy(Any anyFieldRef);










 










 Optional<? extends FieldReference> merge(Any fieldReference);










 










 public static class Any implements FieldReference {










 private Set<String> excludedFieldNames = Sets.newHashSet();










 










 public Any(String...excludedFieldNames) {










 for (int i = 0; i < excludedFieldNames.length; i++) {










 this.excludedFieldNames.add(excludedFieldNames[i]);










 }










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return false;










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return true;










 }










 










 public Optional<Any> merge(Any fieldReference) {










 ArrayList<String> list = new ArrayList<>(excludedFieldNames);










 list.addAll(fieldReference.excludedFieldNames);










 return Optional.of(new Any(list.toArray(new String[list.size()])));










 }










 










 @Override










 public String toString() {










 if(excludedFieldNames.size() == 0)










 return "";










 else if (excludedFieldNames.size() == 1)










 return "^" + excludedFieldNames.iterator().next();










 else










 return "^{" + Joiner.on(",").join(excludedFieldNames) +"}";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime










 * result










 + ((excludedFieldNames == null) ? 0 : excludedFieldNames










 .hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 Any other = (Any) obj;










 if (excludedFieldNames == null) {










 if (other.excludedFieldNames != null)










 return false;










 } else if (!excludedFieldNames.equals(other.excludedFieldNames))










 return false;










 return true;










 }










 }










 










 public static class SpecificFieldReference implements FieldReference {










 private String fieldName;





















 public SpecificFieldReference(String fieldName) {










 this.fieldName = fieldName;










 }





















 @Override










 public String toString() {










 return fieldName;










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return specificFieldRef.fieldName.equals(fieldName);










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return !anyFieldRef.excludedFieldNames.contains(fieldName);










 }










 










 public Optional<SpecificFieldReference> merge(Any fieldReference) {










 if(fieldReference.excludedFieldNames.contains(fieldName))










 return Optional.absent();










 else 










 return Optional.of(this);










 }










 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result










 + ((fieldName == null) ? 0 : fieldName.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 SpecificFieldReference other = (SpecificFieldReference) obj;










 if (fieldName == null) {










 if (other.fieldName != null)










 return false;










 } else if (!fieldName.equals(other.fieldName))










 return false;










 return true;










 }





















 }










}














src/heros/alias/FieldSensitiveFact.java








View file @ 1cd34e9e






......@@ -12,12 +12,12 @@ package heros.alias;




















import heros.solver.LinkedNode;





















public interface FieldSensitiveFact<BaseValue, D> extends LinkedNode<FieldSensitiveFact<BaseValue, D>>{










public interface FieldSensitiveFact<BaseValue, FieldRef, D> extends LinkedNode<D>{





















 BaseValue getBaseValue();










 










 FieldReference[] getAccessPath();










 AccessPath<FieldRef> getAccessPath();










 










 D cloneWithAccessPath(FieldReference... accessPath);










 D cloneWithAccessPath(AccessPath<FieldRef> accessPath);










 










}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 1cd34e9e






......@@ -10,14 +10,12 @@









 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPathUtil.cloneWithConcatenatedAccessPath;










import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.FlowFunction.Constraint;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.IFDSSolver;










import heros.solver.PathEdge;



......@@ -38,7 +36,7 @@ import com.google.common.base.Predicate;









import com.google.common.cache.CacheBuilder;










import com.google.common.collect.Sets;





















public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact<BaseValue, D>, M, I extends InterproceduralCFG<N, M>> {










public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {
































 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel



......@@ -75,7 +73,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 protected final MyConcurrentHashMap<M, Set<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, Set<PathEdge<N,D>>>();










 










 @DontSynchronize("stateless")










 protected final FlowFunctions<N, D, M> flowFunctions;










 protected final FlowFunctions<N, FieldRef, D, M> flowFunctions;










 










 @DontSynchronize("only used by single thread")










 protected final Map<N,Set<D>> initialSeeds;



......@@ -97,7 +95,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * Creates a solver for the given problem, which caches flow functions and edge functions.










	 * The solver must then be started by calling {@link #solve()}.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,D,M,I> tabulationProblem) {










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef, D,M,I> tabulationProblem) {










 this(tabulationProblem, DEFAULT_CACHE_BUILDER);










 }














......@@ -107,14 +105,14 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.










	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {










 if(logger.isDebugEnabled())










 flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();










 this.zeroValue = tabulationProblem.zeroValue();










 this.icfg = tabulationProblem.interproceduralCFG(); 










 /*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?










				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/ 










 FlowFunctions<N, D, M> flowFunctions = tabulationProblem.flowFunctions(); 










 FlowFunctions<N, FieldRef, D, M> flowFunctions = tabulationProblem.flowFunctions(); 










 /*if(flowFunctionCacheBuilder!=null) {










			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);










			flowFunctions = ffCache;



......@@ -222,16 +220,16 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 Collection<M> callees = icfg.getCalleesOfCallAt(n);










 for(M sCalledProcN: callees) { //still line 14










 //compute the call-flow function










 FlowFunction<D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 Set<AnnotatedFact<D>> res = computeCallFlowFunction(function, d1, d2);










 FlowFunction<FieldRef, D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 Set<AnnotatedFact<FieldRef, D>> res = computeCallFlowFunction(function, d1, d2);










 










 Collection<N> startPointsOf = icfg.getStartPointsOf(sCalledProcN);










 //for each result node of the call-flow function










 for(AnnotatedFact<D> d3: res) {










 for(AnnotatedFact<FieldRef, D> d3: res) {










 //for each callee's start point(s)










 for(N sP: startPointsOf) {










 //create initial self-loop










 D abstractStartPointFact = d3.getFact().cloneWithAccessPath();










 D abstractStartPointFact = d3.getFact().cloneWithAccessPath(new AccessPath<FieldRef>());










 propagate(abstractStartPointFact, sP, abstractStartPointFact, n, false); //line 15










 }










 



......@@ -260,9 +258,9 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, d4.get(), n)) {










 for(AnnotatedFact<FieldRef, D> d5: computeReturnFlowFunction(retFunction, d4.get(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 }



......@@ -275,8 +273,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //line 17-19 of Naeem/Lhotak/Rodriguez		










 //process intra-procedural flows along call-to-return flow functions










 for (N returnSiteN : returnSiteNs) {










 FlowFunction<D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 for(AnnotatedFact<D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))










 FlowFunction<FieldRef, D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 for(AnnotatedFact<FieldRef, D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))










 propagate(d1, returnSiteN, d3.getFact(), n, false);










 }










 }



......@@ -299,20 +297,22 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 for(final PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource())) {










 logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);










 










 FieldReference[] accessPathDelta = AccessPathUtil.getAccessPathDelta(










 incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());










 










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), accessPathDelta)) {










 propagate(zeroValue.equals(incomingEdge.getCallerSourceFact()) ? zeroValue : AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta), null, false);










 } else {










 pauseEdge(AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta));










 }










 final FieldRef[] delta = incomingEdge.getCalleeSourceFact().getAccessPath().getDeltaTo(edge.factAtSource().getAccessPath()); 










 Constraint<FieldRef> constraint = new Constraint<FieldRef>() {










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(delta).mergeExcludedFieldReferences(edge.factAtSource().getAccessPath());










 }










 };










 










 propagateConstrained(constraint, new PathEdge<N,D>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact()), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact())));










 }










 }










 }



......@@ -325,8 +325,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the callee's start node










	 */










 protected Set<AnnotatedFact<D>> computeCallFlowFunction










 (FlowFunction<D> callFlowFunction, D d1, D d2) {










 protected Set<AnnotatedFact<FieldRef, D>> computeCallFlowFunction










 (FlowFunction<FieldRef, D> callFlowFunction, D d1, D d2) {










 return callFlowFunction.computeTargets(d2);










 }














......@@ -339,8 +339,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<AnnotatedFact<D>> computeCallToReturnFlowFunction










 (FlowFunction<D> callToReturnFlowFunction, D d1, D d2) {










 protected Set<AnnotatedFact<FieldRef, D>> computeCallToReturnFlowFunction










 (FlowFunction<FieldRef, D> callToReturnFlowFunction, D d1, D d2) {










 return callToReturnFlowFunction.computeTargets(d2);










 }










 



......@@ -376,15 +376,15 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact())) {










 Optional<D> concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 if(concreteCalleeExitFact.isPresent()) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact.get(), callSite);










 Set<AnnotatedFact<FieldRef, D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact.get(), callSite);










 










 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 for (AnnotatedFact<FieldRef, D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }



......@@ -401,9 +401,9 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);










 for(N c: callers) {










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 Set<AnnotatedFact<D>> targets = computeReturnFlowFunction(retFunction, d2, c);










 for(AnnotatedFact<D> d5: targets)










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 Set<AnnotatedFact<FieldRef, D>> targets = computeReturnFlowFunction(retFunction, d2, c);










 for(AnnotatedFact<FieldRef, D> d5: targets)










 propagate(zeroValue, retSiteC, d5.getFact(), c, true);










 }










 }



......@@ -411,7 +411,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //this might be undesirable if the flow function has a side effect such as registering a taint;










 //instead we thus call the return flow function will a null caller










 if(callers.isEmpty()) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);










 retFunction.computeTargets(d2);










 }










 }



......@@ -425,8 +425,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param callSite The call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<AnnotatedFact<D>> computeReturnFlowFunction










 (FlowFunction<D> retFunction, D d2, N callSite) {










 protected Set<AnnotatedFact<FieldRef, D>> computeReturnFlowFunction










 (FlowFunction<FieldRef, D> retFunction, D d2, N callSite) {










 return retFunction.computeTargets(d2);










 }














......@@ -441,44 +441,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 final D d2 = edge.factAtTarget();










 










 for (N m : icfg.getSuccsOf(n)) {










 FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<AnnotatedFact<D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (AnnotatedFact<D> d3 : res) {










 //TODO: double check if concurrency issues may arise










 










 //if reading field f










 // if d1.f element of incoming edges:










 //    create and propagate (d1.f, d2.f)










 // else 










 //	  create and set (d1.f, d2.f) on hold










 //	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold










 










 if(d3.getReadField() != null) {










 SpecificFieldReference fieldRef = new SpecificFieldReference(d3.getReadField());










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(concretizedSourceValue, m, d3.getFact(), null, false);










 } else {










 pauseEdge(concretizedSourceValue, m, d3.getFact());










 }










 }










 else if(d3.getWrittenField() != null) {










 //TODO: double check if concurrency issues may arise










 










 // if writing field f










 // create edge e = (d1, d2.*\{f})










 // if d2.*\{f} element of incoming edges










 // 		continue with e










 // else 










 //		put e on hold










 // always kill (d1, d2)










 










 Any fieldRef = new Any(d3.getWrittenField());










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(d1, m, d3.getFact(), null, false);










 } else {










 pauseEdge(d1, m, d3.getFact());










 }










 FlowFunction<FieldRef, D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<AnnotatedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (AnnotatedFact<FieldRef, D> d3 : res) {










 if(d3.getConstraint() != null) {










 propagateConstrained(d3.getConstraint(), new PathEdge<>(applyConstraint(d3.getConstraint(), d1), m, d3.getFact()));










 }










 else










 propagate(d1, m, d3.getFact(), null, false);



......@@ -486,44 +453,54 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 }










 }










 










 private void pauseEdge(D sourceValue, N targetStmt, D targetValue) {










 M method = icfg.getMethodOf(targetStmt);










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 if(edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue))) {










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 }










 private D applyConstraint(Constraint<FieldRef> constraint, D fact) {










 if(fact.equals(zeroValue))










 return zeroValue;










 else










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath()));










 }










 










 private boolean propagateConstrained(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge) {










 M calleeMethod = icfg.getMethodOf(pathEdge.getTarget());










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, pathEdge.factAtSource(), constraint);





















 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, FieldReference... fieldRef) {










 M calleeMethod = icfg.getMethodOf(targetStmt);










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, calleeSourceFact, fieldRef);










 










 if(calleeSourceFact.equals(zeroValue))










 return true;










 










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 if(!incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue).isEmpty()) {










 return true;










 }










 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, concretizedSourceValue); 










 for (IncomingEdge<D, N> incomingEdge : inc) {










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), fieldRef)) {










 propagate(incomingEdge.getCallerSourceFact().equals(zeroValue) ? 










 incomingEdge.getCallerSourceFact() : 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef), null, false); 










 return true;










 boolean propagate = false;










 if(pathEdge.factAtSource().equals(zeroValue))










 propagate = true;










 else {










 Set<N> callSitesWithInterest = Sets.newHashSet();










 for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixedWith(calleeMethod, pathEdge.factAtSource())) {










 callSitesWithInterest.add(incEdge.getCallSite());










 }










 else {










 pauseEdge(cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef));










 propagate = !callSitesWithInterest.isEmpty();










 










 for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixesOf(calleeMethod, pathEdge.factAtSource())) {










 boolean equal = incEdge.getCalleeSourceFact().equals(pathEdge.factAtSource()); //TODO: write test case for this










 if(!equal && !callSitesWithInterest.contains(incEdge.getCallSite())) {










 PathEdge<N,D> callerEdge = new PathEdge<>(










 applyConstraint(constraint, incEdge.getCallerSourceFact()), 










 incEdge.getCallSite(), 










 applyConstraint(constraint, incEdge.getCallerCallSiteFact()));










 propagate |= propagateConstrained(constraint, callerEdge);










 }










 }










 }










 










 return false;










 if(propagate) {










 propagate(pathEdge.factAtSource(), pathEdge.getTarget(), pathEdge.factAtTarget(), null, false);










 return true;










 } else {










 pauseEdge(pathEdge);










 return false;










 }










 }










 










 private void pauseEdge(PathEdge<N,D> edge) {










 M method = icfg.getMethodOf(edge.getTarget());










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 if(edges.add(edge)) {










 logger.trace("PAUSED: {}: {}", method, edge);










 }










 }










 










 /**



......@@ -534,8 +511,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param d1 The abstraction at the current node










	 * @return The set of abstractions at the successor node










	 */










 protected Set<AnnotatedFact<D>> computeNormalFlowFunction










 (FlowFunction<D> flowFunction, D d1, D d2) {










 protected Set<AnnotatedFact<FieldRef, D>> computeNormalFlowFunction










 (FlowFunction<FieldRef, D> flowFunction, D d1, D d2) {










 return flowFunction.computeTargets(d2);










 }










 



......














src/heros/alias/FlowFunction.java








View file @ 1cd34e9e






......@@ -10,8 +10,6 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FieldReference.SpecificFieldReference;





















import java.util.LinkedHashSet;










import java.util.Set;














......@@ -33,18 +31,18 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {










public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<AnnotatedFact<D>> computeTargets(D source);










 Set<AnnotatedFact<FieldRef, D>> computeTargets(D source);










 










 public static class AnnotatedFact<D extends FieldSensitiveFact<?, D>> {










 //TODO: rename to ConstrainedFact










 public static class AnnotatedFact<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 private D fact;










 private String readField;










 private String writtenField;










 private Constraint<FieldRef> constraint;










 










 //TODO: Refactor API to make things more intuitive










 /**



......@@ -53,31 +51,25 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









		 * @param readField Giving a field reference here means the base value of a field access was tainted, i.e., we have to concretize the source value










		 * @param writtenField










		 */










 public AnnotatedFact(D fact, String readField, String writtenField) {










 public AnnotatedFact(D fact, Constraint<FieldRef> constraint) {










 this.fact = fact;










 this.readField = readField;










 this.writtenField = writtenField;










 this.constraint = constraint;










 }










 










 public D getFact() {










 return fact;










 }










 










 public String getReadField() {










 return readField;










 }










 










 public String getWrittenField() {










 return writtenField;










 public Constraint<FieldRef> getConstraint() {










 return constraint;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((constraint == null) ? 0 : constraint.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((readField == null) ? 0 : readField.hashCode());










 result = prime * result + ((writtenField == null) ? 0 : writtenField.hashCode());










 return result;










 }














......@@ -90,27 +82,66 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 if (!(obj instanceof AnnotatedFact))










 return false;










 AnnotatedFact other = (AnnotatedFact) obj;










 if (constraint == null) {










 if (other.constraint != null)










 return false;










 } else if (!constraint.equals(other.constraint))










 return false;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (readField == null) {










 if (other.readField != null)










 return false;










 } else if (!readField.equals(other.readField))










 return false;










 if (writtenField == null) {










 if (other.writtenField != null)










 return false;










 } else if (!writtenField.equals(other.writtenField))










 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return fact.toString()+"<"+readField+","+writtenField+">";










 return fact.toString()+"<"+constraint+">";










 }










 }










 










 public interface Constraint<FieldRef> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath);










 }










 










 public class WriteFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 private FieldRef fieldRef;





















 public WriteFieldConstraint(FieldRef fieldRef) {










 this.fieldRef = fieldRef;










 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 if(accPath.hasExclusions())










 return accPath.getExclusions(0).addExclusion(fieldRef);










 else










 return accPath.appendExcludedFieldReference(fieldRef);










 }










 










 @Override










 public String toString() {










 return "^"+fieldRef.toString();










 }










 }










 










 public class ReadFieldConstraint<FieldRef> implements Constraint<FieldRef> {





















 private FieldRef fieldRef;





















 public ReadFieldConstraint(FieldRef fieldRef) {










 this.fieldRef = fieldRef;










 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(fieldRef);










 }










 










 @Override










 public String toString() {










 return fieldRef.toString();










 }










 }










}














src/heros/alias/FlowFunctions.java








View file @ 1cd34e9e






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......@@ -40,7 +40,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<F> getNormalFlowFunction(Stmt curr, Stmt succ);










 public FlowFunction<FieldRef, F> getNormalFlowFunction(Stmt curr, Stmt succ);





















 










 /**



......@@ -52,7 +52,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);










 public FlowFunction<FieldRef, F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a



......@@ -82,7 +82,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 *            does not contain a caller for the method that is returned from.










	 * @return










	 */










 public FlowFunction<F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);










 public FlowFunction<FieldRef, F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a



......@@ -102,7 +102,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);










 public FlowFunction<FieldRef, F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);





















 










 



......














src/heros/alias/IFDSTabulationProblem.java








View file @ 1cd34e9e






......@@ -28,7 +28,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,D extends FieldSensitiveFact<?, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......@@ -37,7 +37,7 @@ public interface IFDSTabulationProblem<N,D extends FieldSensitiveFact<?, D>,M, I









	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 FlowFunctions<N,D,M> flowFunctions();










 FlowFunctions<N,FieldRef,D,M> flowFunctions();










 










 /**










	 * Returns the interprocedural control-flow graph which this problem is computed over.



......














src/heros/solver/CountLatch.java








View file @ 1cd34e9e






......@@ -72,7 +72,7 @@ public class CountLatch {









 }





















 public void awaitZero() throws InterruptedException {










 sync.acquireSharedInterruptibly(1);










 sync.acquireShared(1);










 }





















 public boolean awaitZero(long timeout, TimeUnit unit) throws InterruptedException {



......














test/heros/alias/AccessPathUtilTest.java








View file @ 1cd34e9e






......@@ -53,21 +53,22 @@ public class AccessPathUtilTest {









 










 @Test










 public void testDifferentExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.g")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.h")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.f.g")));










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a.g.g")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a.f.h")));










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^g")));










 }





















 @Test



......@@ -76,10 +77,15 @@ public class AccessPathUtilTest {









 }










 










 @Test










 public void testExclusionDoesNotRequireFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 assertTrue(isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 public void testExclusionRequiresFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a"), new Fact("a^f")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a")));










 










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 assertFalse(isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g^h")));










 assertFalse(isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 }










 










 @Test



......@@ -133,19 +139,4 @@ public class AccessPathUtilTest {









 public void testNullOnImpossibleSubsumption() {










 assertFalse(applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).isPresent());










 }










 










 @Test










 public void testConcretizeCallerSourceFact() {










 assertEquals(new Fact("0.f"), AccessPathUtil.concretizeCallerSourceFact(new IncomingEdge<>(new Fact("2"), null, new Fact("0"), null), new Fact("2.f")));










 }










 










 @Test










 public void testConcretizeCallerSourceFactIdentity() {










 assertEquals(new Fact("0.f"), AccessPathUtil.concretizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2.f")));










 }










 










 @Test(expected=IllegalArgumentException.class)










 public void testConcretizeCallerSourceFactNoPrefix() {










 AccessPathUtil.concretizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2"));










 }










}














test/heros/alias/Fact.java








View file @ 1cd34e9e






......@@ -20,15 +20,16 @@ import com.google.common.base.Joiner;









import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, Fact> {










public class Fact implements FieldSensitiveFact<String, String, Fact> {





















 public final String baseValue;










 public final FieldReference[] accessPath;










 public final AccessPath<String> accessPath;










 










 public Fact(String name) {










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 ArrayList<FieldReference> accessPath = Lists.newArrayList();










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();










 baseValue = name.substring(0, firstSeparator);



......@@ -39,23 +40,25 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 String identifier = matcher.group(2);










 










 if(separator.equals(".")) {










 accessPath.add(new FieldReference.SpecificFieldReference(identifier));










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(identifier);










 } else {










 accessPath.add(new FieldReference.Any(identifier.split(",")));










 addedExclusions=true;










 accessPath = accessPath.appendExcludedFieldReference(identifier.split(","));










 }










 }










 this.accessPath = accessPath.toArray(new FieldReference[accessPath.size()]);










 this.accessPath = accessPath;










 }










 










 public Fact(String baseValue, FieldReference[] accessPath) {










 public Fact(String baseValue, AccessPath<String> accessPath) {










 this.baseValue = baseValue;










 this.accessPath = accessPath;










 }





















 










 @Override










 public String toString() {










 return "[Fact "+baseValue+(accessPath.length>0 ? "."+Joiner.on(".").join(accessPath) : "" )+"]";










 return "[Fact "+baseValue+(accessPath.isEmpty() ? "" : accessPath)+"]";










 }





















 @Override



......@@ -64,30 +67,26 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 }





















 @Override










 public FieldReference[] getAccessPath() {










 public AccessPath<String> getAccessPath() {










 return accessPath;










 }
































 @Override










 public void addNeighbor(FieldSensitiveFact<String, Fact> originalAbstraction) {










 public void addNeighbor(Fact originalAbstraction) {










 










 }
































 @Override










 public void setCallingContext(FieldSensitiveFact<String, Fact> callingContext) {










 public void setCallingContext(Fact callingContext) {










 










 }
































 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accessPath);










 result = prime * result










 + ((baseValue == null) ? 0 : baseValue.hashCode());










 result = prime * result + ((accessPath == null) ? 0 : accessPath.hashCode());










 result = prime * result + ((baseValue == null) ? 0 : baseValue.hashCode());










 return result;










 }














......@@ -97,10 +96,13 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 if (!(obj instanceof Fact))










 return false;










 Fact other = (Fact) obj;










 if (!Arrays.equals(accessPath, other.accessPath))










 if (accessPath == null) {










 if (other.accessPath != null)










 return false;










 } else if (!accessPath.equals(other.accessPath))










 return false;










 if (baseValue == null) {










 if (other.baseValue != null)



......@@ -110,11 +112,8 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 return true;










 }






















































 @Override










 public Fact cloneWithAccessPath(FieldReference... accessPath) {










 public Fact cloneWithAccessPath(AccessPath<String> accessPath) {










 return new Fact(baseValue, accessPath);










 }










 



......














test/heros/alias/FieldSensitiveSolverTest.java








View file @ 1cd34e9e






......@@ -245,7 +245,7 @@ public class FieldSensitiveSolverTest {









 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2")));










 callSite("b").calls("bar", flow("1.f", "2"), flow("1.f^f", "2^f")));










 










 helper.method("bar",










 startPoints("c"),



......@@ -255,6 +255,44 @@ public class FieldSensitiveSolverTest {









 helper.runSolver(false, "a");










 }










 










 @Test










 public void pauseOnTransitiveExclusion() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("2", "3")));










 










 helper.method("xyz",










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", writeField("f"), "3^f")),










 normalStmt("e").succ("f")); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumePausedOnTransitiveExclusion() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("2", "3"), flow("2^f", "3^f")));










 










 helper.method("xyz",










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", writeField("f"), "3^f"), flow("3", "4")),










 callSite("e").calls("bar", flow("4", "2.g"), kill("3^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeEdgePausedOnOverwrittenField() {










 helper.method("foo",



......@@ -277,12 +315,12 @@ public class FieldSensitiveSolverTest {









 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")));










 callSite("e").calls("bar", flow("4", "2"), flow("4^f", "2^f")).retSite("f", kill("4"), kill("4^f") /*unwanted call2ret*/));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("3^f"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }



......














test/heros/alias/TestHelper.java








View file @ 1cd34e9e






......@@ -12,6 +12,7 @@ package heros.alias;




















import static org.junit.Assert.assertTrue;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.FlowFunction.Constraint;










import heros.alias.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.solver.IFDSSolver;



......@@ -89,22 +90,22 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static Pair<String, String> readField(String fieldName) {










 return new Pair<String, String>(fieldName, null);










 public static Constraint<String> readField(String fieldName) {










 return new FlowFunction.ReadFieldConstraint<String>(fieldName);










 }










 










 public static Pair<String, String> writeField(String fieldName) {










 return new Pair<String, String>(null, fieldName);










 public static Constraint<String> writeField(String fieldName) {










 return new FlowFunction.WriteFieldConstraint<String>(fieldName);










 }










 










 public static ExpectedFlowFunction flow(String source, Pair<String, String> fieldAccess, String... targets) {










 return flow(1, source, fieldAccess, targets);










 public static ExpectedFlowFunction flow(String source, Constraint<String> constraint, String... targets) {










 return flow(1, source, constraint, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Pair<String, String> fieldAccess, String... targets) {










 AnnotatedFact<Fact>[] targetFacts = new AnnotatedFact[targets.length];










 public static ExpectedFlowFunction flow(int times, String source, Constraint<String> constraint, String... targets) {










 AnnotatedFact<String, Fact>[] targetFacts = new AnnotatedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new AnnotatedFact<Fact>(new Fact(targets[i]), fieldAccess.getO1(), fieldAccess.getO2());










 targetFacts[i] = new AnnotatedFact<String, Fact>(new Fact(targets[i]), constraint);










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 }



......@@ -114,7 +115,7 @@ public class TestHelper {









 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new Pair<String, String>(null, null), targets);










 return flow(times, source, null, targets);










 }










 










 public static int times(int times) {



......@@ -301,11 +302,11 @@ public class TestHelper {









 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final AnnotatedFact<Fact>[] targets;










 public final AnnotatedFact<String, Fact>[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, AnnotatedFact<Fact>... targets) {










 public ExpectedFlowFunction(int times, Fact source, AnnotatedFact<String, Fact>... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;



......@@ -437,11 +438,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, Fact, Method>() {










 public FlowFunctions<Statement, String, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, String, Fact, Method>() {





















 @Override










 public FlowFunction<Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 public FlowFunction<String, Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -453,7 +454,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 public FlowFunction<String, Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr) && edge.succUnit.equals(succ)) {










 return createFlowFunction(edge);



......@@ -463,7 +464,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 public FlowFunction<String, Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -473,7 +474,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 public FlowFunction<String, Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -482,11 +483,11 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<Fact>() {










 private FlowFunction<String, Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<String, Fact>() {










 @Override










 public Set<AnnotatedFact<Fact>> computeTargets(Fact source) {










 Set<AnnotatedFact<Fact>> result = Sets.newHashSet();










 public Set<AnnotatedFact<String, Fact>> computeTargets(Fact source) {










 Set<AnnotatedFact<String, Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {



......@@ -509,17 +510,17 @@ public class TestHelper {









 }





















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 FieldSensitiveIFDSSolver<Statement, String,Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement, String,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 FieldSensitiveIFDSSolver<Statement, String, String, Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement,String,  String,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 solver.solve();










 assertAllFlowFunctionsUsed();










 }










 










 










 private IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 private IFDSTabulationProblem<Statement, String, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, Method> icfg = buildIcfg();










 final FlowFunctions<Statement, Fact, Method> flowFunctions = flowFunctions();










 final FlowFunctions<Statement, String, Fact, Method> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>() {










 return new IFDSTabulationProblem<Statement,String,  Fact, Method, InterproceduralCFG<Statement, Method>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -542,7 +543,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 public FlowFunctions<Statement,String,  Fact, Method> flowFunctions() {










 return flowFunctions;










 }














......
















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment






Commit
1cd34e9e


authored
Jan 07, 2015
by


Johannes Lerch



Browse files



Commit
1cd34e9e


authored
Jan 07, 2015
by


Johannes Lerch

1cd34e9eauthoredbyJohannes Lerch

cleaning code






parent
ec76098b
















parent
ec76098b





parent












Changes
13
13


Hide whitespace changes

Inline
Side-by-side






Hide whitespace changes

Inline
Side-by-side




Hide whitespace changes

Inline
Side-by-side


Inline
Side-by-side










src/heros/alias/AccessPath.java



0 â†’ 100644







View file @ 1cd34e9e













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.collect.Sets;





















@SuppressWarnings("unchecked")










public class AccessPath<FieldRef> {





















 private FieldRef[] accesses;










 private Set<FieldRef>[] exclusions;










 










 public AccessPath() {










 accesses = (FieldRef[]) new Object[0];










 exclusions = new Set[0];










 }










 










 AccessPath(FieldRef[] accesses, Set<FieldRef>[] exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean hasExclusions() {










 return exclusions.length > 0;










 }










 










 public boolean isAccessInExclusions(FieldRef... fieldReferences) {










 for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 if(exclusions[i].contains(fieldReferences[i]))










 return true;










 } 










 return false;










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException();





















 FieldRef[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 Set<FieldRef>[] newExclusionsArray = exclusions.length < fieldReferences.length ? exclusions : Arrays.copyOfRange(exclusions, fieldReferences.length, exclusions.length); 










 return new AccessPath<FieldRef>(newAccesses, newExclusionsArray);










 }





















 public ExclusionSet getExclusions(int index) {










 return new ExclusionSet(index);










 }










 










 public AccessPath<FieldRef> appendExcludedFieldReference(FieldRef... fieldReferences) {










 Set<FieldRef>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);










 newExclusionsArray[exclusions.length] = Sets.newHashSet(fieldReferences);










 return new AccessPath<>(accesses, newExclusionsArray);










 }










 










 public boolean isPrefixOf(AccessPath<FieldRef> accessPath) {










 if(accesses.length > accessPath.accesses.length)










 return false;










 










 if(accesses.length + exclusions.length > accessPath.accesses.length + accessPath.exclusions.length)










 return false;










 










 for(int i=0; i<accesses.length; i++) {










 if(!accesses[i].equals(accessPath.accesses[i]))










 return false;










 }










 










 for(int i=0; i<exclusions.length; i++) {










 if(i+accesses.length < accessPath.accesses.length) {










 if(exclusions[i].contains(accessPath.accesses[i+accesses.length]))










 return false;










 }










 else {










 if(!exclusions[i].containsAll(accessPath.exclusions[i+accesses.length - accessPath.accesses.length]))










 return false;










 }










 }










 










 return true;










 }










 










 public FieldRef[] getDeltaTo(AccessPath<FieldRef> accPath) {










 if(isPrefixOf(accPath))










 return Arrays.copyOfRange(accPath.accesses, accesses.length, accPath.accesses.length);










 else










 throw new IllegalArgumentException("Given AccessPath must be a prefix of the current AccessPath");










 }










 










 public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {










 Set<FieldRef>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];










 for(int i=0; i<newExclusionArray.length; i++) {










 newExclusionArray[i] = Sets.newHashSet();










 if(i<exclusions.length)










 newExclusionArray[i].addAll(exclusions[i]);










 if(i<accPath.exclusions.length)










 newExclusionArray[i].addAll(accPath.exclusions[i]);










 }










 return new AccessPath<>(accesses, newExclusionArray);










 }










 










 public boolean isEmpty() {










 return exclusions.length == 0 && accesses.length == 0;










 }










 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + Arrays.hashCode(exclusions);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof AccessPath))










 return false;










 AccessPath other = (AccessPath) obj;










 if (!Arrays.equals(accesses, other.accesses))










 return false;










 if (!Arrays.equals(exclusions, other.exclusions))










 return false;










 return true;










 }





















 @Override










 public String toString() {










 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 for(Set<FieldRef> exclusion : exclusions) {










 result += "^" + Joiner.on(",").join(exclusion);










 }










 return result;










 }










 










 public class ExclusionSet {










 private int index;










 










 private ExclusionSet(int index) {










 this.index = index;










 }










 










 public AccessPath<FieldRef> addExclusion(FieldRef exclusion) {










 HashSet<FieldRef> newExclusions = Sets.newHashSet(exclusions[index]);










 newExclusions.add(exclusion);










 Set<FieldRef>[] newExclusionsArray = exclusions.clone();










 newExclusionsArray[index] = newExclusions;










 return new AccessPath<FieldRef>(accesses, newExclusionsArray);










 }










 }










}














src/heros/alias/AccessPathUtil.java








View file @ 1cd34e9e






......@@ -14,91 +14,57 @@ import java.util.ArrayList;




















import com.google.common.base.Optional;





















import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;





















public class AccessPathUtil {





















 public static <D extends FieldSensitiveFact<?, D>> boolean isPrefixOf(D prefixCandidate, D fact) {










 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> boolean isPrefixOf(D prefixCandidate, D fact) {










 if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue()))










 return false; 










 return false;










 










 FieldReference[] prefixAccessPath = prefixCandidate.getAccessPath();










 FieldReference[] factAccessPath = fact.getAccessPath();










 










 for(int i=0; i<prefixAccessPath.length; i++) {










 if(i < factAccessPath.length) {










 if(!prefixAccessPath[i].includes(factAccessPath[i]))










 return false;










 }










 else if(!(prefixAccessPath[i] instanceof Any))










 return false; 










 }










 










 return true;










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }










 










 public static <D extends FieldSensitiveFact<?, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 FieldReference[] concreteAccessPath = sourceFact.getAccessPath();










 FieldReference[] abstractAccessPath = summary.getSourceFact().getAccessPath();










 FieldReference[] targetAccessPath = summary.getTargetFact().getAccessPath();










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 FieldRef[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(targetAccessPath.isAccessInExclusions(delta))










 return Optional.absent();










 










 ArrayList<FieldReference> result = new ArrayList<>(targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length);










 int lastSpecificField = -1;










 for(int i=0; i< targetAccessPath.length; i++) {










 result.add(targetAccessPath[i]);










 if(targetAccessPath[i] instanceof SpecificFieldReference)










 lastSpecificField = i;










 }










 AccessPath<FieldRef> result = targetAccessPath.addFieldReference(delta);










 result = result.mergeExcludedFieldReferences(concreteAccessPath);










 










 for(int i=abstractAccessPath.length; i<concreteAccessPath.length; i++) {










 if(lastSpecificField+1 < result.size()) {










 Optional<? extends FieldReference> mergedFieldRef = concreteAccessPath[i].merge((Any) result.get(lastSpecificField+1));










 if(!mergedFieldRef.isPresent())










 return Optional.absent();










 










 result.set(lastSpecificField+1, mergedFieldRef.get());










 lastSpecificField++;










 } else {










 result.add(concreteAccessPath[i]);










 }










 }










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result.toArray(new FieldReference[result.size()])));










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <D extends FieldSensitiveFact<?, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {










 FieldReference[] accessPath = new FieldReference[fact.getAccessPath().length+fieldRefs.length];










 System.arraycopy(fact.getAccessPath(), 0, accessPath, 0, fact.getAccessPath().length);










 System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);










 return fact.cloneWithAccessPath(accessPath);










 }










//	public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {










//		FieldReference[] accessPath = new FieldReference[fact.getAccessPath().length+fieldRefs.length];










//		System.arraycopy(fact.getAccessPath(), 0, accessPath, 0, fact.getAccessPath().length);










//		System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);










//		return fact.cloneWithAccessPath(accessPath);










//	}










 










 public static <D extends FieldSensitiveFact<?, D>> D concretizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {










 if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))










 throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));










 










 FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();










 FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();










 FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();










 










 FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];





















 //copy old access path










 System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










 










 //copy delta access path that was omitted while creating the abstracted source fact










 System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










 










 return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










 }










 










 public static FieldReference[] getAccessPathDelta(FieldReference[] prefixAccessPath, FieldReference[] accessPath) {










 FieldReference[] result = new FieldReference[accessPath.length - prefixAccessPath.length];










 System.arraycopy(accessPath, prefixAccessPath.length, result, 0, result.length);










 return result;










 }










//	public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D concretizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {










//		if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))










//			throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));










//		










//		FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();










//		FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();










//		FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();










//		










//		FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];










//










//		//copy old access path










//		System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










//		










//		//copy delta access path that was omitted while creating the abstracted source fact










//		System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










//		










//		return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










//	}










}














src/heros/alias/FieldReference.java

deleted


100644 â†’ 0







View file @ ec76098b













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch, Johannes SpÃ¤th.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch, Johannes SpÃ¤th - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FieldReference.Any;





















import java.util.ArrayList;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.base.Optional;










import com.google.common.collect.Sets;





















public interface FieldReference {





















 boolean includes(FieldReference fieldReference);










 










 boolean isIncludedBy(SpecificFieldReference specificFieldRef);










 










 boolean isIncludedBy(Any anyFieldRef);










 










 Optional<? extends FieldReference> merge(Any fieldReference);










 










 public static class Any implements FieldReference {










 private Set<String> excludedFieldNames = Sets.newHashSet();










 










 public Any(String...excludedFieldNames) {










 for (int i = 0; i < excludedFieldNames.length; i++) {










 this.excludedFieldNames.add(excludedFieldNames[i]);










 }










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return false;










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return true;










 }










 










 public Optional<Any> merge(Any fieldReference) {










 ArrayList<String> list = new ArrayList<>(excludedFieldNames);










 list.addAll(fieldReference.excludedFieldNames);










 return Optional.of(new Any(list.toArray(new String[list.size()])));










 }










 










 @Override










 public String toString() {










 if(excludedFieldNames.size() == 0)










 return "";










 else if (excludedFieldNames.size() == 1)










 return "^" + excludedFieldNames.iterator().next();










 else










 return "^{" + Joiner.on(",").join(excludedFieldNames) +"}";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime










 * result










 + ((excludedFieldNames == null) ? 0 : excludedFieldNames










 .hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 Any other = (Any) obj;










 if (excludedFieldNames == null) {










 if (other.excludedFieldNames != null)










 return false;










 } else if (!excludedFieldNames.equals(other.excludedFieldNames))










 return false;










 return true;










 }










 }










 










 public static class SpecificFieldReference implements FieldReference {










 private String fieldName;





















 public SpecificFieldReference(String fieldName) {










 this.fieldName = fieldName;










 }





















 @Override










 public String toString() {










 return fieldName;










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return specificFieldRef.fieldName.equals(fieldName);










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return !anyFieldRef.excludedFieldNames.contains(fieldName);










 }










 










 public Optional<SpecificFieldReference> merge(Any fieldReference) {










 if(fieldReference.excludedFieldNames.contains(fieldName))










 return Optional.absent();










 else 










 return Optional.of(this);










 }










 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result










 + ((fieldName == null) ? 0 : fieldName.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 SpecificFieldReference other = (SpecificFieldReference) obj;










 if (fieldName == null) {










 if (other.fieldName != null)










 return false;










 } else if (!fieldName.equals(other.fieldName))










 return false;










 return true;










 }





















 }










}














src/heros/alias/FieldSensitiveFact.java








View file @ 1cd34e9e






......@@ -12,12 +12,12 @@ package heros.alias;




















import heros.solver.LinkedNode;





















public interface FieldSensitiveFact<BaseValue, D> extends LinkedNode<FieldSensitiveFact<BaseValue, D>>{










public interface FieldSensitiveFact<BaseValue, FieldRef, D> extends LinkedNode<D>{





















 BaseValue getBaseValue();










 










 FieldReference[] getAccessPath();










 AccessPath<FieldRef> getAccessPath();










 










 D cloneWithAccessPath(FieldReference... accessPath);










 D cloneWithAccessPath(AccessPath<FieldRef> accessPath);










 










}














src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 1cd34e9e






......@@ -10,14 +10,12 @@









 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPathUtil.cloneWithConcatenatedAccessPath;










import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.FlowFunction.Constraint;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.IFDSSolver;










import heros.solver.PathEdge;



......@@ -38,7 +36,7 @@ import com.google.common.base.Predicate;









import com.google.common.cache.CacheBuilder;










import com.google.common.collect.Sets;





















public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact<BaseValue, D>, M, I extends InterproceduralCFG<N, M>> {










public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {
































 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel



......@@ -75,7 +73,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 protected final MyConcurrentHashMap<M, Set<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, Set<PathEdge<N,D>>>();










 










 @DontSynchronize("stateless")










 protected final FlowFunctions<N, D, M> flowFunctions;










 protected final FlowFunctions<N, FieldRef, D, M> flowFunctions;










 










 @DontSynchronize("only used by single thread")










 protected final Map<N,Set<D>> initialSeeds;



......@@ -97,7 +95,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * Creates a solver for the given problem, which caches flow functions and edge functions.










	 * The solver must then be started by calling {@link #solve()}.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,D,M,I> tabulationProblem) {










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef, D,M,I> tabulationProblem) {










 this(tabulationProblem, DEFAULT_CACHE_BUILDER);










 }














......@@ -107,14 +105,14 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.










	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {










 if(logger.isDebugEnabled())










 flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();










 this.zeroValue = tabulationProblem.zeroValue();










 this.icfg = tabulationProblem.interproceduralCFG(); 










 /*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?










				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/ 










 FlowFunctions<N, D, M> flowFunctions = tabulationProblem.flowFunctions(); 










 FlowFunctions<N, FieldRef, D, M> flowFunctions = tabulationProblem.flowFunctions(); 










 /*if(flowFunctionCacheBuilder!=null) {










			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);










			flowFunctions = ffCache;



......@@ -222,16 +220,16 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 Collection<M> callees = icfg.getCalleesOfCallAt(n);










 for(M sCalledProcN: callees) { //still line 14










 //compute the call-flow function










 FlowFunction<D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 Set<AnnotatedFact<D>> res = computeCallFlowFunction(function, d1, d2);










 FlowFunction<FieldRef, D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 Set<AnnotatedFact<FieldRef, D>> res = computeCallFlowFunction(function, d1, d2);










 










 Collection<N> startPointsOf = icfg.getStartPointsOf(sCalledProcN);










 //for each result node of the call-flow function










 for(AnnotatedFact<D> d3: res) {










 for(AnnotatedFact<FieldRef, D> d3: res) {










 //for each callee's start point(s)










 for(N sP: startPointsOf) {










 //create initial self-loop










 D abstractStartPointFact = d3.getFact().cloneWithAccessPath();










 D abstractStartPointFact = d3.getFact().cloneWithAccessPath(new AccessPath<FieldRef>());










 propagate(abstractStartPointFact, sP, abstractStartPointFact, n, false); //line 15










 }










 



......@@ -260,9 +258,9 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, d4.get(), n)) {










 for(AnnotatedFact<FieldRef, D> d5: computeReturnFlowFunction(retFunction, d4.get(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 }



......@@ -275,8 +273,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //line 17-19 of Naeem/Lhotak/Rodriguez		










 //process intra-procedural flows along call-to-return flow functions










 for (N returnSiteN : returnSiteNs) {










 FlowFunction<D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 for(AnnotatedFact<D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))










 FlowFunction<FieldRef, D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 for(AnnotatedFact<FieldRef, D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))










 propagate(d1, returnSiteN, d3.getFact(), n, false);










 }










 }



......@@ -299,20 +297,22 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 for(final PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource())) {










 logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);










 










 FieldReference[] accessPathDelta = AccessPathUtil.getAccessPathDelta(










 incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());










 










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), accessPathDelta)) {










 propagate(zeroValue.equals(incomingEdge.getCallerSourceFact()) ? zeroValue : AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta), null, false);










 } else {










 pauseEdge(AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta));










 }










 final FieldRef[] delta = incomingEdge.getCalleeSourceFact().getAccessPath().getDeltaTo(edge.factAtSource().getAccessPath()); 










 Constraint<FieldRef> constraint = new Constraint<FieldRef>() {










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(delta).mergeExcludedFieldReferences(edge.factAtSource().getAccessPath());










 }










 };










 










 propagateConstrained(constraint, new PathEdge<N,D>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact()), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact())));










 }










 }










 }



......@@ -325,8 +325,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the callee's start node










	 */










 protected Set<AnnotatedFact<D>> computeCallFlowFunction










 (FlowFunction<D> callFlowFunction, D d1, D d2) {










 protected Set<AnnotatedFact<FieldRef, D>> computeCallFlowFunction










 (FlowFunction<FieldRef, D> callFlowFunction, D d1, D d2) {










 return callFlowFunction.computeTargets(d2);










 }














......@@ -339,8 +339,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<AnnotatedFact<D>> computeCallToReturnFlowFunction










 (FlowFunction<D> callToReturnFlowFunction, D d1, D d2) {










 protected Set<AnnotatedFact<FieldRef, D>> computeCallToReturnFlowFunction










 (FlowFunction<FieldRef, D> callToReturnFlowFunction, D d1, D d2) {










 return callToReturnFlowFunction.computeTargets(d2);










 }










 



......@@ -376,15 +376,15 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact())) {










 Optional<D> concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 if(concreteCalleeExitFact.isPresent()) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact.get(), callSite);










 Set<AnnotatedFact<FieldRef, D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact.get(), callSite);










 










 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 for (AnnotatedFact<FieldRef, D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }



......@@ -401,9 +401,9 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);










 for(N c: callers) {










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 Set<AnnotatedFact<D>> targets = computeReturnFlowFunction(retFunction, d2, c);










 for(AnnotatedFact<D> d5: targets)










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 Set<AnnotatedFact<FieldRef, D>> targets = computeReturnFlowFunction(retFunction, d2, c);










 for(AnnotatedFact<FieldRef, D> d5: targets)










 propagate(zeroValue, retSiteC, d5.getFact(), c, true);










 }










 }



......@@ -411,7 +411,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //this might be undesirable if the flow function has a side effect such as registering a taint;










 //instead we thus call the return flow function will a null caller










 if(callers.isEmpty()) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);










 retFunction.computeTargets(d2);










 }










 }



......@@ -425,8 +425,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param callSite The call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<AnnotatedFact<D>> computeReturnFlowFunction










 (FlowFunction<D> retFunction, D d2, N callSite) {










 protected Set<AnnotatedFact<FieldRef, D>> computeReturnFlowFunction










 (FlowFunction<FieldRef, D> retFunction, D d2, N callSite) {










 return retFunction.computeTargets(d2);










 }














......@@ -441,44 +441,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 final D d2 = edge.factAtTarget();










 










 for (N m : icfg.getSuccsOf(n)) {










 FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<AnnotatedFact<D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (AnnotatedFact<D> d3 : res) {










 //TODO: double check if concurrency issues may arise










 










 //if reading field f










 // if d1.f element of incoming edges:










 //    create and propagate (d1.f, d2.f)










 // else 










 //	  create and set (d1.f, d2.f) on hold










 //	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold










 










 if(d3.getReadField() != null) {










 SpecificFieldReference fieldRef = new SpecificFieldReference(d3.getReadField());










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(concretizedSourceValue, m, d3.getFact(), null, false);










 } else {










 pauseEdge(concretizedSourceValue, m, d3.getFact());










 }










 }










 else if(d3.getWrittenField() != null) {










 //TODO: double check if concurrency issues may arise










 










 // if writing field f










 // create edge e = (d1, d2.*\{f})










 // if d2.*\{f} element of incoming edges










 // 		continue with e










 // else 










 //		put e on hold










 // always kill (d1, d2)










 










 Any fieldRef = new Any(d3.getWrittenField());










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(d1, m, d3.getFact(), null, false);










 } else {










 pauseEdge(d1, m, d3.getFact());










 }










 FlowFunction<FieldRef, D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<AnnotatedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (AnnotatedFact<FieldRef, D> d3 : res) {










 if(d3.getConstraint() != null) {










 propagateConstrained(d3.getConstraint(), new PathEdge<>(applyConstraint(d3.getConstraint(), d1), m, d3.getFact()));










 }










 else










 propagate(d1, m, d3.getFact(), null, false);



......@@ -486,44 +453,54 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 }










 }










 










 private void pauseEdge(D sourceValue, N targetStmt, D targetValue) {










 M method = icfg.getMethodOf(targetStmt);










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 if(edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue))) {










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 }










 private D applyConstraint(Constraint<FieldRef> constraint, D fact) {










 if(fact.equals(zeroValue))










 return zeroValue;










 else










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath()));










 }










 










 private boolean propagateConstrained(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge) {










 M calleeMethod = icfg.getMethodOf(pathEdge.getTarget());










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, pathEdge.factAtSource(), constraint);





















 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, FieldReference... fieldRef) {










 M calleeMethod = icfg.getMethodOf(targetStmt);










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, calleeSourceFact, fieldRef);










 










 if(calleeSourceFact.equals(zeroValue))










 return true;










 










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 if(!incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue).isEmpty()) {










 return true;










 }










 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, concretizedSourceValue); 










 for (IncomingEdge<D, N> incomingEdge : inc) {










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), fieldRef)) {










 propagate(incomingEdge.getCallerSourceFact().equals(zeroValue) ? 










 incomingEdge.getCallerSourceFact() : 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef), null, false); 










 return true;










 boolean propagate = false;










 if(pathEdge.factAtSource().equals(zeroValue))










 propagate = true;










 else {










 Set<N> callSitesWithInterest = Sets.newHashSet();










 for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixedWith(calleeMethod, pathEdge.factAtSource())) {










 callSitesWithInterest.add(incEdge.getCallSite());










 }










 else {










 pauseEdge(cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef));










 propagate = !callSitesWithInterest.isEmpty();










 










 for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixesOf(calleeMethod, pathEdge.factAtSource())) {










 boolean equal = incEdge.getCalleeSourceFact().equals(pathEdge.factAtSource()); //TODO: write test case for this










 if(!equal && !callSitesWithInterest.contains(incEdge.getCallSite())) {










 PathEdge<N,D> callerEdge = new PathEdge<>(










 applyConstraint(constraint, incEdge.getCallerSourceFact()), 










 incEdge.getCallSite(), 










 applyConstraint(constraint, incEdge.getCallerCallSiteFact()));










 propagate |= propagateConstrained(constraint, callerEdge);










 }










 }










 }










 










 return false;










 if(propagate) {










 propagate(pathEdge.factAtSource(), pathEdge.getTarget(), pathEdge.factAtTarget(), null, false);










 return true;










 } else {










 pauseEdge(pathEdge);










 return false;










 }










 }










 










 private void pauseEdge(PathEdge<N,D> edge) {










 M method = icfg.getMethodOf(edge.getTarget());










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 if(edges.add(edge)) {










 logger.trace("PAUSED: {}: {}", method, edge);










 }










 }










 










 /**



......@@ -534,8 +511,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param d1 The abstraction at the current node










	 * @return The set of abstractions at the successor node










	 */










 protected Set<AnnotatedFact<D>> computeNormalFlowFunction










 (FlowFunction<D> flowFunction, D d1, D d2) {










 protected Set<AnnotatedFact<FieldRef, D>> computeNormalFlowFunction










 (FlowFunction<FieldRef, D> flowFunction, D d1, D d2) {










 return flowFunction.computeTargets(d2);










 }










 



......














src/heros/alias/FlowFunction.java








View file @ 1cd34e9e






......@@ -10,8 +10,6 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FieldReference.SpecificFieldReference;





















import java.util.LinkedHashSet;










import java.util.Set;














......@@ -33,18 +31,18 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {










public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<AnnotatedFact<D>> computeTargets(D source);










 Set<AnnotatedFact<FieldRef, D>> computeTargets(D source);










 










 public static class AnnotatedFact<D extends FieldSensitiveFact<?, D>> {










 //TODO: rename to ConstrainedFact










 public static class AnnotatedFact<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 private D fact;










 private String readField;










 private String writtenField;










 private Constraint<FieldRef> constraint;










 










 //TODO: Refactor API to make things more intuitive










 /**



......@@ -53,31 +51,25 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









		 * @param readField Giving a field reference here means the base value of a field access was tainted, i.e., we have to concretize the source value










		 * @param writtenField










		 */










 public AnnotatedFact(D fact, String readField, String writtenField) {










 public AnnotatedFact(D fact, Constraint<FieldRef> constraint) {










 this.fact = fact;










 this.readField = readField;










 this.writtenField = writtenField;










 this.constraint = constraint;










 }










 










 public D getFact() {










 return fact;










 }










 










 public String getReadField() {










 return readField;










 }










 










 public String getWrittenField() {










 return writtenField;










 public Constraint<FieldRef> getConstraint() {










 return constraint;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((constraint == null) ? 0 : constraint.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((readField == null) ? 0 : readField.hashCode());










 result = prime * result + ((writtenField == null) ? 0 : writtenField.hashCode());










 return result;










 }














......@@ -90,27 +82,66 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 if (!(obj instanceof AnnotatedFact))










 return false;










 AnnotatedFact other = (AnnotatedFact) obj;










 if (constraint == null) {










 if (other.constraint != null)










 return false;










 } else if (!constraint.equals(other.constraint))










 return false;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (readField == null) {










 if (other.readField != null)










 return false;










 } else if (!readField.equals(other.readField))










 return false;










 if (writtenField == null) {










 if (other.writtenField != null)










 return false;










 } else if (!writtenField.equals(other.writtenField))










 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return fact.toString()+"<"+readField+","+writtenField+">";










 return fact.toString()+"<"+constraint+">";










 }










 }










 










 public interface Constraint<FieldRef> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath);










 }










 










 public class WriteFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 private FieldRef fieldRef;





















 public WriteFieldConstraint(FieldRef fieldRef) {










 this.fieldRef = fieldRef;










 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 if(accPath.hasExclusions())










 return accPath.getExclusions(0).addExclusion(fieldRef);










 else










 return accPath.appendExcludedFieldReference(fieldRef);










 }










 










 @Override










 public String toString() {










 return "^"+fieldRef.toString();










 }










 }










 










 public class ReadFieldConstraint<FieldRef> implements Constraint<FieldRef> {





















 private FieldRef fieldRef;





















 public ReadFieldConstraint(FieldRef fieldRef) {










 this.fieldRef = fieldRef;










 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(fieldRef);










 }










 










 @Override










 public String toString() {










 return fieldRef.toString();










 }










 }










}














src/heros/alias/FlowFunctions.java








View file @ 1cd34e9e






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......@@ -40,7 +40,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<F> getNormalFlowFunction(Stmt curr, Stmt succ);










 public FlowFunction<FieldRef, F> getNormalFlowFunction(Stmt curr, Stmt succ);





















 










 /**



......@@ -52,7 +52,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);










 public FlowFunction<FieldRef, F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a



......@@ -82,7 +82,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 *            does not contain a caller for the method that is returned from.










	 * @return










	 */










 public FlowFunction<F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);










 public FlowFunction<FieldRef, F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a



......@@ -102,7 +102,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);










 public FlowFunction<FieldRef, F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);





















 










 



......














src/heros/alias/IFDSTabulationProblem.java








View file @ 1cd34e9e






......@@ -28,7 +28,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,D extends FieldSensitiveFact<?, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......@@ -37,7 +37,7 @@ public interface IFDSTabulationProblem<N,D extends FieldSensitiveFact<?, D>,M, I









	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 FlowFunctions<N,D,M> flowFunctions();










 FlowFunctions<N,FieldRef,D,M> flowFunctions();










 










 /**










	 * Returns the interprocedural control-flow graph which this problem is computed over.



......














src/heros/solver/CountLatch.java








View file @ 1cd34e9e






......@@ -72,7 +72,7 @@ public class CountLatch {









 }





















 public void awaitZero() throws InterruptedException {










 sync.acquireSharedInterruptibly(1);










 sync.acquireShared(1);










 }





















 public boolean awaitZero(long timeout, TimeUnit unit) throws InterruptedException {



......














test/heros/alias/AccessPathUtilTest.java








View file @ 1cd34e9e






......@@ -53,21 +53,22 @@ public class AccessPathUtilTest {









 










 @Test










 public void testDifferentExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.g")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.h")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.f.g")));










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a.g.g")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a.f.h")));










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^g")));










 }





















 @Test



......@@ -76,10 +77,15 @@ public class AccessPathUtilTest {









 }










 










 @Test










 public void testExclusionDoesNotRequireFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 assertTrue(isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 public void testExclusionRequiresFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a"), new Fact("a^f")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a")));










 










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 assertFalse(isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g^h")));










 assertFalse(isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 }










 










 @Test



......@@ -133,19 +139,4 @@ public class AccessPathUtilTest {









 public void testNullOnImpossibleSubsumption() {










 assertFalse(applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).isPresent());










 }










 










 @Test










 public void testConcretizeCallerSourceFact() {










 assertEquals(new Fact("0.f"), AccessPathUtil.concretizeCallerSourceFact(new IncomingEdge<>(new Fact("2"), null, new Fact("0"), null), new Fact("2.f")));










 }










 










 @Test










 public void testConcretizeCallerSourceFactIdentity() {










 assertEquals(new Fact("0.f"), AccessPathUtil.concretizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2.f")));










 }










 










 @Test(expected=IllegalArgumentException.class)










 public void testConcretizeCallerSourceFactNoPrefix() {










 AccessPathUtil.concretizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2"));










 }










}














test/heros/alias/Fact.java








View file @ 1cd34e9e






......@@ -20,15 +20,16 @@ import com.google.common.base.Joiner;









import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, Fact> {










public class Fact implements FieldSensitiveFact<String, String, Fact> {





















 public final String baseValue;










 public final FieldReference[] accessPath;










 public final AccessPath<String> accessPath;










 










 public Fact(String name) {










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 ArrayList<FieldReference> accessPath = Lists.newArrayList();










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();










 baseValue = name.substring(0, firstSeparator);



......@@ -39,23 +40,25 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 String identifier = matcher.group(2);










 










 if(separator.equals(".")) {










 accessPath.add(new FieldReference.SpecificFieldReference(identifier));










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(identifier);










 } else {










 accessPath.add(new FieldReference.Any(identifier.split(",")));










 addedExclusions=true;










 accessPath = accessPath.appendExcludedFieldReference(identifier.split(","));










 }










 }










 this.accessPath = accessPath.toArray(new FieldReference[accessPath.size()]);










 this.accessPath = accessPath;










 }










 










 public Fact(String baseValue, FieldReference[] accessPath) {










 public Fact(String baseValue, AccessPath<String> accessPath) {










 this.baseValue = baseValue;










 this.accessPath = accessPath;










 }





















 










 @Override










 public String toString() {










 return "[Fact "+baseValue+(accessPath.length>0 ? "."+Joiner.on(".").join(accessPath) : "" )+"]";










 return "[Fact "+baseValue+(accessPath.isEmpty() ? "" : accessPath)+"]";










 }





















 @Override



......@@ -64,30 +67,26 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 }





















 @Override










 public FieldReference[] getAccessPath() {










 public AccessPath<String> getAccessPath() {










 return accessPath;










 }
































 @Override










 public void addNeighbor(FieldSensitiveFact<String, Fact> originalAbstraction) {










 public void addNeighbor(Fact originalAbstraction) {










 










 }
































 @Override










 public void setCallingContext(FieldSensitiveFact<String, Fact> callingContext) {










 public void setCallingContext(Fact callingContext) {










 










 }
































 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accessPath);










 result = prime * result










 + ((baseValue == null) ? 0 : baseValue.hashCode());










 result = prime * result + ((accessPath == null) ? 0 : accessPath.hashCode());










 result = prime * result + ((baseValue == null) ? 0 : baseValue.hashCode());










 return result;










 }














......@@ -97,10 +96,13 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 if (!(obj instanceof Fact))










 return false;










 Fact other = (Fact) obj;










 if (!Arrays.equals(accessPath, other.accessPath))










 if (accessPath == null) {










 if (other.accessPath != null)










 return false;










 } else if (!accessPath.equals(other.accessPath))










 return false;










 if (baseValue == null) {










 if (other.baseValue != null)



......@@ -110,11 +112,8 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 return true;










 }






















































 @Override










 public Fact cloneWithAccessPath(FieldReference... accessPath) {










 public Fact cloneWithAccessPath(AccessPath<String> accessPath) {










 return new Fact(baseValue, accessPath);










 }










 



......














test/heros/alias/FieldSensitiveSolverTest.java








View file @ 1cd34e9e






......@@ -245,7 +245,7 @@ public class FieldSensitiveSolverTest {









 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2")));










 callSite("b").calls("bar", flow("1.f", "2"), flow("1.f^f", "2^f")));










 










 helper.method("bar",










 startPoints("c"),



......@@ -255,6 +255,44 @@ public class FieldSensitiveSolverTest {









 helper.runSolver(false, "a");










 }










 










 @Test










 public void pauseOnTransitiveExclusion() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("2", "3")));










 










 helper.method("xyz",










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", writeField("f"), "3^f")),










 normalStmt("e").succ("f")); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumePausedOnTransitiveExclusion() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("2", "3"), flow("2^f", "3^f")));










 










 helper.method("xyz",










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", writeField("f"), "3^f"), flow("3", "4")),










 callSite("e").calls("bar", flow("4", "2.g"), kill("3^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeEdgePausedOnOverwrittenField() {










 helper.method("foo",



......@@ -277,12 +315,12 @@ public class FieldSensitiveSolverTest {









 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")));










 callSite("e").calls("bar", flow("4", "2"), flow("4^f", "2^f")).retSite("f", kill("4"), kill("4^f") /*unwanted call2ret*/));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("3^f"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }



......














test/heros/alias/TestHelper.java








View file @ 1cd34e9e






......@@ -12,6 +12,7 @@ package heros.alias;




















import static org.junit.Assert.assertTrue;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.FlowFunction.Constraint;










import heros.alias.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.solver.IFDSSolver;



......@@ -89,22 +90,22 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static Pair<String, String> readField(String fieldName) {










 return new Pair<String, String>(fieldName, null);










 public static Constraint<String> readField(String fieldName) {










 return new FlowFunction.ReadFieldConstraint<String>(fieldName);










 }










 










 public static Pair<String, String> writeField(String fieldName) {










 return new Pair<String, String>(null, fieldName);










 public static Constraint<String> writeField(String fieldName) {










 return new FlowFunction.WriteFieldConstraint<String>(fieldName);










 }










 










 public static ExpectedFlowFunction flow(String source, Pair<String, String> fieldAccess, String... targets) {










 return flow(1, source, fieldAccess, targets);










 public static ExpectedFlowFunction flow(String source, Constraint<String> constraint, String... targets) {










 return flow(1, source, constraint, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Pair<String, String> fieldAccess, String... targets) {










 AnnotatedFact<Fact>[] targetFacts = new AnnotatedFact[targets.length];










 public static ExpectedFlowFunction flow(int times, String source, Constraint<String> constraint, String... targets) {










 AnnotatedFact<String, Fact>[] targetFacts = new AnnotatedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new AnnotatedFact<Fact>(new Fact(targets[i]), fieldAccess.getO1(), fieldAccess.getO2());










 targetFacts[i] = new AnnotatedFact<String, Fact>(new Fact(targets[i]), constraint);










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 }



......@@ -114,7 +115,7 @@ public class TestHelper {









 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new Pair<String, String>(null, null), targets);










 return flow(times, source, null, targets);










 }










 










 public static int times(int times) {



......@@ -301,11 +302,11 @@ public class TestHelper {









 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final AnnotatedFact<Fact>[] targets;










 public final AnnotatedFact<String, Fact>[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, AnnotatedFact<Fact>... targets) {










 public ExpectedFlowFunction(int times, Fact source, AnnotatedFact<String, Fact>... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;



......@@ -437,11 +438,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, Fact, Method>() {










 public FlowFunctions<Statement, String, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, String, Fact, Method>() {





















 @Override










 public FlowFunction<Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 public FlowFunction<String, Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -453,7 +454,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 public FlowFunction<String, Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr) && edge.succUnit.equals(succ)) {










 return createFlowFunction(edge);



......@@ -463,7 +464,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 public FlowFunction<String, Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -473,7 +474,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 public FlowFunction<String, Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -482,11 +483,11 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<Fact>() {










 private FlowFunction<String, Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<String, Fact>() {










 @Override










 public Set<AnnotatedFact<Fact>> computeTargets(Fact source) {










 Set<AnnotatedFact<Fact>> result = Sets.newHashSet();










 public Set<AnnotatedFact<String, Fact>> computeTargets(Fact source) {










 Set<AnnotatedFact<String, Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {



......@@ -509,17 +510,17 @@ public class TestHelper {









 }





















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 FieldSensitiveIFDSSolver<Statement, String,Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement, String,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 FieldSensitiveIFDSSolver<Statement, String, String, Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement,String,  String,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 solver.solve();










 assertAllFlowFunctionsUsed();










 }










 










 










 private IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 private IFDSTabulationProblem<Statement, String, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, Method> icfg = buildIcfg();










 final FlowFunctions<Statement, Fact, Method> flowFunctions = flowFunctions();










 final FlowFunctions<Statement, String, Fact, Method> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>() {










 return new IFDSTabulationProblem<Statement,String,  Fact, Method, InterproceduralCFG<Statement, Method>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -542,7 +543,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 public FlowFunctions<Statement,String,  Fact, Method> flowFunctions() {










 return flowFunctions;










 }














......














src/heros/alias/AccessPath.java



0 â†’ 100644







View file @ 1cd34e9e













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.collect.Sets;





















@SuppressWarnings("unchecked")










public class AccessPath<FieldRef> {





















 private FieldRef[] accesses;










 private Set<FieldRef>[] exclusions;










 










 public AccessPath() {










 accesses = (FieldRef[]) new Object[0];










 exclusions = new Set[0];










 }










 










 AccessPath(FieldRef[] accesses, Set<FieldRef>[] exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean hasExclusions() {










 return exclusions.length > 0;










 }










 










 public boolean isAccessInExclusions(FieldRef... fieldReferences) {










 for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 if(exclusions[i].contains(fieldReferences[i]))










 return true;










 } 










 return false;










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException();





















 FieldRef[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 Set<FieldRef>[] newExclusionsArray = exclusions.length < fieldReferences.length ? exclusions : Arrays.copyOfRange(exclusions, fieldReferences.length, exclusions.length); 










 return new AccessPath<FieldRef>(newAccesses, newExclusionsArray);










 }





















 public ExclusionSet getExclusions(int index) {










 return new ExclusionSet(index);










 }










 










 public AccessPath<FieldRef> appendExcludedFieldReference(FieldRef... fieldReferences) {










 Set<FieldRef>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);










 newExclusionsArray[exclusions.length] = Sets.newHashSet(fieldReferences);










 return new AccessPath<>(accesses, newExclusionsArray);










 }










 










 public boolean isPrefixOf(AccessPath<FieldRef> accessPath) {










 if(accesses.length > accessPath.accesses.length)










 return false;










 










 if(accesses.length + exclusions.length > accessPath.accesses.length + accessPath.exclusions.length)










 return false;










 










 for(int i=0; i<accesses.length; i++) {










 if(!accesses[i].equals(accessPath.accesses[i]))










 return false;










 }










 










 for(int i=0; i<exclusions.length; i++) {










 if(i+accesses.length < accessPath.accesses.length) {










 if(exclusions[i].contains(accessPath.accesses[i+accesses.length]))










 return false;










 }










 else {










 if(!exclusions[i].containsAll(accessPath.exclusions[i+accesses.length - accessPath.accesses.length]))










 return false;










 }










 }










 










 return true;










 }










 










 public FieldRef[] getDeltaTo(AccessPath<FieldRef> accPath) {










 if(isPrefixOf(accPath))










 return Arrays.copyOfRange(accPath.accesses, accesses.length, accPath.accesses.length);










 else










 throw new IllegalArgumentException("Given AccessPath must be a prefix of the current AccessPath");










 }










 










 public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {










 Set<FieldRef>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];










 for(int i=0; i<newExclusionArray.length; i++) {










 newExclusionArray[i] = Sets.newHashSet();










 if(i<exclusions.length)










 newExclusionArray[i].addAll(exclusions[i]);










 if(i<accPath.exclusions.length)










 newExclusionArray[i].addAll(accPath.exclusions[i]);










 }










 return new AccessPath<>(accesses, newExclusionArray);










 }










 










 public boolean isEmpty() {










 return exclusions.length == 0 && accesses.length == 0;










 }










 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + Arrays.hashCode(exclusions);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof AccessPath))










 return false;










 AccessPath other = (AccessPath) obj;










 if (!Arrays.equals(accesses, other.accesses))










 return false;










 if (!Arrays.equals(exclusions, other.exclusions))










 return false;










 return true;










 }





















 @Override










 public String toString() {










 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 for(Set<FieldRef> exclusion : exclusions) {










 result += "^" + Joiner.on(",").join(exclusion);










 }










 return result;










 }










 










 public class ExclusionSet {










 private int index;










 










 private ExclusionSet(int index) {










 this.index = index;










 }










 










 public AccessPath<FieldRef> addExclusion(FieldRef exclusion) {










 HashSet<FieldRef> newExclusions = Sets.newHashSet(exclusions[index]);










 newExclusions.add(exclusion);










 Set<FieldRef>[] newExclusionsArray = exclusions.clone();










 newExclusionsArray[index] = newExclusions;










 return new AccessPath<FieldRef>(accesses, newExclusionsArray);










 }










 }










}












src/heros/alias/AccessPath.java



0 â†’ 100644







View file @ 1cd34e9e








src/heros/alias/AccessPath.java



0 â†’ 100644









View file @ 1cd34e9e


1cd34e9e










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.collect.Sets;





















@SuppressWarnings("unchecked")










public class AccessPath<FieldRef> {





















 private FieldRef[] accesses;










 private Set<FieldRef>[] exclusions;










 










 public AccessPath() {










 accesses = (FieldRef[]) new Object[0];










 exclusions = new Set[0];










 }










 










 AccessPath(FieldRef[] accesses, Set<FieldRef>[] exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean hasExclusions() {










 return exclusions.length > 0;










 }










 










 public boolean isAccessInExclusions(FieldRef... fieldReferences) {










 for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 if(exclusions[i].contains(fieldReferences[i]))










 return true;










 } 










 return false;










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException();





















 FieldRef[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 Set<FieldRef>[] newExclusionsArray = exclusions.length < fieldReferences.length ? exclusions : Arrays.copyOfRange(exclusions, fieldReferences.length, exclusions.length); 










 return new AccessPath<FieldRef>(newAccesses, newExclusionsArray);










 }





















 public ExclusionSet getExclusions(int index) {










 return new ExclusionSet(index);










 }










 










 public AccessPath<FieldRef> appendExcludedFieldReference(FieldRef... fieldReferences) {










 Set<FieldRef>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);










 newExclusionsArray[exclusions.length] = Sets.newHashSet(fieldReferences);










 return new AccessPath<>(accesses, newExclusionsArray);










 }










 










 public boolean isPrefixOf(AccessPath<FieldRef> accessPath) {










 if(accesses.length > accessPath.accesses.length)










 return false;










 










 if(accesses.length + exclusions.length > accessPath.accesses.length + accessPath.exclusions.length)










 return false;










 










 for(int i=0; i<accesses.length; i++) {










 if(!accesses[i].equals(accessPath.accesses[i]))










 return false;










 }










 










 for(int i=0; i<exclusions.length; i++) {










 if(i+accesses.length < accessPath.accesses.length) {










 if(exclusions[i].contains(accessPath.accesses[i+accesses.length]))










 return false;










 }










 else {










 if(!exclusions[i].containsAll(accessPath.exclusions[i+accesses.length - accessPath.accesses.length]))










 return false;










 }










 }










 










 return true;










 }










 










 public FieldRef[] getDeltaTo(AccessPath<FieldRef> accPath) {










 if(isPrefixOf(accPath))










 return Arrays.copyOfRange(accPath.accesses, accesses.length, accPath.accesses.length);










 else










 throw new IllegalArgumentException("Given AccessPath must be a prefix of the current AccessPath");










 }










 










 public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {










 Set<FieldRef>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];










 for(int i=0; i<newExclusionArray.length; i++) {










 newExclusionArray[i] = Sets.newHashSet();










 if(i<exclusions.length)










 newExclusionArray[i].addAll(exclusions[i]);










 if(i<accPath.exclusions.length)










 newExclusionArray[i].addAll(accPath.exclusions[i]);










 }










 return new AccessPath<>(accesses, newExclusionArray);










 }










 










 public boolean isEmpty() {










 return exclusions.length == 0 && accesses.length == 0;










 }










 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + Arrays.hashCode(exclusions);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof AccessPath))










 return false;










 AccessPath other = (AccessPath) obj;










 if (!Arrays.equals(accesses, other.accesses))










 return false;










 if (!Arrays.equals(exclusions, other.exclusions))










 return false;










 return true;










 }





















 @Override










 public String toString() {










 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 for(Set<FieldRef> exclusion : exclusions) {










 result += "^" + Joiner.on(",").join(exclusion);










 }










 return result;










 }










 










 public class ExclusionSet {










 private int index;










 










 private ExclusionSet(int index) {










 this.index = index;










 }










 










 public AccessPath<FieldRef> addExclusion(FieldRef exclusion) {










 HashSet<FieldRef> newExclusions = Sets.newHashSet(exclusions[index]);










 newExclusions.add(exclusion);










 Set<FieldRef>[] newExclusionsArray = exclusions.clone();










 newExclusionsArray[index] = newExclusions;










 return new AccessPath<FieldRef>(accesses, newExclusionsArray);










 }










 }










}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Arrays;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.collect.Sets;





















@SuppressWarnings("unchecked")










public class AccessPath<FieldRef> {





















 private FieldRef[] accesses;










 private Set<FieldRef>[] exclusions;










 










 public AccessPath() {










 accesses = (FieldRef[]) new Object[0];










 exclusions = new Set[0];










 }










 










 AccessPath(FieldRef[] accesses, Set<FieldRef>[] exclusions) {










 this.accesses = accesses;










 this.exclusions = exclusions;










 }





















 public boolean hasExclusions() {










 return exclusions.length > 0;










 }










 










 public boolean isAccessInExclusions(FieldRef... fieldReferences) {










 for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {










 if(exclusions[i].contains(fieldReferences[i]))










 return true;










 } 










 return false;










 }










 










 public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {










 if(isAccessInExclusions(fieldReferences))










 throw new IllegalArgumentException();





















 FieldRef[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);










 System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);










 Set<FieldRef>[] newExclusionsArray = exclusions.length < fieldReferences.length ? exclusions : Arrays.copyOfRange(exclusions, fieldReferences.length, exclusions.length); 










 return new AccessPath<FieldRef>(newAccesses, newExclusionsArray);










 }





















 public ExclusionSet getExclusions(int index) {










 return new ExclusionSet(index);










 }










 










 public AccessPath<FieldRef> appendExcludedFieldReference(FieldRef... fieldReferences) {










 Set<FieldRef>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);










 newExclusionsArray[exclusions.length] = Sets.newHashSet(fieldReferences);










 return new AccessPath<>(accesses, newExclusionsArray);










 }










 










 public boolean isPrefixOf(AccessPath<FieldRef> accessPath) {










 if(accesses.length > accessPath.accesses.length)










 return false;










 










 if(accesses.length + exclusions.length > accessPath.accesses.length + accessPath.exclusions.length)










 return false;










 










 for(int i=0; i<accesses.length; i++) {










 if(!accesses[i].equals(accessPath.accesses[i]))










 return false;










 }










 










 for(int i=0; i<exclusions.length; i++) {










 if(i+accesses.length < accessPath.accesses.length) {










 if(exclusions[i].contains(accessPath.accesses[i+accesses.length]))










 return false;










 }










 else {










 if(!exclusions[i].containsAll(accessPath.exclusions[i+accesses.length - accessPath.accesses.length]))










 return false;










 }










 }










 










 return true;










 }










 










 public FieldRef[] getDeltaTo(AccessPath<FieldRef> accPath) {










 if(isPrefixOf(accPath))










 return Arrays.copyOfRange(accPath.accesses, accesses.length, accPath.accesses.length);










 else










 throw new IllegalArgumentException("Given AccessPath must be a prefix of the current AccessPath");










 }










 










 public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {










 Set<FieldRef>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];










 for(int i=0; i<newExclusionArray.length; i++) {










 newExclusionArray[i] = Sets.newHashSet();










 if(i<exclusions.length)










 newExclusionArray[i].addAll(exclusions[i]);










 if(i<accPath.exclusions.length)










 newExclusionArray[i].addAll(accPath.exclusions[i]);










 }










 return new AccessPath<>(accesses, newExclusionArray);










 }










 










 public boolean isEmpty() {










 return exclusions.length == 0 && accesses.length == 0;










 }










 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accesses);










 result = prime * result + Arrays.hashCode(exclusions);










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof AccessPath))










 return false;










 AccessPath other = (AccessPath) obj;










 if (!Arrays.equals(accesses, other.accesses))










 return false;










 if (!Arrays.equals(exclusions, other.exclusions))










 return false;










 return true;










 }





















 @Override










 public String toString() {










 String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";










 for(Set<FieldRef> exclusion : exclusions) {










 result += "^" + Joiner.on(",").join(exclusion);










 }










 return result;










 }










 










 public class ExclusionSet {










 private int index;










 










 private ExclusionSet(int index) {










 this.index = index;










 }










 










 public AccessPath<FieldRef> addExclusion(FieldRef exclusion) {










 HashSet<FieldRef> newExclusions = Sets.newHashSet(exclusions[index]);










 newExclusions.add(exclusion);










 Set<FieldRef>[] newExclusionsArray = exclusions.clone();










 newExclusionsArray[index] = newExclusions;










 return new AccessPath<FieldRef>(accesses, newExclusionsArray);










 }










 }










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import java.util.Arrays;importjava.util.Arrays;import java.util.HashSet;importjava.util.HashSet;import java.util.Set;importjava.util.Set;import com.google.common.base.Joiner;importcom.google.common.base.Joiner;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;@SuppressWarnings("unchecked")@SuppressWarnings("unchecked")public class AccessPath<FieldRef> {publicclassAccessPath<FieldRef>{ private FieldRef[] accesses;privateFieldRef[]accesses; private Set<FieldRef>[] exclusions;privateSet<FieldRef>[]exclusions;  public AccessPath() {publicAccessPath(){ accesses = (FieldRef[]) new Object[0];accesses=(FieldRef[])newObject[0]; exclusions = new Set[0];exclusions=newSet[0]; }}  AccessPath(FieldRef[] accesses, Set<FieldRef>[] exclusions) {AccessPath(FieldRef[]accesses,Set<FieldRef>[]exclusions){ this.accesses = accesses;this.accesses=accesses; this.exclusions = exclusions;this.exclusions=exclusions; }} public boolean hasExclusions() {publicbooleanhasExclusions(){ return exclusions.length > 0;returnexclusions.length>0; }}  public boolean isAccessInExclusions(FieldRef... fieldReferences) {publicbooleanisAccessInExclusions(FieldRef...fieldReferences){ for(int i=0; i<fieldReferences.length && i<exclusions.length; i++) {for(inti=0;i<fieldReferences.length&&i<exclusions.length;i++){ if(exclusions[i].contains(fieldReferences[i]))if(exclusions[i].contains(fieldReferences[i])) return true;returntrue; } } return false;returnfalse; }}  public AccessPath<FieldRef> addFieldReference(FieldRef... fieldReferences) {publicAccessPath<FieldRef>addFieldReference(FieldRef...fieldReferences){ if(isAccessInExclusions(fieldReferences))if(isAccessInExclusions(fieldReferences)) throw new IllegalArgumentException();thrownewIllegalArgumentException(); FieldRef[] newAccesses = Arrays.copyOf(accesses, accesses.length+fieldReferences.length);FieldRef[]newAccesses=Arrays.copyOf(accesses,accesses.length+fieldReferences.length); System.arraycopy(fieldReferences, 0, newAccesses, accesses.length, fieldReferences.length);System.arraycopy(fieldReferences,0,newAccesses,accesses.length,fieldReferences.length); Set<FieldRef>[] newExclusionsArray = exclusions.length < fieldReferences.length ? exclusions : Arrays.copyOfRange(exclusions, fieldReferences.length, exclusions.length); Set<FieldRef>[]newExclusionsArray=exclusions.length<fieldReferences.length?exclusions:Arrays.copyOfRange(exclusions,fieldReferences.length,exclusions.length); return new AccessPath<FieldRef>(newAccesses, newExclusionsArray);returnnewAccessPath<FieldRef>(newAccesses,newExclusionsArray); }} public ExclusionSet getExclusions(int index) {publicExclusionSetgetExclusions(intindex){ return new ExclusionSet(index);returnnewExclusionSet(index); }}  public AccessPath<FieldRef> appendExcludedFieldReference(FieldRef... fieldReferences) {publicAccessPath<FieldRef>appendExcludedFieldReference(FieldRef...fieldReferences){ Set<FieldRef>[] newExclusionsArray = Arrays.copyOf(exclusions, exclusions.length+1);Set<FieldRef>[]newExclusionsArray=Arrays.copyOf(exclusions,exclusions.length+1); newExclusionsArray[exclusions.length] = Sets.newHashSet(fieldReferences);newExclusionsArray[exclusions.length]=Sets.newHashSet(fieldReferences); return new AccessPath<>(accesses, newExclusionsArray);returnnewAccessPath<>(accesses,newExclusionsArray); }}  public boolean isPrefixOf(AccessPath<FieldRef> accessPath) {publicbooleanisPrefixOf(AccessPath<FieldRef>accessPath){ if(accesses.length > accessPath.accesses.length)if(accesses.length>accessPath.accesses.length) return false;returnfalse;  if(accesses.length + exclusions.length > accessPath.accesses.length + accessPath.exclusions.length)if(accesses.length+exclusions.length>accessPath.accesses.length+accessPath.exclusions.length) return false;returnfalse;  for(int i=0; i<accesses.length; i++) {for(inti=0;i<accesses.length;i++){ if(!accesses[i].equals(accessPath.accesses[i]))if(!accesses[i].equals(accessPath.accesses[i])) return false;returnfalse; }}  for(int i=0; i<exclusions.length; i++) {for(inti=0;i<exclusions.length;i++){ if(i+accesses.length < accessPath.accesses.length) {if(i+accesses.length<accessPath.accesses.length){ if(exclusions[i].contains(accessPath.accesses[i+accesses.length]))if(exclusions[i].contains(accessPath.accesses[i+accesses.length])) return false;returnfalse; }} else {else{ if(!exclusions[i].containsAll(accessPath.exclusions[i+accesses.length - accessPath.accesses.length]))if(!exclusions[i].containsAll(accessPath.exclusions[i+accesses.length-accessPath.accesses.length])) return false;returnfalse; }} }}  return true;returntrue; }}  public FieldRef[] getDeltaTo(AccessPath<FieldRef> accPath) {publicFieldRef[]getDeltaTo(AccessPath<FieldRef>accPath){ if(isPrefixOf(accPath))if(isPrefixOf(accPath)) return Arrays.copyOfRange(accPath.accesses, accesses.length, accPath.accesses.length);returnArrays.copyOfRange(accPath.accesses,accesses.length,accPath.accesses.length); elseelse throw new IllegalArgumentException("Given AccessPath must be a prefix of the current AccessPath");thrownewIllegalArgumentException("Given AccessPath must be a prefix of the current AccessPath"); }}  public AccessPath<FieldRef> mergeExcludedFieldReferences(AccessPath<FieldRef> accPath) {publicAccessPath<FieldRef>mergeExcludedFieldReferences(AccessPath<FieldRef>accPath){ Set<FieldRef>[] newExclusionArray = new Set[Math.max(exclusions.length,accPath.exclusions.length)];Set<FieldRef>[]newExclusionArray=newSet[Math.max(exclusions.length,accPath.exclusions.length)]; for(int i=0; i<newExclusionArray.length; i++) {for(inti=0;i<newExclusionArray.length;i++){ newExclusionArray[i] = Sets.newHashSet();newExclusionArray[i]=Sets.newHashSet(); if(i<exclusions.length)if(i<exclusions.length) newExclusionArray[i].addAll(exclusions[i]);newExclusionArray[i].addAll(exclusions[i]); if(i<accPath.exclusions.length)if(i<accPath.exclusions.length) newExclusionArray[i].addAll(accPath.exclusions[i]);newExclusionArray[i].addAll(accPath.exclusions[i]); }} return new AccessPath<>(accesses, newExclusionArray);returnnewAccessPath<>(accesses,newExclusionArray); }}  public boolean isEmpty() {publicbooleanisEmpty(){ return exclusions.length == 0 && accesses.length == 0;returnexclusions.length==0&&accesses.length==0; }}  @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + Arrays.hashCode(accesses);result=prime*result+Arrays.hashCode(accesses); result = prime * result + Arrays.hashCode(exclusions);result=prime*result+Arrays.hashCode(exclusions); return result;returnresult; }} @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (!(obj instanceof AccessPath))if(!(objinstanceofAccessPath)) return false;returnfalse; AccessPath other = (AccessPath) obj;AccessPathother=(AccessPath)obj; if (!Arrays.equals(accesses, other.accesses))if(!Arrays.equals(accesses,other.accesses)) return false;returnfalse; if (!Arrays.equals(exclusions, other.exclusions))if(!Arrays.equals(exclusions,other.exclusions)) return false;returnfalse; return true;returntrue; }} @Override@Override public String toString() {publicStringtoString(){ String result = accesses.length > 0 ? "."+Joiner.on(".").join(accesses) : "";Stringresult=accesses.length>0?"."+Joiner.on(".").join(accesses):""; for(Set<FieldRef> exclusion : exclusions) {for(Set<FieldRef>exclusion:exclusions){ result += "^" + Joiner.on(",").join(exclusion);result+="^"+Joiner.on(",").join(exclusion); }} return result;returnresult; }}  public class ExclusionSet {publicclassExclusionSet{ private int index;privateintindex;  private ExclusionSet(int index) {privateExclusionSet(intindex){ this.index = index;this.index=index; }}  public AccessPath<FieldRef> addExclusion(FieldRef exclusion) {publicAccessPath<FieldRef>addExclusion(FieldRefexclusion){ HashSet<FieldRef> newExclusions = Sets.newHashSet(exclusions[index]);HashSet<FieldRef>newExclusions=Sets.newHashSet(exclusions[index]); newExclusions.add(exclusion);newExclusions.add(exclusion); Set<FieldRef>[] newExclusionsArray = exclusions.clone();Set<FieldRef>[]newExclusionsArray=exclusions.clone(); newExclusionsArray[index] = newExclusions;newExclusionsArray[index]=newExclusions; return new AccessPath<FieldRef>(accesses, newExclusionsArray);returnnewAccessPath<FieldRef>(accesses,newExclusionsArray); }} }}}}








src/heros/alias/AccessPathUtil.java








View file @ 1cd34e9e






......@@ -14,91 +14,57 @@ import java.util.ArrayList;




















import com.google.common.base.Optional;





















import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;





















public class AccessPathUtil {





















 public static <D extends FieldSensitiveFact<?, D>> boolean isPrefixOf(D prefixCandidate, D fact) {










 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> boolean isPrefixOf(D prefixCandidate, D fact) {










 if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue()))










 return false; 










 return false;










 










 FieldReference[] prefixAccessPath = prefixCandidate.getAccessPath();










 FieldReference[] factAccessPath = fact.getAccessPath();










 










 for(int i=0; i<prefixAccessPath.length; i++) {










 if(i < factAccessPath.length) {










 if(!prefixAccessPath[i].includes(factAccessPath[i]))










 return false;










 }










 else if(!(prefixAccessPath[i] instanceof Any))










 return false; 










 }










 










 return true;










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }










 










 public static <D extends FieldSensitiveFact<?, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 FieldReference[] concreteAccessPath = sourceFact.getAccessPath();










 FieldReference[] abstractAccessPath = summary.getSourceFact().getAccessPath();










 FieldReference[] targetAccessPath = summary.getTargetFact().getAccessPath();










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 FieldRef[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(targetAccessPath.isAccessInExclusions(delta))










 return Optional.absent();










 










 ArrayList<FieldReference> result = new ArrayList<>(targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length);










 int lastSpecificField = -1;










 for(int i=0; i< targetAccessPath.length; i++) {










 result.add(targetAccessPath[i]);










 if(targetAccessPath[i] instanceof SpecificFieldReference)










 lastSpecificField = i;










 }










 AccessPath<FieldRef> result = targetAccessPath.addFieldReference(delta);










 result = result.mergeExcludedFieldReferences(concreteAccessPath);










 










 for(int i=abstractAccessPath.length; i<concreteAccessPath.length; i++) {










 if(lastSpecificField+1 < result.size()) {










 Optional<? extends FieldReference> mergedFieldRef = concreteAccessPath[i].merge((Any) result.get(lastSpecificField+1));










 if(!mergedFieldRef.isPresent())










 return Optional.absent();










 










 result.set(lastSpecificField+1, mergedFieldRef.get());










 lastSpecificField++;










 } else {










 result.add(concreteAccessPath[i]);










 }










 }










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result.toArray(new FieldReference[result.size()])));










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <D extends FieldSensitiveFact<?, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {










 FieldReference[] accessPath = new FieldReference[fact.getAccessPath().length+fieldRefs.length];










 System.arraycopy(fact.getAccessPath(), 0, accessPath, 0, fact.getAccessPath().length);










 System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);










 return fact.cloneWithAccessPath(accessPath);










 }










//	public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {










//		FieldReference[] accessPath = new FieldReference[fact.getAccessPath().length+fieldRefs.length];










//		System.arraycopy(fact.getAccessPath(), 0, accessPath, 0, fact.getAccessPath().length);










//		System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);










//		return fact.cloneWithAccessPath(accessPath);










//	}










 










 public static <D extends FieldSensitiveFact<?, D>> D concretizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {










 if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))










 throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));










 










 FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();










 FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();










 FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();










 










 FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];





















 //copy old access path










 System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










 










 //copy delta access path that was omitted while creating the abstracted source fact










 System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










 










 return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










 }










 










 public static FieldReference[] getAccessPathDelta(FieldReference[] prefixAccessPath, FieldReference[] accessPath) {










 FieldReference[] result = new FieldReference[accessPath.length - prefixAccessPath.length];










 System.arraycopy(accessPath, prefixAccessPath.length, result, 0, result.length);










 return result;










 }










//	public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D concretizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {










//		if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))










//			throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));










//		










//		FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();










//		FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();










//		FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();










//		










//		FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];










//










//		//copy old access path










//		System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










//		










//		//copy delta access path that was omitted while creating the abstracted source fact










//		System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










//		










//		return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










//	}










}












src/heros/alias/AccessPathUtil.java








View file @ 1cd34e9e








src/heros/alias/AccessPathUtil.java










View file @ 1cd34e9e


1cd34e9e



......@@ -14,91 +14,57 @@ import java.util.ArrayList;




















import com.google.common.base.Optional;





















import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;





















public class AccessPathUtil {





















 public static <D extends FieldSensitiveFact<?, D>> boolean isPrefixOf(D prefixCandidate, D fact) {










 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> boolean isPrefixOf(D prefixCandidate, D fact) {










 if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue()))










 return false; 










 return false;










 










 FieldReference[] prefixAccessPath = prefixCandidate.getAccessPath();










 FieldReference[] factAccessPath = fact.getAccessPath();










 










 for(int i=0; i<prefixAccessPath.length; i++) {










 if(i < factAccessPath.length) {










 if(!prefixAccessPath[i].includes(factAccessPath[i]))










 return false;










 }










 else if(!(prefixAccessPath[i] instanceof Any))










 return false; 










 }










 










 return true;










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }










 










 public static <D extends FieldSensitiveFact<?, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 FieldReference[] concreteAccessPath = sourceFact.getAccessPath();










 FieldReference[] abstractAccessPath = summary.getSourceFact().getAccessPath();










 FieldReference[] targetAccessPath = summary.getTargetFact().getAccessPath();










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 FieldRef[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(targetAccessPath.isAccessInExclusions(delta))










 return Optional.absent();










 










 ArrayList<FieldReference> result = new ArrayList<>(targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length);










 int lastSpecificField = -1;










 for(int i=0; i< targetAccessPath.length; i++) {










 result.add(targetAccessPath[i]);










 if(targetAccessPath[i] instanceof SpecificFieldReference)










 lastSpecificField = i;










 }










 AccessPath<FieldRef> result = targetAccessPath.addFieldReference(delta);










 result = result.mergeExcludedFieldReferences(concreteAccessPath);










 










 for(int i=abstractAccessPath.length; i<concreteAccessPath.length; i++) {










 if(lastSpecificField+1 < result.size()) {










 Optional<? extends FieldReference> mergedFieldRef = concreteAccessPath[i].merge((Any) result.get(lastSpecificField+1));










 if(!mergedFieldRef.isPresent())










 return Optional.absent();










 










 result.set(lastSpecificField+1, mergedFieldRef.get());










 lastSpecificField++;










 } else {










 result.add(concreteAccessPath[i]);










 }










 }










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result.toArray(new FieldReference[result.size()])));










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <D extends FieldSensitiveFact<?, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {










 FieldReference[] accessPath = new FieldReference[fact.getAccessPath().length+fieldRefs.length];










 System.arraycopy(fact.getAccessPath(), 0, accessPath, 0, fact.getAccessPath().length);










 System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);










 return fact.cloneWithAccessPath(accessPath);










 }










//	public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {










//		FieldReference[] accessPath = new FieldReference[fact.getAccessPath().length+fieldRefs.length];










//		System.arraycopy(fact.getAccessPath(), 0, accessPath, 0, fact.getAccessPath().length);










//		System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);










//		return fact.cloneWithAccessPath(accessPath);










//	}










 










 public static <D extends FieldSensitiveFact<?, D>> D concretizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {










 if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))










 throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));










 










 FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();










 FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();










 FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();










 










 FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];





















 //copy old access path










 System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










 










 //copy delta access path that was omitted while creating the abstracted source fact










 System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










 










 return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










 }










 










 public static FieldReference[] getAccessPathDelta(FieldReference[] prefixAccessPath, FieldReference[] accessPath) {










 FieldReference[] result = new FieldReference[accessPath.length - prefixAccessPath.length];










 System.arraycopy(accessPath, prefixAccessPath.length, result, 0, result.length);










 return result;










 }










//	public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D concretizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {










//		if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))










//			throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));










//		










//		FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();










//		FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();










//		FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();










//		










//		FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];










//










//		//copy old access path










//		System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










//		










//		//copy delta access path that was omitted while creating the abstracted source fact










//		System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










//		










//		return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










//	}










}






......@@ -14,91 +14,57 @@ import java.util.ArrayList;




















import com.google.common.base.Optional;





















import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;





















public class AccessPathUtil {





















 public static <D extends FieldSensitiveFact<?, D>> boolean isPrefixOf(D prefixCandidate, D fact) {










 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> boolean isPrefixOf(D prefixCandidate, D fact) {










 if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue()))










 return false; 










 return false;










 










 FieldReference[] prefixAccessPath = prefixCandidate.getAccessPath();










 FieldReference[] factAccessPath = fact.getAccessPath();










 










 for(int i=0; i<prefixAccessPath.length; i++) {










 if(i < factAccessPath.length) {










 if(!prefixAccessPath[i].includes(factAccessPath[i]))










 return false;










 }










 else if(!(prefixAccessPath[i] instanceof Any))










 return false; 










 }










 










 return true;










 return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());










 }










 










 public static <D extends FieldSensitiveFact<?, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {










 if(!isPrefixOf(summary.getSourceFact(), sourceFact))










 throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));










 










 FieldReference[] concreteAccessPath = sourceFact.getAccessPath();










 FieldReference[] abstractAccessPath = summary.getSourceFact().getAccessPath();










 FieldReference[] targetAccessPath = summary.getTargetFact().getAccessPath();










 AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();










 AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();










 AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();










 










 FieldRef[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);










 if(targetAccessPath.isAccessInExclusions(delta))










 return Optional.absent();










 










 ArrayList<FieldReference> result = new ArrayList<>(targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length);










 int lastSpecificField = -1;










 for(int i=0; i< targetAccessPath.length; i++) {










 result.add(targetAccessPath[i]);










 if(targetAccessPath[i] instanceof SpecificFieldReference)










 lastSpecificField = i;










 }










 AccessPath<FieldRef> result = targetAccessPath.addFieldReference(delta);










 result = result.mergeExcludedFieldReferences(concreteAccessPath);










 










 for(int i=abstractAccessPath.length; i<concreteAccessPath.length; i++) {










 if(lastSpecificField+1 < result.size()) {










 Optional<? extends FieldReference> mergedFieldRef = concreteAccessPath[i].merge((Any) result.get(lastSpecificField+1));










 if(!mergedFieldRef.isPresent())










 return Optional.absent();










 










 result.set(lastSpecificField+1, mergedFieldRef.get());










 lastSpecificField++;










 } else {










 result.add(concreteAccessPath[i]);










 }










 }










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result.toArray(new FieldReference[result.size()])));










 return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));










 }





















 public static <D extends FieldSensitiveFact<?, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {










 FieldReference[] accessPath = new FieldReference[fact.getAccessPath().length+fieldRefs.length];










 System.arraycopy(fact.getAccessPath(), 0, accessPath, 0, fact.getAccessPath().length);










 System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);










 return fact.cloneWithAccessPath(accessPath);










 }










//	public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {










//		FieldReference[] accessPath = new FieldReference[fact.getAccessPath().length+fieldRefs.length];










//		System.arraycopy(fact.getAccessPath(), 0, accessPath, 0, fact.getAccessPath().length);










//		System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);










//		return fact.cloneWithAccessPath(accessPath);










//	}










 










 public static <D extends FieldSensitiveFact<?, D>> D concretizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {










 if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))










 throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));










 










 FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();










 FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();










 FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();










 










 FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];





















 //copy old access path










 System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










 










 //copy delta access path that was omitted while creating the abstracted source fact










 System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










 










 return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










 }










 










 public static FieldReference[] getAccessPathDelta(FieldReference[] prefixAccessPath, FieldReference[] accessPath) {










 FieldReference[] result = new FieldReference[accessPath.length - prefixAccessPath.length];










 System.arraycopy(accessPath, prefixAccessPath.length, result, 0, result.length);










 return result;










 }










//	public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D concretizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {










//		if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))










//			throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));










//		










//		FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();










//		FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();










//		FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();










//		










//		FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];










//










//		//copy old access path










//		System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);










//		










//		//copy delta access path that was omitted while creating the abstracted source fact










//		System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);










//		










//		return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);










//	}










}


import com.google.common.base.Optional;importcom.google.common.base.Optional;import heros.alias.FieldReference.Any;importheros.alias.FieldReference.Any;import heros.alias.FieldReference.SpecificFieldReference;importheros.alias.FieldReference.SpecificFieldReference;public class AccessPathUtil {publicclassAccessPathUtil{ public static <D extends FieldSensitiveFact<?, D>> boolean isPrefixOf(D prefixCandidate, D fact) {publicstatic<DextendsFieldSensitiveFact<?,D>>booleanisPrefixOf(DprefixCandidate,Dfact){ public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> boolean isPrefixOf(D prefixCandidate, D fact) {publicstatic<FieldRefFieldRef,, DextendsFieldSensitiveFact<?,FieldRefFieldRef,, D>>booleanisPrefixOf(DprefixCandidate,Dfact){ if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue()))if(!prefixCandidate.getBaseValue().equals(fact.getBaseValue())) return false; returnfalse;  return false;returnfalse;  FieldReference[] prefixAccessPath = prefixCandidate.getAccessPath();FieldReference[]prefixAccessPath=prefixCandidate.getAccessPath(); FieldReference[] factAccessPath = fact.getAccessPath();FieldReference[]factAccessPath=fact.getAccessPath();  for(int i=0; i<prefixAccessPath.length; i++) {for(inti=0;i<prefixAccessPath.length;i++){ if(i < factAccessPath.length) {if(i<factAccessPath.length){ if(!prefixAccessPath[i].includes(factAccessPath[i]))if(!prefixAccessPath[i].includes(factAccessPath[i])) return false;returnfalse; }} else if(!(prefixAccessPath[i] instanceof Any))elseif(!(prefixAccessPath[i]instanceofAny)) return false; returnfalse; }}  return true;returntrue; return prefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath());returnprefixCandidate.getAccessPath().isPrefixOf(fact.getAccessPath()); }}  public static <D extends FieldSensitiveFact<?, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {publicstatic<DextendsFieldSensitiveFact<?,D>>Optional<D>applyAbstractedSummary(DsourceFact,SummaryEdge<D,?>summary){ public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> Optional<D> applyAbstractedSummary(D sourceFact, SummaryEdge<D, ?> summary) {publicstatic<FieldRefFieldRef,, DextendsFieldSensitiveFact<?,FieldRefFieldRef,, D>>Optional<D>applyAbstractedSummary(DsourceFact,SummaryEdge<D,?>summary){ if(!isPrefixOf(summary.getSourceFact(), sourceFact))if(!isPrefixOf(summary.getSourceFact(),sourceFact)) throw new IllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'", summary, sourceFact));thrownewIllegalArgumentException(String.format("Source fact in given summary edge '%s' is not a prefix of the given source fact '%s'",summary,sourceFact));  FieldReference[] concreteAccessPath = sourceFact.getAccessPath();FieldReferenceFieldReference[][]concreteAccessPath=sourceFact.getAccessPath(); FieldReference[] abstractAccessPath = summary.getSourceFact().getAccessPath();FieldReferenceFieldReference[][]abstractAccessPath=summary.getSourceFact().getAccessPath(); FieldReference[] targetAccessPath = summary.getTargetFact().getAccessPath();FieldReferenceFieldReference[][]targetAccessPath=summary.getTargetFact().getAccessPath(); AccessPath<FieldRef> concreteAccessPath = sourceFact.getAccessPath();AccessPathAccessPath<<FieldRefFieldRef>>concreteAccessPath=sourceFact.getAccessPath(); AccessPath<FieldRef> abstractAccessPath = summary.getSourceFact().getAccessPath();AccessPathAccessPath<<FieldRefFieldRef>>abstractAccessPath=summary.getSourceFact().getAccessPath(); AccessPath<FieldRef> targetAccessPath = summary.getTargetFact().getAccessPath();AccessPathAccessPath<<FieldRefFieldRef>>targetAccessPath=summary.getTargetFact().getAccessPath();  FieldRef[] delta = abstractAccessPath.getDeltaTo(concreteAccessPath);FieldRef[]delta=abstractAccessPath.getDeltaTo(concreteAccessPath); if(targetAccessPath.isAccessInExclusions(delta))if(targetAccessPath.isAccessInExclusions(delta)) return Optional.absent();returnOptional.absent();  ArrayList<FieldReference> result = new ArrayList<>(targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length);ArrayList<FieldReference>result=newArrayList<>(targetAccessPath.length+concreteAccessPath.length-abstractAccessPath.length); int lastSpecificField = -1;intlastSpecificField=-1; for(int i=0; i< targetAccessPath.length; i++) {for(inti=0;i<targetAccessPath.length;i++){ result.add(targetAccessPath[i]);result.add(targetAccessPath[i]); if(targetAccessPath[i] instanceof SpecificFieldReference)if(targetAccessPath[i]instanceofSpecificFieldReference) lastSpecificField = i;lastSpecificField=i; }} AccessPath<FieldRef> result = targetAccessPath.addFieldReference(delta);AccessPath<FieldRef>result=targetAccessPath.addFieldReference(delta); result = result.mergeExcludedFieldReferences(concreteAccessPath);result=result.mergeExcludedFieldReferences(concreteAccessPath);  for(int i=abstractAccessPath.length; i<concreteAccessPath.length; i++) {for(inti=abstractAccessPath.length;i<concreteAccessPath.length;i++){ if(lastSpecificField+1 < result.size()) {if(lastSpecificField+1<result.size()){ Optional<? extends FieldReference> mergedFieldRef = concreteAccessPath[i].merge((Any) result.get(lastSpecificField+1));Optional<?extendsFieldReference>mergedFieldRef=concreteAccessPath[i].merge((Any)result.get(lastSpecificField+1)); if(!mergedFieldRef.isPresent())if(!mergedFieldRef.isPresent()) return Optional.absent();returnOptional.absent();  result.set(lastSpecificField+1, mergedFieldRef.get());result.set(lastSpecificField+1,mergedFieldRef.get()); lastSpecificField++;lastSpecificField++; } else {}else{ result.add(concreteAccessPath[i]);result.add(concreteAccessPath[i]); }} }} return Optional.of(summary.getTargetFact().cloneWithAccessPath(result.toArray(new FieldReference[result.size()])));returnOptional.of(summary.getTargetFact().cloneWithAccessPath(result.toArray(newFieldReference[result.size()]))); return Optional.of(summary.getTargetFact().cloneWithAccessPath(result));returnOptional.of(summary.getTargetFact().cloneWithAccessPath(result)); }} public static <D extends FieldSensitiveFact<?, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {publicstatic<DextendsFieldSensitiveFact<?,D>>DcloneWithConcatenatedAccessPath(Dfact,FieldReference...fieldRefs){ FieldReference[] accessPath = new FieldReference[fact.getAccessPath().length+fieldRefs.length];FieldReference[]accessPath=newFieldReference[fact.getAccessPath().length+fieldRefs.length]; System.arraycopy(fact.getAccessPath(), 0, accessPath, 0, fact.getAccessPath().length);System.arraycopy(fact.getAccessPath(),0,accessPath,0,fact.getAccessPath().length); System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);System.arraycopy(fieldRefs,0,accessPath,fact.getAccessPath().length,fieldRefs.length); return fact.cloneWithAccessPath(accessPath);returnfact.cloneWithAccessPath(accessPath); }}//	public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {//	public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D cloneWithConcatenatedAccessPath(D fact, FieldReference... fieldRefs) {//FieldRef, FieldRef, //		FieldReference[] accessPath = new FieldReference[fact.getAccessPath().length+fieldRefs.length];//		FieldReference[] accessPath = new FieldReference[fact.getAccessPath().length+fieldRefs.length];////		System.arraycopy(fact.getAccessPath(), 0, accessPath, 0, fact.getAccessPath().length);//		System.arraycopy(fact.getAccessPath(), 0, accessPath, 0, fact.getAccessPath().length);////		System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);//		System.arraycopy(fieldRefs, 0, accessPath, fact.getAccessPath().length, fieldRefs.length);////		return fact.cloneWithAccessPath(accessPath);//		return fact.cloneWithAccessPath(accessPath);////	}//	}//  public static <D extends FieldSensitiveFact<?, D>> D concretizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {publicstatic<DextendsFieldSensitiveFact<?,D>>DconcretizeCallerSourceFact(IncomingEdge<D,?>incomingEdge,DcalleeSourceFact){ if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))if(!isPrefixOf(incomingEdge.getCalleeSourceFact(),calleeSourceFact)) throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));thrownewIllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.",incomingEdge,calleeSourceFact));  FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();FieldReference[]abstractAccessPath=incomingEdge.getCalleeSourceFact().getAccessPath(); FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();FieldReference[]concreteAccessPath=calleeSourceFact.getAccessPath(); FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();FieldReference[]targetAccessPath=incomingEdge.getCallerSourceFact().getAccessPath();  FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];FieldReference[]resultAccessPath=newFieldReference[targetAccessPath.length+concreteAccessPath.length-abstractAccessPath.length]; //copy old access path//copy old access path System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);System.arraycopy(targetAccessPath,0,resultAccessPath,0,targetAccessPath.length);  //copy delta access path that was omitted while creating the abstracted source fact//copy delta access path that was omitted while creating the abstracted source fact System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);System.arraycopy(concreteAccessPath,abstractAccessPath.length,resultAccessPath,targetAccessPath.length,concreteAccessPath.length-abstractAccessPath.length);  return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);returnincomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath); }}  public static FieldReference[] getAccessPathDelta(FieldReference[] prefixAccessPath, FieldReference[] accessPath) {publicstaticFieldReference[]getAccessPathDelta(FieldReference[]prefixAccessPath,FieldReference[]accessPath){ FieldReference[] result = new FieldReference[accessPath.length - prefixAccessPath.length];FieldReference[]result=newFieldReference[accessPath.length-prefixAccessPath.length]; System.arraycopy(accessPath, prefixAccessPath.length, result, 0, result.length);System.arraycopy(accessPath,prefixAccessPath.length,result,0,result.length); return result;returnresult; }}//	public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D concretizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {//	public static <FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> D concretizeCallerSourceFact(IncomingEdge<D, ?> incomingEdge, D calleeSourceFact) {//		if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))//		if(!isPrefixOf(incomingEdge.getCalleeSourceFact(), calleeSourceFact))//			throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));//			throw new IllegalArgumentException(String.format("Callee Source Fact in IncomingEdge '%s' is not a prefix of the given fact '%s'.", incomingEdge, calleeSourceFact));//		//		//		FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();//		FieldReference[] abstractAccessPath = incomingEdge.getCalleeSourceFact().getAccessPath();//		FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();//		FieldReference[] concreteAccessPath = calleeSourceFact.getAccessPath();//		FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();//		FieldReference[] targetAccessPath = incomingEdge.getCallerSourceFact().getAccessPath();//		//		//		FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];//		FieldReference[] resultAccessPath = new FieldReference[targetAccessPath.length + concreteAccessPath.length - abstractAccessPath.length];//////		//copy old access path//		//copy old access path//		System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);//		System.arraycopy(targetAccessPath, 0, resultAccessPath, 0, targetAccessPath.length);//		//		//		//copy delta access path that was omitted while creating the abstracted source fact//		//copy delta access path that was omitted while creating the abstracted source fact//		System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);//		System.arraycopy(concreteAccessPath, abstractAccessPath.length, resultAccessPath, targetAccessPath.length, concreteAccessPath.length - abstractAccessPath.length);//		//		//		return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);//		return incomingEdge.getCallerSourceFact().cloneWithAccessPath(resultAccessPath);//	}//	}}}








src/heros/alias/FieldReference.java

deleted


100644 â†’ 0







View file @ ec76098b













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch, Johannes SpÃ¤th.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch, Johannes SpÃ¤th - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FieldReference.Any;





















import java.util.ArrayList;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.base.Optional;










import com.google.common.collect.Sets;





















public interface FieldReference {





















 boolean includes(FieldReference fieldReference);










 










 boolean isIncludedBy(SpecificFieldReference specificFieldRef);










 










 boolean isIncludedBy(Any anyFieldRef);










 










 Optional<? extends FieldReference> merge(Any fieldReference);










 










 public static class Any implements FieldReference {










 private Set<String> excludedFieldNames = Sets.newHashSet();










 










 public Any(String...excludedFieldNames) {










 for (int i = 0; i < excludedFieldNames.length; i++) {










 this.excludedFieldNames.add(excludedFieldNames[i]);










 }










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return false;










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return true;










 }










 










 public Optional<Any> merge(Any fieldReference) {










 ArrayList<String> list = new ArrayList<>(excludedFieldNames);










 list.addAll(fieldReference.excludedFieldNames);










 return Optional.of(new Any(list.toArray(new String[list.size()])));










 }










 










 @Override










 public String toString() {










 if(excludedFieldNames.size() == 0)










 return "";










 else if (excludedFieldNames.size() == 1)










 return "^" + excludedFieldNames.iterator().next();










 else










 return "^{" + Joiner.on(",").join(excludedFieldNames) +"}";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime










 * result










 + ((excludedFieldNames == null) ? 0 : excludedFieldNames










 .hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 Any other = (Any) obj;










 if (excludedFieldNames == null) {










 if (other.excludedFieldNames != null)










 return false;










 } else if (!excludedFieldNames.equals(other.excludedFieldNames))










 return false;










 return true;










 }










 }










 










 public static class SpecificFieldReference implements FieldReference {










 private String fieldName;





















 public SpecificFieldReference(String fieldName) {










 this.fieldName = fieldName;










 }





















 @Override










 public String toString() {










 return fieldName;










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return specificFieldRef.fieldName.equals(fieldName);










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return !anyFieldRef.excludedFieldNames.contains(fieldName);










 }










 










 public Optional<SpecificFieldReference> merge(Any fieldReference) {










 if(fieldReference.excludedFieldNames.contains(fieldName))










 return Optional.absent();










 else 










 return Optional.of(this);










 }










 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result










 + ((fieldName == null) ? 0 : fieldName.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 SpecificFieldReference other = (SpecificFieldReference) obj;










 if (fieldName == null) {










 if (other.fieldName != null)










 return false;










 } else if (!fieldName.equals(other.fieldName))










 return false;










 return true;










 }





















 }










}












src/heros/alias/FieldReference.java

deleted


100644 â†’ 0







View file @ ec76098b








src/heros/alias/FieldReference.java

deleted


100644 â†’ 0









View file @ ec76098b


ec76098b










/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch, Johannes SpÃ¤th.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch, Johannes SpÃ¤th - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FieldReference.Any;





















import java.util.ArrayList;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.base.Optional;










import com.google.common.collect.Sets;





















public interface FieldReference {





















 boolean includes(FieldReference fieldReference);










 










 boolean isIncludedBy(SpecificFieldReference specificFieldRef);










 










 boolean isIncludedBy(Any anyFieldRef);










 










 Optional<? extends FieldReference> merge(Any fieldReference);










 










 public static class Any implements FieldReference {










 private Set<String> excludedFieldNames = Sets.newHashSet();










 










 public Any(String...excludedFieldNames) {










 for (int i = 0; i < excludedFieldNames.length; i++) {










 this.excludedFieldNames.add(excludedFieldNames[i]);










 }










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return false;










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return true;










 }










 










 public Optional<Any> merge(Any fieldReference) {










 ArrayList<String> list = new ArrayList<>(excludedFieldNames);










 list.addAll(fieldReference.excludedFieldNames);










 return Optional.of(new Any(list.toArray(new String[list.size()])));










 }










 










 @Override










 public String toString() {










 if(excludedFieldNames.size() == 0)










 return "";










 else if (excludedFieldNames.size() == 1)










 return "^" + excludedFieldNames.iterator().next();










 else










 return "^{" + Joiner.on(",").join(excludedFieldNames) +"}";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime










 * result










 + ((excludedFieldNames == null) ? 0 : excludedFieldNames










 .hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 Any other = (Any) obj;










 if (excludedFieldNames == null) {










 if (other.excludedFieldNames != null)










 return false;










 } else if (!excludedFieldNames.equals(other.excludedFieldNames))










 return false;










 return true;










 }










 }










 










 public static class SpecificFieldReference implements FieldReference {










 private String fieldName;





















 public SpecificFieldReference(String fieldName) {










 this.fieldName = fieldName;










 }





















 @Override










 public String toString() {










 return fieldName;










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return specificFieldRef.fieldName.equals(fieldName);










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return !anyFieldRef.excludedFieldNames.contains(fieldName);










 }










 










 public Optional<SpecificFieldReference> merge(Any fieldReference) {










 if(fieldReference.excludedFieldNames.contains(fieldName))










 return Optional.absent();










 else 










 return Optional.of(this);










 }










 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result










 + ((fieldName == null) ? 0 : fieldName.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 SpecificFieldReference other = (SpecificFieldReference) obj;










 if (fieldName == null) {










 if (other.fieldName != null)










 return false;










 } else if (!fieldName.equals(other.fieldName))










 return false;










 return true;










 }





















 }










}













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch, Johannes SpÃ¤th.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch, Johannes SpÃ¤th - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.FieldReference.Any;





















import java.util.ArrayList;










import java.util.HashSet;










import java.util.Set;





















import com.google.common.base.Joiner;










import com.google.common.base.Optional;










import com.google.common.collect.Sets;





















public interface FieldReference {





















 boolean includes(FieldReference fieldReference);










 










 boolean isIncludedBy(SpecificFieldReference specificFieldRef);










 










 boolean isIncludedBy(Any anyFieldRef);










 










 Optional<? extends FieldReference> merge(Any fieldReference);










 










 public static class Any implements FieldReference {










 private Set<String> excludedFieldNames = Sets.newHashSet();










 










 public Any(String...excludedFieldNames) {










 for (int i = 0; i < excludedFieldNames.length; i++) {










 this.excludedFieldNames.add(excludedFieldNames[i]);










 }










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return false;










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return true;










 }










 










 public Optional<Any> merge(Any fieldReference) {










 ArrayList<String> list = new ArrayList<>(excludedFieldNames);










 list.addAll(fieldReference.excludedFieldNames);










 return Optional.of(new Any(list.toArray(new String[list.size()])));










 }










 










 @Override










 public String toString() {










 if(excludedFieldNames.size() == 0)










 return "";










 else if (excludedFieldNames.size() == 1)










 return "^" + excludedFieldNames.iterator().next();










 else










 return "^{" + Joiner.on(",").join(excludedFieldNames) +"}";










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime










 * result










 + ((excludedFieldNames == null) ? 0 : excludedFieldNames










 .hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 Any other = (Any) obj;










 if (excludedFieldNames == null) {










 if (other.excludedFieldNames != null)










 return false;










 } else if (!excludedFieldNames.equals(other.excludedFieldNames))










 return false;










 return true;










 }










 }










 










 public static class SpecificFieldReference implements FieldReference {










 private String fieldName;





















 public SpecificFieldReference(String fieldName) {










 this.fieldName = fieldName;










 }





















 @Override










 public String toString() {










 return fieldName;










 }










 










 public boolean includes(FieldReference fieldReference) {










 return fieldReference.isIncludedBy(this);










 }





















 @Override










 public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {










 return specificFieldRef.fieldName.equals(fieldName);










 }





















 @Override










 public boolean isIncludedBy(Any anyFieldRef) {










 return !anyFieldRef.excludedFieldNames.contains(fieldName);










 }










 










 public Optional<SpecificFieldReference> merge(Any fieldReference) {










 if(fieldReference.excludedFieldNames.contains(fieldName))










 return Optional.absent();










 else 










 return Optional.of(this);










 }










 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result










 + ((fieldName == null) ? 0 : fieldName.hashCode());










 return result;










 }





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 return false;










 SpecificFieldReference other = (SpecificFieldReference) obj;










 if (fieldName == null) {










 if (other.fieldName != null)










 return false;










 } else if (!fieldName.equals(other.fieldName))










 return false;










 return true;










 }





















 }










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2014 Johannes Lerch, Johannes SpÃ¤th. * Copyright (c) 2014 Johannes Lerch, Johannes SpÃ¤th. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch, Johannes SpÃ¤th - initial API and implementation *     Johannes Lerch, Johannes SpÃ¤th - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.alias.FieldReference.Any;importheros.alias.FieldReference.Any;import java.util.ArrayList;importjava.util.ArrayList;import java.util.HashSet;importjava.util.HashSet;import java.util.Set;importjava.util.Set;import com.google.common.base.Joiner;importcom.google.common.base.Joiner;import com.google.common.base.Optional;importcom.google.common.base.Optional;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;public interface FieldReference {publicinterfaceFieldReference{ boolean includes(FieldReference fieldReference);booleanincludes(FieldReferencefieldReference);  boolean isIncludedBy(SpecificFieldReference specificFieldRef);booleanisIncludedBy(SpecificFieldReferencespecificFieldRef);  boolean isIncludedBy(Any anyFieldRef);booleanisIncludedBy(AnyanyFieldRef);  Optional<? extends FieldReference> merge(Any fieldReference);Optional<?extendsFieldReference>merge(AnyfieldReference);  public static class Any implements FieldReference {publicstaticclassAnyimplementsFieldReference{ private Set<String> excludedFieldNames = Sets.newHashSet();privateSet<String>excludedFieldNames=Sets.newHashSet();  public Any(String...excludedFieldNames) {publicAny(String...excludedFieldNames){ for (int i = 0; i < excludedFieldNames.length; i++) {for(inti=0;i<excludedFieldNames.length;i++){ this.excludedFieldNames.add(excludedFieldNames[i]);this.excludedFieldNames.add(excludedFieldNames[i]); }} }}  public boolean includes(FieldReference fieldReference) {publicbooleanincludes(FieldReferencefieldReference){ return fieldReference.isIncludedBy(this);returnfieldReference.isIncludedBy(this); }} @Override@Override public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {publicbooleanisIncludedBy(SpecificFieldReferencespecificFieldRef){ return false;returnfalse; }} @Override@Override public boolean isIncludedBy(Any anyFieldRef) {publicbooleanisIncludedBy(AnyanyFieldRef){ return true;returntrue; }}  public Optional<Any> merge(Any fieldReference) {publicOptional<Any>merge(AnyfieldReference){ ArrayList<String> list = new ArrayList<>(excludedFieldNames);ArrayList<String>list=newArrayList<>(excludedFieldNames); list.addAll(fieldReference.excludedFieldNames);list.addAll(fieldReference.excludedFieldNames); return Optional.of(new Any(list.toArray(new String[list.size()])));returnOptional.of(newAny(list.toArray(newString[list.size()]))); }}  @Override@Override public String toString() {publicStringtoString(){ if(excludedFieldNames.size() == 0)if(excludedFieldNames.size()==0) return "";return""; else if (excludedFieldNames.size() == 1)elseif(excludedFieldNames.size()==1) return "^" + excludedFieldNames.iterator().next();return"^"+excludedFieldNames.iterator().next(); elseelse return "^{" + Joiner.on(",").join(excludedFieldNames) +"}";return"^{"+Joiner.on(",").join(excludedFieldNames)+"}"; }} @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = primeresult=prime * result*result + ((excludedFieldNames == null) ? 0 : excludedFieldNames+((excludedFieldNames==null)?0:excludedFieldNames .hashCode());.hashCode()); return result;returnresult; }} @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (getClass() != obj.getClass())if(getClass()!=obj.getClass()) return false;returnfalse; Any other = (Any) obj;Anyother=(Any)obj; if (excludedFieldNames == null) {if(excludedFieldNames==null){ if (other.excludedFieldNames != null)if(other.excludedFieldNames!=null) return false;returnfalse; } else if (!excludedFieldNames.equals(other.excludedFieldNames))}elseif(!excludedFieldNames.equals(other.excludedFieldNames)) return false;returnfalse; return true;returntrue; }} }}  public static class SpecificFieldReference implements FieldReference {publicstaticclassSpecificFieldReferenceimplementsFieldReference{ private String fieldName;privateStringfieldName; public SpecificFieldReference(String fieldName) {publicSpecificFieldReference(StringfieldName){ this.fieldName = fieldName;this.fieldName=fieldName; }} @Override@Override public String toString() {publicStringtoString(){ return fieldName;returnfieldName; }}  public boolean includes(FieldReference fieldReference) {publicbooleanincludes(FieldReferencefieldReference){ return fieldReference.isIncludedBy(this);returnfieldReference.isIncludedBy(this); }} @Override@Override public boolean isIncludedBy(SpecificFieldReference specificFieldRef) {publicbooleanisIncludedBy(SpecificFieldReferencespecificFieldRef){ return specificFieldRef.fieldName.equals(fieldName);returnspecificFieldRef.fieldName.equals(fieldName); }} @Override@Override public boolean isIncludedBy(Any anyFieldRef) {publicbooleanisIncludedBy(AnyanyFieldRef){ return !anyFieldRef.excludedFieldNames.contains(fieldName);return!anyFieldRef.excludedFieldNames.contains(fieldName); }}  public Optional<SpecificFieldReference> merge(Any fieldReference) {publicOptional<SpecificFieldReference>merge(AnyfieldReference){ if(fieldReference.excludedFieldNames.contains(fieldName))if(fieldReference.excludedFieldNames.contains(fieldName)) return Optional.absent();returnOptional.absent(); else else return Optional.of(this);returnOptional.of(this); }}  @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * resultresult=prime*result + ((fieldName == null) ? 0 : fieldName.hashCode());+((fieldName==null)?0:fieldName.hashCode()); return result;returnresult; }} @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (getClass() != obj.getClass())if(getClass()!=obj.getClass()) return false;returnfalse; SpecificFieldReference other = (SpecificFieldReference) obj;SpecificFieldReferenceother=(SpecificFieldReference)obj; if (fieldName == null) {if(fieldName==null){ if (other.fieldName != null)if(other.fieldName!=null) return false;returnfalse; } else if (!fieldName.equals(other.fieldName))}elseif(!fieldName.equals(other.fieldName)) return false;returnfalse; return true;returntrue; }} }}}}








src/heros/alias/FieldSensitiveFact.java








View file @ 1cd34e9e






......@@ -12,12 +12,12 @@ package heros.alias;




















import heros.solver.LinkedNode;





















public interface FieldSensitiveFact<BaseValue, D> extends LinkedNode<FieldSensitiveFact<BaseValue, D>>{










public interface FieldSensitiveFact<BaseValue, FieldRef, D> extends LinkedNode<D>{





















 BaseValue getBaseValue();










 










 FieldReference[] getAccessPath();










 AccessPath<FieldRef> getAccessPath();










 










 D cloneWithAccessPath(FieldReference... accessPath);










 D cloneWithAccessPath(AccessPath<FieldRef> accessPath);










 










}












src/heros/alias/FieldSensitiveFact.java








View file @ 1cd34e9e








src/heros/alias/FieldSensitiveFact.java










View file @ 1cd34e9e


1cd34e9e



......@@ -12,12 +12,12 @@ package heros.alias;




















import heros.solver.LinkedNode;





















public interface FieldSensitiveFact<BaseValue, D> extends LinkedNode<FieldSensitiveFact<BaseValue, D>>{










public interface FieldSensitiveFact<BaseValue, FieldRef, D> extends LinkedNode<D>{





















 BaseValue getBaseValue();










 










 FieldReference[] getAccessPath();










 AccessPath<FieldRef> getAccessPath();










 










 D cloneWithAccessPath(FieldReference... accessPath);










 D cloneWithAccessPath(AccessPath<FieldRef> accessPath);










 










}






......@@ -12,12 +12,12 @@ package heros.alias;




















import heros.solver.LinkedNode;





















public interface FieldSensitiveFact<BaseValue, D> extends LinkedNode<FieldSensitiveFact<BaseValue, D>>{










public interface FieldSensitiveFact<BaseValue, FieldRef, D> extends LinkedNode<D>{





















 BaseValue getBaseValue();










 










 FieldReference[] getAccessPath();










 AccessPath<FieldRef> getAccessPath();










 










 D cloneWithAccessPath(FieldReference... accessPath);










 D cloneWithAccessPath(AccessPath<FieldRef> accessPath);










 










}


import heros.solver.LinkedNode;importheros.solver.LinkedNode;public interface FieldSensitiveFact<BaseValue, D> extends LinkedNode<FieldSensitiveFact<BaseValue, D>>{publicinterfaceFieldSensitiveFact<BaseValue,D>extendsLinkedNode<FieldSensitiveFactFieldSensitiveFact<<BaseValueBaseValue,, DD>>{>public interface FieldSensitiveFact<BaseValue, FieldRef, D> extends LinkedNode<D>{publicinterfaceFieldSensitiveFact<BaseValue,FieldRefFieldRef,, D>extendsLinkedNode<DD>{ BaseValue getBaseValue();BaseValuegetBaseValue();  FieldReference[] getAccessPath();FieldReferenceFieldReference[][]getAccessPath(); AccessPath<FieldRef> getAccessPath();AccessPathAccessPath<<FieldRefFieldRef>>getAccessPath();  D cloneWithAccessPath(FieldReference... accessPath);DcloneWithAccessPath(FieldReferenceFieldReference......accessPath); D cloneWithAccessPath(AccessPath<FieldRef> accessPath);DcloneWithAccessPath(AccessPathAccessPath<<FieldRefFieldRef>>accessPath); }}








src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 1cd34e9e






......@@ -10,14 +10,12 @@









 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPathUtil.cloneWithConcatenatedAccessPath;










import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.FlowFunction.Constraint;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.IFDSSolver;










import heros.solver.PathEdge;



......@@ -38,7 +36,7 @@ import com.google.common.base.Predicate;









import com.google.common.cache.CacheBuilder;










import com.google.common.collect.Sets;





















public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact<BaseValue, D>, M, I extends InterproceduralCFG<N, M>> {










public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {
































 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel



......@@ -75,7 +73,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 protected final MyConcurrentHashMap<M, Set<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, Set<PathEdge<N,D>>>();










 










 @DontSynchronize("stateless")










 protected final FlowFunctions<N, D, M> flowFunctions;










 protected final FlowFunctions<N, FieldRef, D, M> flowFunctions;










 










 @DontSynchronize("only used by single thread")










 protected final Map<N,Set<D>> initialSeeds;



......@@ -97,7 +95,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * Creates a solver for the given problem, which caches flow functions and edge functions.










	 * The solver must then be started by calling {@link #solve()}.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,D,M,I> tabulationProblem) {










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef, D,M,I> tabulationProblem) {










 this(tabulationProblem, DEFAULT_CACHE_BUILDER);










 }














......@@ -107,14 +105,14 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.










	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {










 if(logger.isDebugEnabled())










 flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();










 this.zeroValue = tabulationProblem.zeroValue();










 this.icfg = tabulationProblem.interproceduralCFG(); 










 /*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?










				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/ 










 FlowFunctions<N, D, M> flowFunctions = tabulationProblem.flowFunctions(); 










 FlowFunctions<N, FieldRef, D, M> flowFunctions = tabulationProblem.flowFunctions(); 










 /*if(flowFunctionCacheBuilder!=null) {










			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);










			flowFunctions = ffCache;



......@@ -222,16 +220,16 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 Collection<M> callees = icfg.getCalleesOfCallAt(n);










 for(M sCalledProcN: callees) { //still line 14










 //compute the call-flow function










 FlowFunction<D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 Set<AnnotatedFact<D>> res = computeCallFlowFunction(function, d1, d2);










 FlowFunction<FieldRef, D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 Set<AnnotatedFact<FieldRef, D>> res = computeCallFlowFunction(function, d1, d2);










 










 Collection<N> startPointsOf = icfg.getStartPointsOf(sCalledProcN);










 //for each result node of the call-flow function










 for(AnnotatedFact<D> d3: res) {










 for(AnnotatedFact<FieldRef, D> d3: res) {










 //for each callee's start point(s)










 for(N sP: startPointsOf) {










 //create initial self-loop










 D abstractStartPointFact = d3.getFact().cloneWithAccessPath();










 D abstractStartPointFact = d3.getFact().cloneWithAccessPath(new AccessPath<FieldRef>());










 propagate(abstractStartPointFact, sP, abstractStartPointFact, n, false); //line 15










 }










 



......@@ -260,9 +258,9 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, d4.get(), n)) {










 for(AnnotatedFact<FieldRef, D> d5: computeReturnFlowFunction(retFunction, d4.get(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 }



......@@ -275,8 +273,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //line 17-19 of Naeem/Lhotak/Rodriguez		










 //process intra-procedural flows along call-to-return flow functions










 for (N returnSiteN : returnSiteNs) {










 FlowFunction<D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 for(AnnotatedFact<D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))










 FlowFunction<FieldRef, D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 for(AnnotatedFact<FieldRef, D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))










 propagate(d1, returnSiteN, d3.getFact(), n, false);










 }










 }



......@@ -299,20 +297,22 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 for(final PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource())) {










 logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);










 










 FieldReference[] accessPathDelta = AccessPathUtil.getAccessPathDelta(










 incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());










 










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), accessPathDelta)) {










 propagate(zeroValue.equals(incomingEdge.getCallerSourceFact()) ? zeroValue : AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta), null, false);










 } else {










 pauseEdge(AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta));










 }










 final FieldRef[] delta = incomingEdge.getCalleeSourceFact().getAccessPath().getDeltaTo(edge.factAtSource().getAccessPath()); 










 Constraint<FieldRef> constraint = new Constraint<FieldRef>() {










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(delta).mergeExcludedFieldReferences(edge.factAtSource().getAccessPath());










 }










 };










 










 propagateConstrained(constraint, new PathEdge<N,D>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact()), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact())));










 }










 }










 }



......@@ -325,8 +325,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the callee's start node










	 */










 protected Set<AnnotatedFact<D>> computeCallFlowFunction










 (FlowFunction<D> callFlowFunction, D d1, D d2) {










 protected Set<AnnotatedFact<FieldRef, D>> computeCallFlowFunction










 (FlowFunction<FieldRef, D> callFlowFunction, D d1, D d2) {










 return callFlowFunction.computeTargets(d2);










 }














......@@ -339,8 +339,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<AnnotatedFact<D>> computeCallToReturnFlowFunction










 (FlowFunction<D> callToReturnFlowFunction, D d1, D d2) {










 protected Set<AnnotatedFact<FieldRef, D>> computeCallToReturnFlowFunction










 (FlowFunction<FieldRef, D> callToReturnFlowFunction, D d1, D d2) {










 return callToReturnFlowFunction.computeTargets(d2);










 }










 



......@@ -376,15 +376,15 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact())) {










 Optional<D> concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 if(concreteCalleeExitFact.isPresent()) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact.get(), callSite);










 Set<AnnotatedFact<FieldRef, D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact.get(), callSite);










 










 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 for (AnnotatedFact<FieldRef, D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }



......@@ -401,9 +401,9 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);










 for(N c: callers) {










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 Set<AnnotatedFact<D>> targets = computeReturnFlowFunction(retFunction, d2, c);










 for(AnnotatedFact<D> d5: targets)










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 Set<AnnotatedFact<FieldRef, D>> targets = computeReturnFlowFunction(retFunction, d2, c);










 for(AnnotatedFact<FieldRef, D> d5: targets)










 propagate(zeroValue, retSiteC, d5.getFact(), c, true);










 }










 }



......@@ -411,7 +411,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //this might be undesirable if the flow function has a side effect such as registering a taint;










 //instead we thus call the return flow function will a null caller










 if(callers.isEmpty()) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);










 retFunction.computeTargets(d2);










 }










 }



......@@ -425,8 +425,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param callSite The call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<AnnotatedFact<D>> computeReturnFlowFunction










 (FlowFunction<D> retFunction, D d2, N callSite) {










 protected Set<AnnotatedFact<FieldRef, D>> computeReturnFlowFunction










 (FlowFunction<FieldRef, D> retFunction, D d2, N callSite) {










 return retFunction.computeTargets(d2);










 }














......@@ -441,44 +441,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 final D d2 = edge.factAtTarget();










 










 for (N m : icfg.getSuccsOf(n)) {










 FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<AnnotatedFact<D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (AnnotatedFact<D> d3 : res) {










 //TODO: double check if concurrency issues may arise










 










 //if reading field f










 // if d1.f element of incoming edges:










 //    create and propagate (d1.f, d2.f)










 // else 










 //	  create and set (d1.f, d2.f) on hold










 //	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold










 










 if(d3.getReadField() != null) {










 SpecificFieldReference fieldRef = new SpecificFieldReference(d3.getReadField());










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(concretizedSourceValue, m, d3.getFact(), null, false);










 } else {










 pauseEdge(concretizedSourceValue, m, d3.getFact());










 }










 }










 else if(d3.getWrittenField() != null) {










 //TODO: double check if concurrency issues may arise










 










 // if writing field f










 // create edge e = (d1, d2.*\{f})










 // if d2.*\{f} element of incoming edges










 // 		continue with e










 // else 










 //		put e on hold










 // always kill (d1, d2)










 










 Any fieldRef = new Any(d3.getWrittenField());










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(d1, m, d3.getFact(), null, false);










 } else {










 pauseEdge(d1, m, d3.getFact());










 }










 FlowFunction<FieldRef, D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<AnnotatedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (AnnotatedFact<FieldRef, D> d3 : res) {










 if(d3.getConstraint() != null) {










 propagateConstrained(d3.getConstraint(), new PathEdge<>(applyConstraint(d3.getConstraint(), d1), m, d3.getFact()));










 }










 else










 propagate(d1, m, d3.getFact(), null, false);



......@@ -486,44 +453,54 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 }










 }










 










 private void pauseEdge(D sourceValue, N targetStmt, D targetValue) {










 M method = icfg.getMethodOf(targetStmt);










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 if(edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue))) {










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 }










 private D applyConstraint(Constraint<FieldRef> constraint, D fact) {










 if(fact.equals(zeroValue))










 return zeroValue;










 else










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath()));










 }










 










 private boolean propagateConstrained(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge) {










 M calleeMethod = icfg.getMethodOf(pathEdge.getTarget());










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, pathEdge.factAtSource(), constraint);





















 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, FieldReference... fieldRef) {










 M calleeMethod = icfg.getMethodOf(targetStmt);










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, calleeSourceFact, fieldRef);










 










 if(calleeSourceFact.equals(zeroValue))










 return true;










 










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 if(!incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue).isEmpty()) {










 return true;










 }










 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, concretizedSourceValue); 










 for (IncomingEdge<D, N> incomingEdge : inc) {










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), fieldRef)) {










 propagate(incomingEdge.getCallerSourceFact().equals(zeroValue) ? 










 incomingEdge.getCallerSourceFact() : 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef), null, false); 










 return true;










 boolean propagate = false;










 if(pathEdge.factAtSource().equals(zeroValue))










 propagate = true;










 else {










 Set<N> callSitesWithInterest = Sets.newHashSet();










 for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixedWith(calleeMethod, pathEdge.factAtSource())) {










 callSitesWithInterest.add(incEdge.getCallSite());










 }










 else {










 pauseEdge(cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef));










 propagate = !callSitesWithInterest.isEmpty();










 










 for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixesOf(calleeMethod, pathEdge.factAtSource())) {










 boolean equal = incEdge.getCalleeSourceFact().equals(pathEdge.factAtSource()); //TODO: write test case for this










 if(!equal && !callSitesWithInterest.contains(incEdge.getCallSite())) {










 PathEdge<N,D> callerEdge = new PathEdge<>(










 applyConstraint(constraint, incEdge.getCallerSourceFact()), 










 incEdge.getCallSite(), 










 applyConstraint(constraint, incEdge.getCallerCallSiteFact()));










 propagate |= propagateConstrained(constraint, callerEdge);










 }










 }










 }










 










 return false;










 if(propagate) {










 propagate(pathEdge.factAtSource(), pathEdge.getTarget(), pathEdge.factAtTarget(), null, false);










 return true;










 } else {










 pauseEdge(pathEdge);










 return false;










 }










 }










 










 private void pauseEdge(PathEdge<N,D> edge) {










 M method = icfg.getMethodOf(edge.getTarget());










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 if(edges.add(edge)) {










 logger.trace("PAUSED: {}: {}", method, edge);










 }










 }










 










 /**



......@@ -534,8 +511,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param d1 The abstraction at the current node










	 * @return The set of abstractions at the successor node










	 */










 protected Set<AnnotatedFact<D>> computeNormalFlowFunction










 (FlowFunction<D> flowFunction, D d1, D d2) {










 protected Set<AnnotatedFact<FieldRef, D>> computeNormalFlowFunction










 (FlowFunction<FieldRef, D> flowFunction, D d1, D d2) {










 return flowFunction.computeTargets(d2);










 }










 



......












src/heros/alias/FieldSensitiveIFDSSolver.java








View file @ 1cd34e9e








src/heros/alias/FieldSensitiveIFDSSolver.java










View file @ 1cd34e9e


1cd34e9e



......@@ -10,14 +10,12 @@









 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPathUtil.cloneWithConcatenatedAccessPath;










import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.FlowFunction.Constraint;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.IFDSSolver;










import heros.solver.PathEdge;



......@@ -38,7 +36,7 @@ import com.google.common.base.Predicate;









import com.google.common.cache.CacheBuilder;










import com.google.common.collect.Sets;





















public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact<BaseValue, D>, M, I extends InterproceduralCFG<N, M>> {










public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {
































 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel



......@@ -75,7 +73,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 protected final MyConcurrentHashMap<M, Set<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, Set<PathEdge<N,D>>>();










 










 @DontSynchronize("stateless")










 protected final FlowFunctions<N, D, M> flowFunctions;










 protected final FlowFunctions<N, FieldRef, D, M> flowFunctions;










 










 @DontSynchronize("only used by single thread")










 protected final Map<N,Set<D>> initialSeeds;



......@@ -97,7 +95,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * Creates a solver for the given problem, which caches flow functions and edge functions.










	 * The solver must then be started by calling {@link #solve()}.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,D,M,I> tabulationProblem) {










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef, D,M,I> tabulationProblem) {










 this(tabulationProblem, DEFAULT_CACHE_BUILDER);










 }














......@@ -107,14 +105,14 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.










	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {










 if(logger.isDebugEnabled())










 flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();










 this.zeroValue = tabulationProblem.zeroValue();










 this.icfg = tabulationProblem.interproceduralCFG(); 










 /*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?










				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/ 










 FlowFunctions<N, D, M> flowFunctions = tabulationProblem.flowFunctions(); 










 FlowFunctions<N, FieldRef, D, M> flowFunctions = tabulationProblem.flowFunctions(); 










 /*if(flowFunctionCacheBuilder!=null) {










			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);










			flowFunctions = ffCache;



......@@ -222,16 +220,16 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 Collection<M> callees = icfg.getCalleesOfCallAt(n);










 for(M sCalledProcN: callees) { //still line 14










 //compute the call-flow function










 FlowFunction<D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 Set<AnnotatedFact<D>> res = computeCallFlowFunction(function, d1, d2);










 FlowFunction<FieldRef, D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 Set<AnnotatedFact<FieldRef, D>> res = computeCallFlowFunction(function, d1, d2);










 










 Collection<N> startPointsOf = icfg.getStartPointsOf(sCalledProcN);










 //for each result node of the call-flow function










 for(AnnotatedFact<D> d3: res) {










 for(AnnotatedFact<FieldRef, D> d3: res) {










 //for each callee's start point(s)










 for(N sP: startPointsOf) {










 //create initial self-loop










 D abstractStartPointFact = d3.getFact().cloneWithAccessPath();










 D abstractStartPointFact = d3.getFact().cloneWithAccessPath(new AccessPath<FieldRef>());










 propagate(abstractStartPointFact, sP, abstractStartPointFact, n, false); //line 15










 }










 



......@@ -260,9 +258,9 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, d4.get(), n)) {










 for(AnnotatedFact<FieldRef, D> d5: computeReturnFlowFunction(retFunction, d4.get(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 }



......@@ -275,8 +273,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //line 17-19 of Naeem/Lhotak/Rodriguez		










 //process intra-procedural flows along call-to-return flow functions










 for (N returnSiteN : returnSiteNs) {










 FlowFunction<D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 for(AnnotatedFact<D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))










 FlowFunction<FieldRef, D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 for(AnnotatedFact<FieldRef, D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))










 propagate(d1, returnSiteN, d3.getFact(), n, false);










 }










 }



......@@ -299,20 +297,22 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 for(final PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource())) {










 logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);










 










 FieldReference[] accessPathDelta = AccessPathUtil.getAccessPathDelta(










 incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());










 










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), accessPathDelta)) {










 propagate(zeroValue.equals(incomingEdge.getCallerSourceFact()) ? zeroValue : AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta), null, false);










 } else {










 pauseEdge(AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta));










 }










 final FieldRef[] delta = incomingEdge.getCalleeSourceFact().getAccessPath().getDeltaTo(edge.factAtSource().getAccessPath()); 










 Constraint<FieldRef> constraint = new Constraint<FieldRef>() {










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(delta).mergeExcludedFieldReferences(edge.factAtSource().getAccessPath());










 }










 };










 










 propagateConstrained(constraint, new PathEdge<N,D>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact()), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact())));










 }










 }










 }



......@@ -325,8 +325,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the callee's start node










	 */










 protected Set<AnnotatedFact<D>> computeCallFlowFunction










 (FlowFunction<D> callFlowFunction, D d1, D d2) {










 protected Set<AnnotatedFact<FieldRef, D>> computeCallFlowFunction










 (FlowFunction<FieldRef, D> callFlowFunction, D d1, D d2) {










 return callFlowFunction.computeTargets(d2);










 }














......@@ -339,8 +339,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<AnnotatedFact<D>> computeCallToReturnFlowFunction










 (FlowFunction<D> callToReturnFlowFunction, D d1, D d2) {










 protected Set<AnnotatedFact<FieldRef, D>> computeCallToReturnFlowFunction










 (FlowFunction<FieldRef, D> callToReturnFlowFunction, D d1, D d2) {










 return callToReturnFlowFunction.computeTargets(d2);










 }










 



......@@ -376,15 +376,15 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact())) {










 Optional<D> concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 if(concreteCalleeExitFact.isPresent()) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact.get(), callSite);










 Set<AnnotatedFact<FieldRef, D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact.get(), callSite);










 










 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 for (AnnotatedFact<FieldRef, D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }



......@@ -401,9 +401,9 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);










 for(N c: callers) {










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 Set<AnnotatedFact<D>> targets = computeReturnFlowFunction(retFunction, d2, c);










 for(AnnotatedFact<D> d5: targets)










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 Set<AnnotatedFact<FieldRef, D>> targets = computeReturnFlowFunction(retFunction, d2, c);










 for(AnnotatedFact<FieldRef, D> d5: targets)










 propagate(zeroValue, retSiteC, d5.getFact(), c, true);










 }










 }



......@@ -411,7 +411,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //this might be undesirable if the flow function has a side effect such as registering a taint;










 //instead we thus call the return flow function will a null caller










 if(callers.isEmpty()) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);










 retFunction.computeTargets(d2);










 }










 }



......@@ -425,8 +425,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param callSite The call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<AnnotatedFact<D>> computeReturnFlowFunction










 (FlowFunction<D> retFunction, D d2, N callSite) {










 protected Set<AnnotatedFact<FieldRef, D>> computeReturnFlowFunction










 (FlowFunction<FieldRef, D> retFunction, D d2, N callSite) {










 return retFunction.computeTargets(d2);










 }














......@@ -441,44 +441,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 final D d2 = edge.factAtTarget();










 










 for (N m : icfg.getSuccsOf(n)) {










 FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<AnnotatedFact<D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (AnnotatedFact<D> d3 : res) {










 //TODO: double check if concurrency issues may arise










 










 //if reading field f










 // if d1.f element of incoming edges:










 //    create and propagate (d1.f, d2.f)










 // else 










 //	  create and set (d1.f, d2.f) on hold










 //	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold










 










 if(d3.getReadField() != null) {










 SpecificFieldReference fieldRef = new SpecificFieldReference(d3.getReadField());










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(concretizedSourceValue, m, d3.getFact(), null, false);










 } else {










 pauseEdge(concretizedSourceValue, m, d3.getFact());










 }










 }










 else if(d3.getWrittenField() != null) {










 //TODO: double check if concurrency issues may arise










 










 // if writing field f










 // create edge e = (d1, d2.*\{f})










 // if d2.*\{f} element of incoming edges










 // 		continue with e










 // else 










 //		put e on hold










 // always kill (d1, d2)










 










 Any fieldRef = new Any(d3.getWrittenField());










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(d1, m, d3.getFact(), null, false);










 } else {










 pauseEdge(d1, m, d3.getFact());










 }










 FlowFunction<FieldRef, D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<AnnotatedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (AnnotatedFact<FieldRef, D> d3 : res) {










 if(d3.getConstraint() != null) {










 propagateConstrained(d3.getConstraint(), new PathEdge<>(applyConstraint(d3.getConstraint(), d1), m, d3.getFact()));










 }










 else










 propagate(d1, m, d3.getFact(), null, false);



......@@ -486,44 +453,54 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 }










 }










 










 private void pauseEdge(D sourceValue, N targetStmt, D targetValue) {










 M method = icfg.getMethodOf(targetStmt);










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 if(edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue))) {










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 }










 private D applyConstraint(Constraint<FieldRef> constraint, D fact) {










 if(fact.equals(zeroValue))










 return zeroValue;










 else










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath()));










 }










 










 private boolean propagateConstrained(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge) {










 M calleeMethod = icfg.getMethodOf(pathEdge.getTarget());










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, pathEdge.factAtSource(), constraint);





















 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, FieldReference... fieldRef) {










 M calleeMethod = icfg.getMethodOf(targetStmt);










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, calleeSourceFact, fieldRef);










 










 if(calleeSourceFact.equals(zeroValue))










 return true;










 










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 if(!incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue).isEmpty()) {










 return true;










 }










 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, concretizedSourceValue); 










 for (IncomingEdge<D, N> incomingEdge : inc) {










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), fieldRef)) {










 propagate(incomingEdge.getCallerSourceFact().equals(zeroValue) ? 










 incomingEdge.getCallerSourceFact() : 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef), null, false); 










 return true;










 boolean propagate = false;










 if(pathEdge.factAtSource().equals(zeroValue))










 propagate = true;










 else {










 Set<N> callSitesWithInterest = Sets.newHashSet();










 for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixedWith(calleeMethod, pathEdge.factAtSource())) {










 callSitesWithInterest.add(incEdge.getCallSite());










 }










 else {










 pauseEdge(cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef));










 propagate = !callSitesWithInterest.isEmpty();










 










 for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixesOf(calleeMethod, pathEdge.factAtSource())) {










 boolean equal = incEdge.getCalleeSourceFact().equals(pathEdge.factAtSource()); //TODO: write test case for this










 if(!equal && !callSitesWithInterest.contains(incEdge.getCallSite())) {










 PathEdge<N,D> callerEdge = new PathEdge<>(










 applyConstraint(constraint, incEdge.getCallerSourceFact()), 










 incEdge.getCallSite(), 










 applyConstraint(constraint, incEdge.getCallerCallSiteFact()));










 propagate |= propagateConstrained(constraint, callerEdge);










 }










 }










 }










 










 return false;










 if(propagate) {










 propagate(pathEdge.factAtSource(), pathEdge.getTarget(), pathEdge.factAtTarget(), null, false);










 return true;










 } else {










 pauseEdge(pathEdge);










 return false;










 }










 }










 










 private void pauseEdge(PathEdge<N,D> edge) {










 M method = icfg.getMethodOf(edge.getTarget());










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 if(edges.add(edge)) {










 logger.trace("PAUSED: {}: {}", method, edge);










 }










 }










 










 /**



......@@ -534,8 +511,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param d1 The abstraction at the current node










	 * @return The set of abstractions at the successor node










	 */










 protected Set<AnnotatedFact<D>> computeNormalFlowFunction










 (FlowFunction<D> flowFunction, D d1, D d2) {










 protected Set<AnnotatedFact<FieldRef, D>> computeNormalFlowFunction










 (FlowFunction<FieldRef, D> flowFunction, D d1, D d2) {










 return flowFunction.computeTargets(d2);










 }










 



......






......@@ -10,14 +10,12 @@









 ******************************************************************************/










package heros.alias;





















import static heros.alias.AccessPathUtil.cloneWithConcatenatedAccessPath;










import heros.DontSynchronize;










import heros.FlowFunctionCache;










import heros.InterproceduralCFG;










import heros.SynchronizedBy;










import heros.alias.FieldReference.Any;










import heros.alias.FieldReference.SpecificFieldReference;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.FlowFunction.Constraint;










import heros.solver.CountingThreadPoolExecutor;










import heros.solver.IFDSSolver;










import heros.solver.PathEdge;



......@@ -38,7 +36,7 @@ import com.google.common.base.Predicate;









import com.google.common.cache.CacheBuilder;










import com.google.common.collect.Sets;





















public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact<BaseValue, D>, M, I extends InterproceduralCFG<N, M>> {










public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {
































 public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevel



......@@ -75,7 +73,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 protected final MyConcurrentHashMap<M, Set<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, Set<PathEdge<N,D>>>();










 










 @DontSynchronize("stateless")










 protected final FlowFunctions<N, D, M> flowFunctions;










 protected final FlowFunctions<N, FieldRef, D, M> flowFunctions;










 










 @DontSynchronize("only used by single thread")










 protected final Map<N,Set<D>> initialSeeds;



......@@ -97,7 +95,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * Creates a solver for the given problem, which caches flow functions and edge functions.










	 * The solver must then be started by calling {@link #solve()}.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,D,M,I> tabulationProblem) {










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef, D,M,I> tabulationProblem) {










 this(tabulationProblem, DEFAULT_CACHE_BUILDER);










 }














......@@ -107,14 +105,14 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.










	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.










	 */










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {










 public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {










 if(logger.isDebugEnabled())










 flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();










 this.zeroValue = tabulationProblem.zeroValue();










 this.icfg = tabulationProblem.interproceduralCFG(); 










 /*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?










				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/ 










 FlowFunctions<N, D, M> flowFunctions = tabulationProblem.flowFunctions(); 










 FlowFunctions<N, FieldRef, D, M> flowFunctions = tabulationProblem.flowFunctions(); 










 /*if(flowFunctionCacheBuilder!=null) {










			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);










			flowFunctions = ffCache;



......@@ -222,16 +220,16 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 Collection<M> callees = icfg.getCalleesOfCallAt(n);










 for(M sCalledProcN: callees) { //still line 14










 //compute the call-flow function










 FlowFunction<D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 Set<AnnotatedFact<D>> res = computeCallFlowFunction(function, d1, d2);










 FlowFunction<FieldRef, D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);










 Set<AnnotatedFact<FieldRef, D>> res = computeCallFlowFunction(function, d1, d2);










 










 Collection<N> startPointsOf = icfg.getStartPointsOf(sCalledProcN);










 //for each result node of the call-flow function










 for(AnnotatedFact<D> d3: res) {










 for(AnnotatedFact<FieldRef, D> d3: res) {










 //for each callee's start point(s)










 for(N sP: startPointsOf) {










 //create initial self-loop










 D abstractStartPointFact = d3.getFact().cloneWithAccessPath();










 D abstractStartPointFact = d3.getFact().cloneWithAccessPath(new AccessPath<FieldRef>());










 propagate(abstractStartPointFact, sP, abstractStartPointFact, n, false); //line 15










 }










 



......@@ -260,9 +258,9 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //for each return site










 for(N retSiteN: returnSiteNs) {










 //compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);










 //for each target value of the function










 for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, d4.get(), n)) {










 for(AnnotatedFact<FieldRef, D> d5: computeReturnFlowFunction(retFunction, d4.get(), n)) {










 D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());










 propagate(d1, retSiteN, d5p_restoredCtx, n, false);










 }



......@@ -275,8 +273,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //line 17-19 of Naeem/Lhotak/Rodriguez		










 //process intra-procedural flows along call-to-return flow functions










 for (N returnSiteN : returnSiteNs) {










 FlowFunction<D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 for(AnnotatedFact<D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))










 FlowFunction<FieldRef, D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);










 for(AnnotatedFact<FieldRef, D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))










 propagate(d1, returnSiteN, d3.getFact(), n, false);










 }










 }



......@@ -299,20 +297,22 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {










 Set<PathEdge<N, D>> edges = pausedEdges.get(method);










 if(edges != null) {










 for(PathEdge<N, D> edge : edges) {










 for(final PathEdge<N, D> edge : edges) {










 if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource())) {










 logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);










 










 FieldReference[] accessPathDelta = AccessPathUtil.getAccessPathDelta(










 incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());










 










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), accessPathDelta)) {










 propagate(zeroValue.equals(incomingEdge.getCallerSourceFact()) ? zeroValue : AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta), null, false);










 } else {










 pauseEdge(AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), 










 incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta));










 }










 final FieldRef[] delta = incomingEdge.getCalleeSourceFact().getAccessPath().getDeltaTo(edge.factAtSource().getAccessPath()); 










 Constraint<FieldRef> constraint = new Constraint<FieldRef>() {










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(delta).mergeExcludedFieldReferences(edge.factAtSource().getAccessPath());










 }










 };










 










 propagateConstrained(constraint, new PathEdge<N,D>(










 applyConstraint(constraint, incomingEdge.getCallerSourceFact()), 










 incomingEdge.getCallSite(), 










 applyConstraint(constraint, incomingEdge.getCallerCallSiteFact())));










 }










 }










 }



......@@ -325,8 +325,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the callee's start node










	 */










 protected Set<AnnotatedFact<D>> computeCallFlowFunction










 (FlowFunction<D> callFlowFunction, D d1, D d2) {










 protected Set<AnnotatedFact<FieldRef, D>> computeCallFlowFunction










 (FlowFunction<FieldRef, D> callFlowFunction, D d1, D d2) {










 return callFlowFunction.computeTargets(d2);










 }














......@@ -339,8 +339,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param d2 The abstraction at the call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<AnnotatedFact<D>> computeCallToReturnFlowFunction










 (FlowFunction<D> callToReturnFlowFunction, D d1, D d2) {










 protected Set<AnnotatedFact<FieldRef, D>> computeCallToReturnFlowFunction










 (FlowFunction<FieldRef, D> callToReturnFlowFunction, D d1, D d2) {










 return callToReturnFlowFunction.computeTargets(d2);










 }










 



......@@ -376,15 +376,15 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 // for each return site










 for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {










 // compute return-flow function










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);










 










 if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact())) {










 Optional<D> concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);










 if(concreteCalleeExitFact.isPresent()) {










 Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact.get(), callSite);










 Set<AnnotatedFact<FieldRef, D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact.get(), callSite);










 










 // for each incoming-call value










 for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {










 for (AnnotatedFact<FieldRef, D> callerTargetAnnotatedFact : callerTargetFacts) {










 D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());










 propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);










 }



......@@ -401,9 +401,9 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);










 for(N c: callers) {










 for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 Set<AnnotatedFact<D>> targets = computeReturnFlowFunction(retFunction, d2, c);










 for(AnnotatedFact<D> d5: targets)










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);










 Set<AnnotatedFact<FieldRef, D>> targets = computeReturnFlowFunction(retFunction, d2, c);










 for(AnnotatedFact<FieldRef, D> d5: targets)










 propagate(zeroValue, retSiteC, d5.getFact(), c, true);










 }










 }



......@@ -411,7 +411,7 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 //this might be undesirable if the flow function has a side effect such as registering a taint;










 //instead we thus call the return flow function will a null caller










 if(callers.isEmpty()) {










 FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);










 FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);










 retFunction.computeTargets(d2);










 }










 }



......@@ -425,8 +425,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param callSite The call site










	 * @return The set of caller-side abstractions at the return site










	 */










 protected Set<AnnotatedFact<D>> computeReturnFlowFunction










 (FlowFunction<D> retFunction, D d2, N callSite) {










 protected Set<AnnotatedFact<FieldRef, D>> computeReturnFlowFunction










 (FlowFunction<FieldRef, D> retFunction, D d2, N callSite) {










 return retFunction.computeTargets(d2);










 }














......@@ -441,44 +441,11 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 final D d2 = edge.factAtTarget();










 










 for (N m : icfg.getSuccsOf(n)) {










 FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<AnnotatedFact<D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (AnnotatedFact<D> d3 : res) {










 //TODO: double check if concurrency issues may arise










 










 //if reading field f










 // if d1.f element of incoming edges:










 //    create and propagate (d1.f, d2.f)










 // else 










 //	  create and set (d1.f, d2.f) on hold










 //	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold










 










 if(d3.getReadField() != null) {










 SpecificFieldReference fieldRef = new SpecificFieldReference(d3.getReadField());










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(concretizedSourceValue, m, d3.getFact(), null, false);










 } else {










 pauseEdge(concretizedSourceValue, m, d3.getFact());










 }










 }










 else if(d3.getWrittenField() != null) {










 //TODO: double check if concurrency issues may arise










 










 // if writing field f










 // create edge e = (d1, d2.*\{f})










 // if d2.*\{f} element of incoming edges










 // 		continue with e










 // else 










 //		put e on hold










 // always kill (d1, d2)










 










 Any fieldRef = new Any(d3.getWrittenField());










 if(checkForInterestedCallers(d1, n, fieldRef)) {










 propagate(d1, m, d3.getFact(), null, false);










 } else {










 pauseEdge(d1, m, d3.getFact());










 }










 FlowFunction<FieldRef, D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);










 Set<AnnotatedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);










 for (AnnotatedFact<FieldRef, D> d3 : res) {










 if(d3.getConstraint() != null) {










 propagateConstrained(d3.getConstraint(), new PathEdge<>(applyConstraint(d3.getConstraint(), d1), m, d3.getFact()));










 }










 else










 propagate(d1, m, d3.getFact(), null, false);



......@@ -486,44 +453,54 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









 }










 }










 










 private void pauseEdge(D sourceValue, N targetStmt, D targetValue) {










 M method = icfg.getMethodOf(targetStmt);










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 if(edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue))) {










 logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);










 }










 private D applyConstraint(Constraint<FieldRef> constraint, D fact) {










 if(fact.equals(zeroValue))










 return zeroValue;










 else










 return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath()));










 }










 










 private boolean propagateConstrained(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge) {










 M calleeMethod = icfg.getMethodOf(pathEdge.getTarget());










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, pathEdge.factAtSource(), constraint);





















 private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, FieldReference... fieldRef) {










 M calleeMethod = icfg.getMethodOf(targetStmt);










 logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, calleeSourceFact, fieldRef);










 










 if(calleeSourceFact.equals(zeroValue))










 return true;










 










 D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);










 if(!incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue).isEmpty()) {










 return true;










 }










 










 Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, concretizedSourceValue); 










 for (IncomingEdge<D, N> incomingEdge : inc) {










 if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), fieldRef)) {










 propagate(incomingEdge.getCallerSourceFact().equals(zeroValue) ? 










 incomingEdge.getCallerSourceFact() : 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef), null, false); 










 return true;










 boolean propagate = false;










 if(pathEdge.factAtSource().equals(zeroValue))










 propagate = true;










 else {










 Set<N> callSitesWithInterest = Sets.newHashSet();










 for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixedWith(calleeMethod, pathEdge.factAtSource())) {










 callSitesWithInterest.add(incEdge.getCallSite());










 }










 else {










 pauseEdge(cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), 










 incomingEdge.getCallSite(), 










 cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef));










 propagate = !callSitesWithInterest.isEmpty();










 










 for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixesOf(calleeMethod, pathEdge.factAtSource())) {










 boolean equal = incEdge.getCalleeSourceFact().equals(pathEdge.factAtSource()); //TODO: write test case for this










 if(!equal && !callSitesWithInterest.contains(incEdge.getCallSite())) {










 PathEdge<N,D> callerEdge = new PathEdge<>(










 applyConstraint(constraint, incEdge.getCallerSourceFact()), 










 incEdge.getCallSite(), 










 applyConstraint(constraint, incEdge.getCallerCallSiteFact()));










 propagate |= propagateConstrained(constraint, callerEdge);










 }










 }










 }










 










 return false;










 if(propagate) {










 propagate(pathEdge.factAtSource(), pathEdge.getTarget(), pathEdge.factAtTarget(), null, false);










 return true;










 } else {










 pauseEdge(pathEdge);










 return false;










 }










 }










 










 private void pauseEdge(PathEdge<N,D> edge) {










 M method = icfg.getMethodOf(edge.getTarget());










 Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());










 if(edges.add(edge)) {










 logger.trace("PAUSED: {}: {}", method, edge);










 }










 }










 










 /**



......@@ -534,8 +511,8 @@ public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact









	 * @param d1 The abstraction at the current node










	 * @return The set of abstractions at the successor node










	 */










 protected Set<AnnotatedFact<D>> computeNormalFlowFunction










 (FlowFunction<D> flowFunction, D d1, D d2) {










 protected Set<AnnotatedFact<FieldRef, D>> computeNormalFlowFunction










 (FlowFunction<FieldRef, D> flowFunction, D d1, D d2) {










 return flowFunction.computeTargets(d2);










 }










 



......


 ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import static heros.alias.AccessPathUtil.cloneWithConcatenatedAccessPath;importstaticheros.alias.AccessPathUtil.cloneWithConcatenatedAccessPath;import heros.DontSynchronize;importheros.DontSynchronize;import heros.FlowFunctionCache;importheros.FlowFunctionCache;import heros.InterproceduralCFG;importheros.InterproceduralCFG;import heros.SynchronizedBy;importheros.SynchronizedBy;import heros.alias.FieldReference.Any;importheros.alias.FieldReference.Any;import heros.alias.FieldReference.SpecificFieldReference;importheros.alias.FieldReference.SpecificFieldReference;import heros.alias.FlowFunction.AnnotatedFact;importheros.alias.FlowFunction.AnnotatedFact;import heros.alias.FlowFunction.Constraint;importheros.alias.FlowFunction.Constraint;import heros.solver.CountingThreadPoolExecutor;importheros.solver.CountingThreadPoolExecutor;import heros.solver.IFDSSolver;importheros.solver.IFDSSolver;import heros.solver.PathEdge;importheros.solver.PathEdge;import com.google.common.cache.CacheBuilder;importcom.google.common.cache.CacheBuilder;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;public class FieldSensitiveIFDSSolver<N, BaseValue, D extends FieldSensitiveFact<BaseValue, D>, M, I extends InterproceduralCFG<N, M>> {publicclassFieldSensitiveIFDSSolver<N,BaseValue,DextendsFieldSensitiveFact<BaseValue,D>,M,IextendsInterproceduralCFG<N,M>>{public class FieldSensitiveIFDSSolver<N, BaseValue, FieldRef, D extends FieldSensitiveFact<BaseValue, FieldRef, D>, M, I extends InterproceduralCFG<N, M>> {publicclassFieldSensitiveIFDSSolver<N,BaseValue,FieldRefFieldRef,, DextendsFieldSensitiveFact<BaseValue,FieldRefFieldRef,, D>,M,IextendsInterproceduralCFG<N,M>>{ public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder().concurrencyLevelpublicstaticCacheBuilder<Object,Object>DEFAULT_CACHE_BUILDER=CacheBuilder.newBuilder().concurrencyLevel protected final MyConcurrentHashMap<M, Set<PathEdge<N,D>>> pausedEdges = new MyConcurrentHashMap<M, Set<PathEdge<N,D>>>();protectedfinalMyConcurrentHashMap<M,Set<PathEdge<N,D>>>pausedEdges=newMyConcurrentHashMap<M,Set<PathEdge<N,D>>>();  @DontSynchronize("stateless")@DontSynchronize("stateless") protected final FlowFunctions<N, D, M> flowFunctions;protectedfinalFlowFunctions<N,D,M>flowFunctions; protected final FlowFunctions<N, FieldRef, D, M> flowFunctions;protectedfinalFlowFunctions<N,FieldRefFieldRef,, D,M>flowFunctions;  @DontSynchronize("only used by single thread")@DontSynchronize("only used by single thread") protected final Map<N,Set<D>> initialSeeds;protectedfinalMap<N,Set<D>>initialSeeds;	 * Creates a solver for the given problem, which caches flow functions and edge functions.	 * Creates a solver for the given problem, which caches flow functions and edge functions.	 * The solver must then be started by calling {@link #solve()}.	 * The solver must then be started by calling {@link #solve()}.	 */	 */ public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,D,M,I> tabulationProblem) {publicFieldSensitiveIFDSSolver(IFDSTabulationProblem<N,D,M,I>tabulationProblem){ public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef, D,M,I> tabulationProblem) {publicFieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRefFieldRef,, D,M,I>tabulationProblem){ this(tabulationProblem, DEFAULT_CACHE_BUILDER);this(tabulationProblem,DEFAULT_CACHE_BUILDER); }}	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for flow functions.	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.	 * @param edgeFunctionCacheBuilder A valid {@link CacheBuilder} or <code>null</code> if no caching is to be used for edge functions.	 */	 */ public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {publicFieldSensitiveIFDSSolver(IFDSTabulationProblem<N,D,M,I>tabulationProblem,@SuppressWarnings("rawtypes")CacheBuilderflowFunctionCacheBuilder){ public FieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRef,D,M,I> tabulationProblem, @SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {publicFieldSensitiveIFDSSolver(IFDSTabulationProblem<N,FieldRefFieldRef,,D,M,I>tabulationProblem,@SuppressWarnings("rawtypes")CacheBuilderflowFunctionCacheBuilder){ if(logger.isDebugEnabled())if(logger.isDebugEnabled()) flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();flowFunctionCacheBuilder=flowFunctionCacheBuilder.recordStats(); this.zeroValue = tabulationProblem.zeroValue();this.zeroValue=tabulationProblem.zeroValue(); this.icfg = tabulationProblem.interproceduralCFG(); this.icfg=tabulationProblem.interproceduralCFG(); /*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?/*	FlowFunctions<N, D, M> flowFunctions = tabulationProblem.autoAddZero() ?				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/ 				new ZeroedFlowFunctions<N,D,M>(tabulationProblem.flowFunctions(), zeroValue) : tabulationProblem.flowFunctions();*/ FlowFunctions<N, D, M> flowFunctions = tabulationProblem.flowFunctions(); FlowFunctions<N,D,M>flowFunctions=tabulationProblem.flowFunctions(); FlowFunctions<N, FieldRef, D, M> flowFunctions = tabulationProblem.flowFunctions(); FlowFunctions<N,FieldRefFieldRef,, D,M>flowFunctions=tabulationProblem.flowFunctions(); /*if(flowFunctionCacheBuilder!=null) {/*if(flowFunctionCacheBuilder!=null) {			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);			ffCache = new FlowFunctionCache<N,D,M>(flowFunctions, flowFunctionCacheBuilder);			flowFunctions = ffCache;			flowFunctions = ffCache; Collection<M> callees = icfg.getCalleesOfCallAt(n);Collection<M>callees=icfg.getCalleesOfCallAt(n); for(M sCalledProcN: callees) { //still line 14for(MsCalledProcN:callees){//still line 14 //compute the call-flow function//compute the call-flow function FlowFunction<D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);FlowFunction<D>function=flowFunctions.getCallFlowFunction(n,sCalledProcN); Set<AnnotatedFact<D>> res = computeCallFlowFunction(function, d1, d2);Set<AnnotatedFact<D>>res=computeCallFlowFunction(function,d1,d2); FlowFunction<FieldRef, D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);FlowFunction<FieldRefFieldRef,, D>function=flowFunctions.getCallFlowFunction(n,sCalledProcN); Set<AnnotatedFact<FieldRef, D>> res = computeCallFlowFunction(function, d1, d2);Set<AnnotatedFact<FieldRefFieldRef,, D>>res=computeCallFlowFunction(function,d1,d2);  Collection<N> startPointsOf = icfg.getStartPointsOf(sCalledProcN);Collection<N>startPointsOf=icfg.getStartPointsOf(sCalledProcN); //for each result node of the call-flow function//for each result node of the call-flow function for(AnnotatedFact<D> d3: res) {for(AnnotatedFact<D>d3:res){ for(AnnotatedFact<FieldRef, D> d3: res) {for(AnnotatedFact<FieldRefFieldRef,, D>d3:res){ //for each callee's start point(s)//for each callee's start point(s) for(N sP: startPointsOf) {for(NsP:startPointsOf){ //create initial self-loop//create initial self-loop D abstractStartPointFact = d3.getFact().cloneWithAccessPath();DabstractStartPointFact=d3.getFact().cloneWithAccessPath(); D abstractStartPointFact = d3.getFact().cloneWithAccessPath(new AccessPath<FieldRef>());DabstractStartPointFact=d3.getFact().cloneWithAccessPath(newnew AccessPathAccessPath<<FieldRefFieldRef>());>() propagate(abstractStartPointFact, sP, abstractStartPointFact, n, false); //line 15propagate(abstractStartPointFact,sP,abstractStartPointFact,n,false);//line 15 }}  //for each return site//for each return site for(N retSiteN: returnSiteNs) {for(NretSiteN:returnSiteNs){ //compute return-flow function//compute return-flow function FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);FlowFunction<D>retFunction=flowFunctions.getReturnFlowFunction(n,sCalledProcN,summary.getTargetStmt(),retSiteN); FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, summary.getTargetStmt(), retSiteN);FlowFunction<FieldRefFieldRef,, D>retFunction=flowFunctions.getReturnFlowFunction(n,sCalledProcN,summary.getTargetStmt(),retSiteN); //for each target value of the function//for each target value of the function for(AnnotatedFact<D> d5: computeReturnFlowFunction(retFunction, d4.get(), n)) {for(AnnotatedFact<D>d5:computeReturnFlowFunction(retFunction,d4.get(),n)){ for(AnnotatedFact<FieldRef, D> d5: computeReturnFlowFunction(retFunction, d4.get(), n)) {for(AnnotatedFact<FieldRefFieldRef,, D>d5:computeReturnFlowFunction(retFunction,d4.get(),n)){ D d5p_restoredCtx = restoreContextOnReturnedFact(d2, d5.getFact());Dd5p_restoredCtx=restoreContextOnReturnedFact(d2,d5.getFact()); propagate(d1, retSiteN, d5p_restoredCtx, n, false);propagate(d1,retSiteN,d5p_restoredCtx,n,false); }} //line 17-19 of Naeem/Lhotak/Rodriguez		//line 17-19 of Naeem/Lhotak/Rodriguez		 //process intra-procedural flows along call-to-return flow functions//process intra-procedural flows along call-to-return flow functions for (N returnSiteN : returnSiteNs) {for(NreturnSiteN:returnSiteNs){ FlowFunction<D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);FlowFunction<D>callToReturnFlowFunction=flowFunctions.getCallToReturnFlowFunction(n,returnSiteN); for(AnnotatedFact<D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))for(AnnotatedFact<D>d3:computeCallToReturnFlowFunction(callToReturnFlowFunction,d1,d2)) FlowFunction<FieldRef, D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);FlowFunction<FieldRefFieldRef,, D>callToReturnFlowFunction=flowFunctions.getCallToReturnFlowFunction(n,returnSiteN); for(AnnotatedFact<FieldRef, D> d3: computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2))for(AnnotatedFact<FieldRefFieldRef,, D>d3:computeCallToReturnFlowFunction(callToReturnFlowFunction,d1,d2)) propagate(d1, returnSiteN, d3.getFact(), n, false);propagate(d1,returnSiteN,d3.getFact(),n,false); }} }} private void registerInterestedCaller(M method, IncomingEdge<D, N> incomingEdge) {privatevoidregisterInterestedCaller(Mmethod,IncomingEdge<D,N>incomingEdge){ Set<PathEdge<N, D>> edges = pausedEdges.get(method);Set<PathEdge<N,D>>edges=pausedEdges.get(method); if(edges != null) {if(edges!=null){ for(PathEdge<N, D> edge : edges) {for(PathEdge<N,D>edge:edges){ for(final PathEdge<N, D> edge : edges) {for(finalfinal PathEdge<N,D>edge:edges){ if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(), edge.factAtSource())) {if(AccessPathUtil.isPrefixOf(incomingEdge.getCalleeSourceFact(),edge.factAtSource())){ logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}", edge, incomingEdge);logger.trace("RECHECKING-PAUSED-EDGE: {} for new incoming edge {}",edge,incomingEdge);  FieldReference[] accessPathDelta = AccessPathUtil.getAccessPathDelta(FieldReference[]accessPathDelta=AccessPathUtil.getAccessPathDelta( incomingEdge.getCalleeSourceFact().getAccessPath(), edge.factAtSource().getAccessPath());incomingEdge.getCalleeSourceFact().getAccessPath(),edge.factAtSource().getAccessPath());  if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), accessPathDelta)) {if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(),incomingEdge.getCallSite(),accessPathDelta)){ propagate(zeroValue.equals(incomingEdge.getCallerSourceFact()) ? zeroValue : AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), propagate(zeroValue.equals(incomingEdge.getCallerSourceFact())?zeroValue:AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(),accessPathDelta), incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta), null, false);incomingEdge.getCallSite(),AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(),accessPathDelta),null,false); } else {}else{ pauseEdge(AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), accessPathDelta), pauseEdge(AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(),accessPathDelta), incomingEdge.getCallSite(), AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), accessPathDelta));incomingEdge.getCallSite(),AccessPathUtil.cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(),accessPathDelta)); }} final FieldRef[] delta = incomingEdge.getCalleeSourceFact().getAccessPath().getDeltaTo(edge.factAtSource().getAccessPath()); finalFieldRef[]delta=incomingEdge.getCalleeSourceFact().getAccessPath().getDeltaTo(edge.factAtSource().getAccessPath()); Constraint<FieldRef> constraint = new Constraint<FieldRef>() {Constraint<FieldRef>constraint=newConstraint<FieldRef>(){ @Override@Override public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {publicAccessPath<FieldRef>applyToAccessPath(AccessPath<FieldRef>accPath){ return accPath.addFieldReference(delta).mergeExcludedFieldReferences(edge.factAtSource().getAccessPath());returnaccPath.addFieldReference(delta).mergeExcludedFieldReferences(edge.factAtSource().getAccessPath()); }} };};  propagateConstrained(constraint, new PathEdge<N,D>(propagateConstrained(constraint,newPathEdge<N,D>( applyConstraint(constraint, incomingEdge.getCallerSourceFact()), applyConstraint(constraint,incomingEdge.getCallerSourceFact()), incomingEdge.getCallSite(), incomingEdge.getCallSite(), applyConstraint(constraint, incomingEdge.getCallerCallSiteFact())));applyConstraint(constraint,incomingEdge.getCallerCallSiteFact()))); }} }} }}	 * @param d2 The abstraction at the call site	 * @param d2 The abstraction at the call site	 * @return The set of caller-side abstractions at the callee's start node	 * @return The set of caller-side abstractions at the callee's start node	 */	 */ protected Set<AnnotatedFact<D>> computeCallFlowFunctionprotectedSet<AnnotatedFact<D>>computeCallFlowFunction (FlowFunction<D> callFlowFunction, D d1, D d2) {(FlowFunction<D>callFlowFunction,Dd1,Dd2){ protected Set<AnnotatedFact<FieldRef, D>> computeCallFlowFunctionprotectedSet<AnnotatedFact<FieldRefFieldRef,, D>>computeCallFlowFunction (FlowFunction<FieldRef, D> callFlowFunction, D d1, D d2) {(FlowFunction<FieldRefFieldRef,, D>callFlowFunction,Dd1,Dd2){ return callFlowFunction.computeTargets(d2);returncallFlowFunction.computeTargets(d2); }}	 * @param d2 The abstraction at the call site	 * @param d2 The abstraction at the call site	 * @return The set of caller-side abstractions at the return site	 * @return The set of caller-side abstractions at the return site	 */	 */ protected Set<AnnotatedFact<D>> computeCallToReturnFlowFunctionprotectedSet<AnnotatedFact<D>>computeCallToReturnFlowFunction (FlowFunction<D> callToReturnFlowFunction, D d1, D d2) {(FlowFunction<D>callToReturnFlowFunction,Dd1,Dd2){ protected Set<AnnotatedFact<FieldRef, D>> computeCallToReturnFlowFunctionprotectedSet<AnnotatedFact<FieldRefFieldRef,, D>>computeCallToReturnFlowFunction (FlowFunction<FieldRef, D> callToReturnFlowFunction, D d1, D d2) {(FlowFunction<FieldRefFieldRef,, D>callToReturnFlowFunction,Dd1,Dd2){ return callToReturnFlowFunction.computeTargets(d2);returncallToReturnFlowFunction.computeTargets(d2); }}  // for each return site// for each return site for (N retSiteC : icfg.getReturnSitesOfCallAt(callSite)) {for(NretSiteC:icfg.getReturnSitesOfCallAt(callSite)){ // compute return-flow function// compute return-flow function FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);FlowFunction<D>retFunction=flowFunctions.getReturnFlowFunction(callSite,methodThatNeedsSummary,n,retSiteC); FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(callSite, methodThatNeedsSummary, n, retSiteC);FlowFunction<FieldRefFieldRef,, D>retFunction=flowFunctions.getReturnFlowFunction(callSite,methodThatNeedsSummary,n,retSiteC);  if(AccessPathUtil.isPrefixOf(d1, incomingEdge.getCalleeSourceFact())) {if(AccessPathUtil.isPrefixOf(d1,incomingEdge.getCalleeSourceFact())){ Optional<D> concreteCalleeExitFact = AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(), summaryEdge);Optional<D>concreteCalleeExitFact=AccessPathUtil.applyAbstractedSummary(incomingEdge.getCalleeSourceFact(),summaryEdge); if(concreteCalleeExitFact.isPresent()) {if(concreteCalleeExitFact.isPresent()){ Set<AnnotatedFact<D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact.get(), callSite);Set<AnnotatedFact<D>>callerTargetFacts=computeReturnFlowFunction(retFunction,concreteCalleeExitFact.get(),callSite); Set<AnnotatedFact<FieldRef, D>> callerTargetFacts = computeReturnFlowFunction(retFunction, concreteCalleeExitFact.get(), callSite);Set<AnnotatedFact<FieldRefFieldRef,, D>>callerTargetFacts=computeReturnFlowFunction(retFunction,concreteCalleeExitFact.get(),callSite);  // for each incoming-call value// for each incoming-call value for (AnnotatedFact<D> callerTargetAnnotatedFact : callerTargetFacts) {for(AnnotatedFact<D>callerTargetAnnotatedFact:callerTargetFacts){ for (AnnotatedFact<FieldRef, D> callerTargetAnnotatedFact : callerTargetFacts) {for(AnnotatedFact<FieldRefFieldRef,, D>callerTargetAnnotatedFact:callerTargetFacts){ D callerTargetFact = restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(), callerTargetAnnotatedFact.getFact());DcallerTargetFact=restoreContextOnReturnedFact(incomingEdge.getCallerCallSiteFact(),callerTargetAnnotatedFact.getFact()); propagate(incomingEdge.getCallerSourceFact(), retSiteC, callerTargetFact, callSite, false);propagate(incomingEdge.getCallerSourceFact(),retSiteC,callerTargetFact,callSite,false); }} Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);Collection<N>callers=icfg.getCallersOf(methodThatNeedsSummary); for(N c: callers) {for(Nc:callers){ for(N retSiteC: icfg.getReturnSitesOfCallAt(c)) {for(NretSiteC:icfg.getReturnSitesOfCallAt(c)){ FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);FlowFunction<D>retFunction=flowFunctions.getReturnFlowFunction(c,methodThatNeedsSummary,n,retSiteC); Set<AnnotatedFact<D>> targets = computeReturnFlowFunction(retFunction, d2, c);Set<AnnotatedFact<D>>targets=computeReturnFlowFunction(retFunction,d2,c); for(AnnotatedFact<D> d5: targets)for(AnnotatedFact<D>d5:targets) FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary,n,retSiteC);FlowFunction<FieldRefFieldRef,, D>retFunction=flowFunctions.getReturnFlowFunction(c,methodThatNeedsSummary,n,retSiteC); Set<AnnotatedFact<FieldRef, D>> targets = computeReturnFlowFunction(retFunction, d2, c);Set<AnnotatedFact<FieldRefFieldRef,, D>>targets=computeReturnFlowFunction(retFunction,d2,c); for(AnnotatedFact<FieldRef, D> d5: targets)for(AnnotatedFact<FieldRefFieldRef,, D>d5:targets) propagate(zeroValue, retSiteC, d5.getFact(), c, true);propagate(zeroValue,retSiteC,d5.getFact(),c,true); }} }} //this might be undesirable if the flow function has a side effect such as registering a taint;//this might be undesirable if the flow function has a side effect such as registering a taint; //instead we thus call the return flow function will a null caller//instead we thus call the return flow function will a null caller if(callers.isEmpty()) {if(callers.isEmpty()){ FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);FlowFunction<D>retFunction=flowFunctions.getReturnFlowFunction(null,methodThatNeedsSummary,n,null); FlowFunction<FieldRef, D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary,n,null);FlowFunction<FieldRefFieldRef,, D>retFunction=flowFunctions.getReturnFlowFunction(null,methodThatNeedsSummary,n,null); retFunction.computeTargets(d2);retFunction.computeTargets(d2); }} }}	 * @param callSite The call site	 * @param callSite The call site	 * @return The set of caller-side abstractions at the return site	 * @return The set of caller-side abstractions at the return site	 */	 */ protected Set<AnnotatedFact<D>> computeReturnFlowFunctionprotectedSet<AnnotatedFact<D>>computeReturnFlowFunction (FlowFunction<D> retFunction, D d2, N callSite) {(FlowFunction<D>retFunction,Dd2,NcallSite){ protected Set<AnnotatedFact<FieldRef, D>> computeReturnFlowFunctionprotectedSet<AnnotatedFact<FieldRefFieldRef,, D>>computeReturnFlowFunction (FlowFunction<FieldRef, D> retFunction, D d2, N callSite) {(FlowFunction<FieldRefFieldRef,, D>retFunction,Dd2,NcallSite){ return retFunction.computeTargets(d2);returnretFunction.computeTargets(d2); }} final D d2 = edge.factAtTarget();finalDd2=edge.factAtTarget();  for (N m : icfg.getSuccsOf(n)) {for(Nm:icfg.getSuccsOf(n)){ FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);FlowFunction<D>flowFunction=flowFunctions.getNormalFlowFunction(n,m); Set<AnnotatedFact<D>> res = computeNormalFlowFunction(flowFunction, d1, d2);Set<AnnotatedFact<D>>res=computeNormalFlowFunction(flowFunction,d1,d2); for (AnnotatedFact<D> d3 : res) {for(AnnotatedFact<D>d3:res){ //TODO: double check if concurrency issues may arise//TODO: double check if concurrency issues may arise  //if reading field f//if reading field f // if d1.f element of incoming edges:// if d1.f element of incoming edges: //    create and propagate (d1.f, d2.f)//    create and propagate (d1.f, d2.f) // else // else  //	  create and set (d1.f, d2.f) on hold//	  create and set (d1.f, d2.f) on hold //	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold//	  create for each incoming edge inc: (inc.call-d1.f, inc.call-d2.f) and put on hold  if(d3.getReadField() != null) {if(d3.getReadField()!=null){ SpecificFieldReference fieldRef = new SpecificFieldReference(d3.getReadField());SpecificFieldReferencefieldRef=newSpecificFieldReference(d3.getReadField()); D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(d1, fieldRef);DconcretizedSourceValue=AccessPathUtil.cloneWithConcatenatedAccessPath(d1,fieldRef); if(checkForInterestedCallers(d1, n, fieldRef)) {if(checkForInterestedCallers(d1,n,fieldRef)){ propagate(concretizedSourceValue, m, d3.getFact(), null, false);propagate(concretizedSourceValue,m,d3.getFact(),null,false); } else {}else{ pauseEdge(concretizedSourceValue, m, d3.getFact());pauseEdge(concretizedSourceValue,m,d3.getFact()); }} }} else if(d3.getWrittenField() != null) {elseif(d3.getWrittenField()!=null){ //TODO: double check if concurrency issues may arise//TODO: double check if concurrency issues may arise  // if writing field f// if writing field f // create edge e = (d1, d2.*\{f})// create edge e = (d1, d2.*\{f}) // if d2.*\{f} element of incoming edges// if d2.*\{f} element of incoming edges // 		continue with e// 		continue with e // else // else  //		put e on hold//		put e on hold // always kill (d1, d2)// always kill (d1, d2)  Any fieldRef = new Any(d3.getWrittenField());AnyfieldRef=newAny(d3.getWrittenField()); if(checkForInterestedCallers(d1, n, fieldRef)) {if(checkForInterestedCallers(d1,n,fieldRef)){ propagate(d1, m, d3.getFact(), null, false);propagate(d1,m,d3.getFact(),null,false); } else {}else{ pauseEdge(d1, m, d3.getFact());pauseEdge(d1,m,d3.getFact()); }} FlowFunction<FieldRef, D> flowFunction = flowFunctions.getNormalFlowFunction(n,m);FlowFunction<FieldRef,D>flowFunction=flowFunctions.getNormalFlowFunction(n,m); Set<AnnotatedFact<FieldRef, D>> res = computeNormalFlowFunction(flowFunction, d1, d2);Set<AnnotatedFact<FieldRef,D>>res=computeNormalFlowFunction(flowFunction,d1,d2); for (AnnotatedFact<FieldRef, D> d3 : res) {for(AnnotatedFact<FieldRef,D>d3:res){ if(d3.getConstraint() != null) {if(d3.getConstraint()!=null){ propagateConstrained(d3.getConstraint(), new PathEdge<>(applyConstraint(d3.getConstraint(), d1), m, d3.getFact()));propagateConstrained(d3.getConstraint(),newPathEdge<>(applyConstraint(d3.getConstraint(),d1),m,d3.getFact())); }} elseelse propagate(d1, m, d3.getFact(), null, false);propagate(d1,m,d3.getFact(),null,false); }} }}  private void pauseEdge(D sourceValue, N targetStmt, D targetValue) {privatevoidpauseEdge(DsourceValue,NtargetStmt,DtargetValue){ M method = icfg.getMethodOf(targetStmt);Mmethod=icfg.getMethodOf(targetStmt); Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());Set<PathEdge<N,D>>edges=pausedEdges.putIfAbsentElseGet(method,newConcurrentHashSet<PathEdge<N,D>>()); if(edges.add(new PathEdge<N,D>(sourceValue, targetStmt, targetValue))) {if(edges.add(newPathEdge<N,D>(sourceValue,targetStmt,targetValue))){ logger.trace("PAUSED: <{},{}> -> <{},{}>", method, sourceValue, targetStmt, targetValue);logger.trace("PAUSED: <{},{}> -> <{},{}>",method,sourceValue,targetStmt,targetValue); }} private D applyConstraint(Constraint<FieldRef> constraint, D fact) {privateDapplyConstraint(Constraint<FieldRef>constraint,Dfact){ if(fact.equals(zeroValue))if(fact.equals(zeroValue)) return zeroValue;returnzeroValue; elseelse return fact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath()));returnfact.cloneWithAccessPath(constraint.applyToAccessPath(fact.getAccessPath())); }}  private boolean propagateConstrained(Constraint<FieldRef> constraint, PathEdge<N, D> pathEdge) {privatebooleanpropagateConstrained(Constraint<FieldRef>constraint,PathEdge<N,D>pathEdge){ M calleeMethod = icfg.getMethodOf(pathEdge.getTarget());McalleeMethod=icfg.getMethodOf(pathEdge.getTarget()); logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, pathEdge.factAtSource(), constraint);logger.trace("Checking interest at method {} in fact {} with field access {}",calleeMethod,pathEdge.factAtSource(),constraint); private boolean checkForInterestedCallers(D calleeSourceFact, N targetStmt, FieldReference... fieldRef) {privatebooleancheckForInterestedCallers(DcalleeSourceFact,NtargetStmt,FieldReference...fieldRef){ M calleeMethod = icfg.getMethodOf(targetStmt);McalleeMethod=icfg.getMethodOf(targetStmt); logger.trace("Checking interest at method {} in fact {} with field access {}", calleeMethod, calleeSourceFact, fieldRef);logger.trace("Checking interest at method {} in fact {} with field access {}",calleeMethod,calleeSourceFact,fieldRef);  if(calleeSourceFact.equals(zeroValue))if(calleeSourceFact.equals(zeroValue)) return true;returntrue;  D concretizedSourceValue = AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact, fieldRef);DconcretizedSourceValue=AccessPathUtil.cloneWithConcatenatedAccessPath(calleeSourceFact,fieldRef); if(!incomingEdgesPrefixedWith(calleeMethod, concretizedSourceValue).isEmpty()) {if(!incomingEdgesPrefixedWith(calleeMethod,concretizedSourceValue).isEmpty()){ return true;returntrue; }}  Set<IncomingEdge<D, N>> inc = incomingEdgesPrefixesOf(calleeMethod, concretizedSourceValue); Set<IncomingEdge<D,N>>inc=incomingEdgesPrefixesOf(calleeMethod,concretizedSourceValue); for (IncomingEdge<D, N> incomingEdge : inc) {for(IncomingEdge<D,N>incomingEdge:inc){ if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(), incomingEdge.getCallSite(), fieldRef)) {if(checkForInterestedCallers(incomingEdge.getCallerSourceFact(),incomingEdge.getCallSite(),fieldRef)){ propagate(incomingEdge.getCallerSourceFact().equals(zeroValue) ? propagate(incomingEdge.getCallerSourceFact().equals(zeroValue)? incomingEdge.getCallerSourceFact() : incomingEdge.getCallerSourceFact(): cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(),fieldRef), incomingEdge.getCallSite(), incomingEdge.getCallSite(), cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef), null, false); cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(),fieldRef),null,false); return true;returntrue; boolean propagate = false;booleanpropagate=false; if(pathEdge.factAtSource().equals(zeroValue))if(pathEdge.factAtSource().equals(zeroValue)) propagate = true;propagate=true; else {else{ Set<N> callSitesWithInterest = Sets.newHashSet();Set<N>callSitesWithInterest=Sets.newHashSet(); for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixedWith(calleeMethod, pathEdge.factAtSource())) {for(IncomingEdge<D,N>incEdge:incomingEdgesPrefixedWith(calleeMethod,pathEdge.factAtSource())){ callSitesWithInterest.add(incEdge.getCallSite());callSitesWithInterest.add(incEdge.getCallSite()); }} else {else{ pauseEdge(cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(), fieldRef), pauseEdge(cloneWithConcatenatedAccessPath(incomingEdge.getCallerSourceFact(),fieldRef), incomingEdge.getCallSite(), incomingEdge.getCallSite(), cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(), fieldRef));cloneWithConcatenatedAccessPath(incomingEdge.getCallerCallSiteFact(),fieldRef)); propagate = !callSitesWithInterest.isEmpty();propagate=!callSitesWithInterest.isEmpty();  for(IncomingEdge<D, N> incEdge : incomingEdgesPrefixesOf(calleeMethod, pathEdge.factAtSource())) {for(IncomingEdge<D,N>incEdge:incomingEdgesPrefixesOf(calleeMethod,pathEdge.factAtSource())){ boolean equal = incEdge.getCalleeSourceFact().equals(pathEdge.factAtSource()); //TODO: write test case for thisbooleanequal=incEdge.getCalleeSourceFact().equals(pathEdge.factAtSource());//TODO: write test case for this if(!equal && !callSitesWithInterest.contains(incEdge.getCallSite())) {if(!equal&&!callSitesWithInterest.contains(incEdge.getCallSite())){ PathEdge<N,D> callerEdge = new PathEdge<>(PathEdge<N,D>callerEdge=newPathEdge<>( applyConstraint(constraint, incEdge.getCallerSourceFact()), applyConstraint(constraint,incEdge.getCallerSourceFact()), incEdge.getCallSite(), incEdge.getCallSite(), applyConstraint(constraint, incEdge.getCallerCallSiteFact()));applyConstraint(constraint,incEdge.getCallerCallSiteFact())); propagate |= propagateConstrained(constraint, callerEdge);propagate|=propagateConstrained(constraint,callerEdge); }} }} }}  return false;returnfalse; if(propagate) {if(propagate){ propagate(pathEdge.factAtSource(), pathEdge.getTarget(), pathEdge.factAtTarget(), null, false);propagate(pathEdge.factAtSource(),pathEdge.getTarget(),pathEdge.factAtTarget(),null,false); return true;returntrue; } else {}else{ pauseEdge(pathEdge);pauseEdge(pathEdge); return false;returnfalse; }} }}  private void pauseEdge(PathEdge<N,D> edge) {privatevoidpauseEdge(PathEdge<N,D>edge){ M method = icfg.getMethodOf(edge.getTarget());Mmethod=icfg.getMethodOf(edge.getTarget()); Set<PathEdge<N, D>> edges = pausedEdges.putIfAbsentElseGet(method, new ConcurrentHashSet<PathEdge<N,D>>());Set<PathEdge<N,D>>edges=pausedEdges.putIfAbsentElseGet(method,newConcurrentHashSet<PathEdge<N,D>>()); if(edges.add(edge)) {if(edges.add(edge)){ logger.trace("PAUSED: {}: {}", method, edge);logger.trace("PAUSED: {}: {}",method,edge); }} }}  /**/**	 * @param d1 The abstraction at the current node	 * @param d1 The abstraction at the current node	 * @return The set of abstractions at the successor node	 * @return The set of abstractions at the successor node	 */	 */ protected Set<AnnotatedFact<D>> computeNormalFlowFunctionprotectedSet<AnnotatedFact<D>>computeNormalFlowFunction (FlowFunction<D> flowFunction, D d1, D d2) {(FlowFunction<D>flowFunction,Dd1,Dd2){ protected Set<AnnotatedFact<FieldRef, D>> computeNormalFlowFunctionprotectedSet<AnnotatedFact<FieldRefFieldRef,, D>>computeNormalFlowFunction (FlowFunction<FieldRef, D> flowFunction, D d1, D d2) {(FlowFunction<FieldRefFieldRef,, D>flowFunction,Dd1,Dd2){ return flowFunction.computeTargets(d2);returnflowFunction.computeTargets(d2); }} 








src/heros/alias/FlowFunction.java








View file @ 1cd34e9e






......@@ -10,8 +10,6 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FieldReference.SpecificFieldReference;





















import java.util.LinkedHashSet;










import java.util.Set;














......@@ -33,18 +31,18 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {










public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<AnnotatedFact<D>> computeTargets(D source);










 Set<AnnotatedFact<FieldRef, D>> computeTargets(D source);










 










 public static class AnnotatedFact<D extends FieldSensitiveFact<?, D>> {










 //TODO: rename to ConstrainedFact










 public static class AnnotatedFact<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 private D fact;










 private String readField;










 private String writtenField;










 private Constraint<FieldRef> constraint;










 










 //TODO: Refactor API to make things more intuitive










 /**



......@@ -53,31 +51,25 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









		 * @param readField Giving a field reference here means the base value of a field access was tainted, i.e., we have to concretize the source value










		 * @param writtenField










		 */










 public AnnotatedFact(D fact, String readField, String writtenField) {










 public AnnotatedFact(D fact, Constraint<FieldRef> constraint) {










 this.fact = fact;










 this.readField = readField;










 this.writtenField = writtenField;










 this.constraint = constraint;










 }










 










 public D getFact() {










 return fact;










 }










 










 public String getReadField() {










 return readField;










 }










 










 public String getWrittenField() {










 return writtenField;










 public Constraint<FieldRef> getConstraint() {










 return constraint;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((constraint == null) ? 0 : constraint.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((readField == null) ? 0 : readField.hashCode());










 result = prime * result + ((writtenField == null) ? 0 : writtenField.hashCode());










 return result;










 }














......@@ -90,27 +82,66 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 if (!(obj instanceof AnnotatedFact))










 return false;










 AnnotatedFact other = (AnnotatedFact) obj;










 if (constraint == null) {










 if (other.constraint != null)










 return false;










 } else if (!constraint.equals(other.constraint))










 return false;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (readField == null) {










 if (other.readField != null)










 return false;










 } else if (!readField.equals(other.readField))










 return false;










 if (writtenField == null) {










 if (other.writtenField != null)










 return false;










 } else if (!writtenField.equals(other.writtenField))










 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return fact.toString()+"<"+readField+","+writtenField+">";










 return fact.toString()+"<"+constraint+">";










 }










 }










 










 public interface Constraint<FieldRef> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath);










 }










 










 public class WriteFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 private FieldRef fieldRef;





















 public WriteFieldConstraint(FieldRef fieldRef) {










 this.fieldRef = fieldRef;










 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 if(accPath.hasExclusions())










 return accPath.getExclusions(0).addExclusion(fieldRef);










 else










 return accPath.appendExcludedFieldReference(fieldRef);










 }










 










 @Override










 public String toString() {










 return "^"+fieldRef.toString();










 }










 }










 










 public class ReadFieldConstraint<FieldRef> implements Constraint<FieldRef> {





















 private FieldRef fieldRef;





















 public ReadFieldConstraint(FieldRef fieldRef) {










 this.fieldRef = fieldRef;










 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(fieldRef);










 }










 










 @Override










 public String toString() {










 return fieldRef.toString();










 }










 }










}












src/heros/alias/FlowFunction.java








View file @ 1cd34e9e








src/heros/alias/FlowFunction.java










View file @ 1cd34e9e


1cd34e9e



......@@ -10,8 +10,6 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FieldReference.SpecificFieldReference;





















import java.util.LinkedHashSet;










import java.util.Set;














......@@ -33,18 +31,18 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {










public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<AnnotatedFact<D>> computeTargets(D source);










 Set<AnnotatedFact<FieldRef, D>> computeTargets(D source);










 










 public static class AnnotatedFact<D extends FieldSensitiveFact<?, D>> {










 //TODO: rename to ConstrainedFact










 public static class AnnotatedFact<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 private D fact;










 private String readField;










 private String writtenField;










 private Constraint<FieldRef> constraint;










 










 //TODO: Refactor API to make things more intuitive










 /**



......@@ -53,31 +51,25 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









		 * @param readField Giving a field reference here means the base value of a field access was tainted, i.e., we have to concretize the source value










		 * @param writtenField










		 */










 public AnnotatedFact(D fact, String readField, String writtenField) {










 public AnnotatedFact(D fact, Constraint<FieldRef> constraint) {










 this.fact = fact;










 this.readField = readField;










 this.writtenField = writtenField;










 this.constraint = constraint;










 }










 










 public D getFact() {










 return fact;










 }










 










 public String getReadField() {










 return readField;










 }










 










 public String getWrittenField() {










 return writtenField;










 public Constraint<FieldRef> getConstraint() {










 return constraint;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((constraint == null) ? 0 : constraint.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((readField == null) ? 0 : readField.hashCode());










 result = prime * result + ((writtenField == null) ? 0 : writtenField.hashCode());










 return result;










 }














......@@ -90,27 +82,66 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 if (!(obj instanceof AnnotatedFact))










 return false;










 AnnotatedFact other = (AnnotatedFact) obj;










 if (constraint == null) {










 if (other.constraint != null)










 return false;










 } else if (!constraint.equals(other.constraint))










 return false;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (readField == null) {










 if (other.readField != null)










 return false;










 } else if (!readField.equals(other.readField))










 return false;










 if (writtenField == null) {










 if (other.writtenField != null)










 return false;










 } else if (!writtenField.equals(other.writtenField))










 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return fact.toString()+"<"+readField+","+writtenField+">";










 return fact.toString()+"<"+constraint+">";










 }










 }










 










 public interface Constraint<FieldRef> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath);










 }










 










 public class WriteFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 private FieldRef fieldRef;





















 public WriteFieldConstraint(FieldRef fieldRef) {










 this.fieldRef = fieldRef;










 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 if(accPath.hasExclusions())










 return accPath.getExclusions(0).addExclusion(fieldRef);










 else










 return accPath.appendExcludedFieldReference(fieldRef);










 }










 










 @Override










 public String toString() {










 return "^"+fieldRef.toString();










 }










 }










 










 public class ReadFieldConstraint<FieldRef> implements Constraint<FieldRef> {





















 private FieldRef fieldRef;





















 public ReadFieldConstraint(FieldRef fieldRef) {










 this.fieldRef = fieldRef;










 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(fieldRef);










 }










 










 @Override










 public String toString() {










 return fieldRef.toString();










 }










 }










}






......@@ -10,8 +10,6 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FieldReference.SpecificFieldReference;





















import java.util.LinkedHashSet;










import java.util.Set;














......@@ -33,18 +31,18 @@ import java.util.Set;









 * 










 * @param <D> The type of data-flow facts to be computed by the tabulation problem.










 */










public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {










public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {





















 /**










	 * Returns the target values reachable from the source.










	 */










 Set<AnnotatedFact<D>> computeTargets(D source);










 Set<AnnotatedFact<FieldRef, D>> computeTargets(D source);










 










 public static class AnnotatedFact<D extends FieldSensitiveFact<?, D>> {










 //TODO: rename to ConstrainedFact










 public static class AnnotatedFact<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {










 










 private D fact;










 private String readField;










 private String writtenField;










 private Constraint<FieldRef> constraint;










 










 //TODO: Refactor API to make things more intuitive










 /**



......@@ -53,31 +51,25 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









		 * @param readField Giving a field reference here means the base value of a field access was tainted, i.e., we have to concretize the source value










		 * @param writtenField










		 */










 public AnnotatedFact(D fact, String readField, String writtenField) {










 public AnnotatedFact(D fact, Constraint<FieldRef> constraint) {










 this.fact = fact;










 this.readField = readField;










 this.writtenField = writtenField;










 this.constraint = constraint;










 }










 










 public D getFact() {










 return fact;










 }










 










 public String getReadField() {










 return readField;










 }










 










 public String getWrittenField() {










 return writtenField;










 public Constraint<FieldRef> getConstraint() {










 return constraint;










 }





















 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((constraint == null) ? 0 : constraint.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((readField == null) ? 0 : readField.hashCode());










 result = prime * result + ((writtenField == null) ? 0 : writtenField.hashCode());










 return result;










 }














......@@ -90,27 +82,66 @@ public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {









 if (!(obj instanceof AnnotatedFact))










 return false;










 AnnotatedFact other = (AnnotatedFact) obj;










 if (constraint == null) {










 if (other.constraint != null)










 return false;










 } else if (!constraint.equals(other.constraint))










 return false;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!fact.equals(other.fact))










 return false;










 if (readField == null) {










 if (other.readField != null)










 return false;










 } else if (!readField.equals(other.readField))










 return false;










 if (writtenField == null) {










 if (other.writtenField != null)










 return false;










 } else if (!writtenField.equals(other.writtenField))










 return false;










 return true;










 }










 










 @Override










 public String toString() {










 return fact.toString()+"<"+readField+","+writtenField+">";










 return fact.toString()+"<"+constraint+">";










 }










 }










 










 public interface Constraint<FieldRef> {










 AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath);










 }










 










 public class WriteFieldConstraint<FieldRef> implements Constraint<FieldRef> {










 private FieldRef fieldRef;





















 public WriteFieldConstraint(FieldRef fieldRef) {










 this.fieldRef = fieldRef;










 }





















 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 if(accPath.hasExclusions())










 return accPath.getExclusions(0).addExclusion(fieldRef);










 else










 return accPath.appendExcludedFieldReference(fieldRef);










 }










 










 @Override










 public String toString() {










 return "^"+fieldRef.toString();










 }










 }










 










 public class ReadFieldConstraint<FieldRef> implements Constraint<FieldRef> {





















 private FieldRef fieldRef;





















 public ReadFieldConstraint(FieldRef fieldRef) {










 this.fieldRef = fieldRef;










 }










 










 @Override










 public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {










 return accPath.addFieldReference(fieldRef);










 }










 










 @Override










 public String toString() {










 return fieldRef.toString();










 }










 }










}


 ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.alias.FieldReference.SpecificFieldReference;importheros.alias.FieldReference.SpecificFieldReference;import java.util.LinkedHashSet;importjava.util.LinkedHashSet;import java.util.Set;importjava.util.Set; *  *  * @param <D> The type of data-flow facts to be computed by the tabulation problem. * @param <D> The type of data-flow facts to be computed by the tabulation problem. */ */public interface FlowFunction<D extends FieldSensitiveFact<?, D>> {publicinterfaceFlowFunction<DextendsFieldSensitiveFact<?,D>>{public interface FlowFunction<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {publicinterfaceFlowFunction<FieldRefFieldRef,, DextendsFieldSensitiveFact<?,FieldRefFieldRef,, D>>{ /**/**	 * Returns the target values reachable from the source.	 * Returns the target values reachable from the source.	 */	 */ Set<AnnotatedFact<D>> computeTargets(D source);Set<AnnotatedFact<D>>computeTargets(Dsource); Set<AnnotatedFact<FieldRef, D>> computeTargets(D source);Set<AnnotatedFact<FieldRefFieldRef,, D>>computeTargets(Dsource);  public static class AnnotatedFact<D extends FieldSensitiveFact<?, D>> {publicstaticclassAnnotatedFact<DextendsFieldSensitiveFact<?,D>>{ //TODO: rename to ConstrainedFact//TODO: rename to ConstrainedFact public static class AnnotatedFact<FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>> {publicstaticclassAnnotatedFact<FieldRef,DextendsFieldSensitiveFact<?,FieldRef,D>>{  private D fact;privateDfact; private String readField;privateStringreadField; private String writtenField;privateStringwrittenField; private Constraint<FieldRef> constraint;privateConstraint<FieldRef>constraint;  //TODO: Refactor API to make things more intuitive//TODO: Refactor API to make things more intuitive /**/**		 * @param readField Giving a field reference here means the base value of a field access was tainted, i.e., we have to concretize the source value		 * @param readField Giving a field reference here means the base value of a field access was tainted, i.e., we have to concretize the source value		 * @param writtenField		 * @param writtenField		 */		 */ public AnnotatedFact(D fact, String readField, String writtenField) {publicAnnotatedFact(Dfact,StringSg readFieldreadField,, StringSg writtenFieldwrittenField){ public AnnotatedFact(D fact, Constraint<FieldRef> constraint) {publicAnnotatedFact(Dfact,ConstraintConsat<<FieldRefFieldRef>> constraintconsat){ this.fact = fact;this.fact=fact; this.readField = readField;this.readField=readField; this.writtenField = writtenField;this.writtenField=writtenField; this.constraint = constraint;this.constraint=constraint; }}  public D getFact() {publicDgetFact(){ return fact;returnfact; }}  public String getReadField() {publicStringgetReadField(){ return readField;returnreadField; }}  public String getWrittenField() {publicStringgetWrittenField(){ return writtenField;returnwrittenField; public Constraint<FieldRef> getConstraint() {publicConstraint<FieldRef>getConstraint(){ return constraint;returnconstraint; }} @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + ((constraint == null) ? 0 : constraint.hashCode());result=prime*result+((constraint==null)?0:constraint.hashCode()); result = prime * result + ((fact == null) ? 0 : fact.hashCode());result=prime*result+((fact==null)?0:fact.hashCode()); result = prime * result + ((readField == null) ? 0 : readField.hashCode());result=prime*result+((readField==null)?0:readField.hashCode()); result = prime * result + ((writtenField == null) ? 0 : writtenField.hashCode());result=prime*result+((writtenField==null)?0:writtenField.hashCode()); return result;returnresult; }} if (!(obj instanceof AnnotatedFact))if(!(objinstanceofAnnotatedFact)) return false;returnfalse; AnnotatedFact other = (AnnotatedFact) obj;AnnotatedFactother=(AnnotatedFact)obj; if (constraint == null) {if(constraint==null){ if (other.constraint != null)if(other.constraint!=null) return false;returnfalse; } else if (!constraint.equals(other.constraint))}elseif(!constraint.equals(other.constraint)) return false;returnfalse; if (fact == null) {if(fact==null){ if (other.fact != null)if(other.fact!=null) return false;returnfalse; } else if (!fact.equals(other.fact))}elseif(!fact.equals(other.fact)) return false;returnfalse; if (readField == null) {if(readField==null){ if (other.readField != null)if(other.readField!=null) return false;returnfalse; } else if (!readField.equals(other.readField))}elseif(!readField.equals(other.readField)) return false;returnfalse; if (writtenField == null) {if(writtenField==null){ if (other.writtenField != null)if(other.writtenField!=null) return false;returnfalse; } else if (!writtenField.equals(other.writtenField))}elseif(!writtenField.equals(other.writtenField)) return false;returnfalse; return true;returntrue; }}  @Override@Override public String toString() {publicStringtoString(){ return fact.toString()+"<"+readField+","+writtenField+">";returnfact.toString()+"<"+readField+","+writtenField+">"; return fact.toString()+"<"+constraint+">";returnfact.toString()+"<"+constraint+">"; }} }}  public interface Constraint<FieldRef> {publicinterfaceConstraint<FieldRef>{ AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath);AccessPath<FieldRef>applyToAccessPath(AccessPath<FieldRef>accPath); }}  public class WriteFieldConstraint<FieldRef> implements Constraint<FieldRef> {publicclassWriteFieldConstraint<FieldRef>implementsConstraint<FieldRef>{ private FieldRef fieldRef;privateFieldReffieldRef; public WriteFieldConstraint(FieldRef fieldRef) {publicWriteFieldConstraint(FieldReffieldRef){ this.fieldRef = fieldRef;this.fieldRef=fieldRef; }} @Override@Override public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {publicAccessPath<FieldRef>applyToAccessPath(AccessPath<FieldRef>accPath){ if(accPath.hasExclusions())if(accPath.hasExclusions()) return accPath.getExclusions(0).addExclusion(fieldRef);returnaccPath.getExclusions(0).addExclusion(fieldRef); elseelse return accPath.appendExcludedFieldReference(fieldRef);returnaccPath.appendExcludedFieldReference(fieldRef); }}  @Override@Override public String toString() {publicStringtoString(){ return "^"+fieldRef.toString();return"^"+fieldRef.toString(); }} }}  public class ReadFieldConstraint<FieldRef> implements Constraint<FieldRef> {publicclassReadFieldConstraint<FieldRef>implementsConstraint<FieldRef>{ private FieldRef fieldRef;privateFieldReffieldRef; public ReadFieldConstraint(FieldRef fieldRef) {publicReadFieldConstraint(FieldReffieldRef){ this.fieldRef = fieldRef;this.fieldRef=fieldRef; }}  @Override@Override public AccessPath<FieldRef> applyToAccessPath(AccessPath<FieldRef> accPath) {publicAccessPath<FieldRef>applyToAccessPath(AccessPath<FieldRef>accPath){ return accPath.addFieldReference(fieldRef);returnaccPath.addFieldReference(fieldRef); }}  @Override@Override public String toString() {publicStringtoString(){ return fieldRef.toString();returnfieldRef.toString(); }} }}}}








src/heros/alias/FlowFunctions.java








View file @ 1cd34e9e






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......@@ -40,7 +40,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<F> getNormalFlowFunction(Stmt curr, Stmt succ);










 public FlowFunction<FieldRef, F> getNormalFlowFunction(Stmt curr, Stmt succ);





















 










 /**



......@@ -52,7 +52,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);










 public FlowFunction<FieldRef, F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a



......@@ -82,7 +82,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 *            does not contain a caller for the method that is returned from.










	 * @return










	 */










 public FlowFunction<F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);










 public FlowFunction<FieldRef, F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a



......@@ -102,7 +102,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);










 public FlowFunction<FieldRef, F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);





















 










 



......












src/heros/alias/FlowFunctions.java








View file @ 1cd34e9e








src/heros/alias/FlowFunctions.java










View file @ 1cd34e9e


1cd34e9e



......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......@@ -40,7 +40,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<F> getNormalFlowFunction(Stmt curr, Stmt succ);










 public FlowFunction<FieldRef, F> getNormalFlowFunction(Stmt curr, Stmt succ);





















 










 /**



......@@ -52,7 +52,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);










 public FlowFunction<FieldRef, F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a



......@@ -82,7 +82,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 *            does not contain a caller for the method that is returned from.










	 * @return










	 */










 public FlowFunction<F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);










 public FlowFunction<FieldRef, F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a



......@@ -102,7 +102,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);










 public FlowFunction<FieldRef, F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);





















 










 



......






......@@ -27,7 +27,7 @@ package heros.alias;









 *            The type of objects used to represent methods. Typically










 *            {@link SootMethod}.










 */










public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method> {










public interface FlowFunctions<Stmt, FieldRef, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {





















 /**










	 * Returns the flow function that computes the flow for a normal statement,



......@@ -40,7 +40,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 *            be used to compute a branched analysis that propagates










	 *            different values depending on where control0flow branches.










	 */










 public FlowFunction<F> getNormalFlowFunction(Stmt curr, Stmt succ);










 public FlowFunction<FieldRef, F> getNormalFlowFunction(Stmt curr, Stmt succ);





















 










 /**



......@@ -52,7 +52,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 * @param destinationMethod










	 *            The concrete target method for which the flow is computed.










	 */










 public FlowFunction<F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);










 public FlowFunction<FieldRef, F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);





















 /**










	 * Returns the flow function that computes the flow for a an exit from a



......@@ -82,7 +82,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 *            does not contain a caller for the method that is returned from.










	 * @return










	 */










 public FlowFunction<F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);










 public FlowFunction<FieldRef, F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);





















 /**










	 * Returns the flow function that computes the flow from a call site to a



......@@ -102,7 +102,7 @@ public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method>









	 *            exceptional flow, this may actually be the start of an










	 *            exception handler.










	 */










 public FlowFunction<F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);










 public FlowFunction<FieldRef, F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);





















 










 



......


 *            The type of objects used to represent methods. Typically *            The type of objects used to represent methods. Typically *            {@link SootMethod}. *            {@link SootMethod}. */ */public interface FlowFunctions<Stmt, F extends FieldSensitiveFact<?, F>, Method> {publicinterfaceFlowFunctions<Stmt,FextendsFieldSensitiveFact<?,F>,Method>{public interface FlowFunctions<Stmt, FieldRef, F extends FieldSensitiveFact<?, FieldRef, F>, Method> {publicinterfaceFlowFunctions<Stmt,FieldRefFieldRef,, FextendsFieldSensitiveFact<?,FieldRefFieldRef,, F>,Method>{ /**/**	 * Returns the flow function that computes the flow for a normal statement,	 * Returns the flow function that computes the flow for a normal statement,	 *            be used to compute a branched analysis that propagates	 *            be used to compute a branched analysis that propagates	 *            different values depending on where control0flow branches.	 *            different values depending on where control0flow branches.	 */	 */ public FlowFunction<F> getNormalFlowFunction(Stmt curr, Stmt succ);publicFlowFunction<F>getNormalFlowFunction(Stmtcurr,Stmtsucc); public FlowFunction<FieldRef, F> getNormalFlowFunction(Stmt curr, Stmt succ);publicFlowFunction<FieldRefFieldRef,, F>getNormalFlowFunction(Stmtcurr,Stmtsucc);  /**/**	 * @param destinationMethod	 * @param destinationMethod	 *            The concrete target method for which the flow is computed.	 *            The concrete target method for which the flow is computed.	 */	 */ public FlowFunction<F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);publicFlowFunction<F>getCallFlowFunction(StmtcallStmt,MethoddestinationMethod); public FlowFunction<FieldRef, F> getCallFlowFunction(Stmt callStmt, Method destinationMethod);publicFlowFunction<FieldRefFieldRef,, F>getCallFlowFunction(StmtcallStmt,MethoddestinationMethod); /**/**	 * Returns the flow function that computes the flow for a an exit from a	 * Returns the flow function that computes the flow for a an exit from a	 *            does not contain a caller for the method that is returned from.	 *            does not contain a caller for the method that is returned from.	 * @return	 * @return	 */	 */ public FlowFunction<F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);publicFlowFunction<F>getReturnFlowFunction(StmtcallSite,MethodcalleeMethod,StmtexitStmt,StmtreturnSite); public FlowFunction<FieldRef, F> getReturnFlowFunction(Stmt callSite, Method calleeMethod, Stmt exitStmt, Stmt returnSite);publicFlowFunction<FieldRefFieldRef,, F>getReturnFlowFunction(StmtcallSite,MethodcalleeMethod,StmtexitStmt,StmtreturnSite); /**/**	 * Returns the flow function that computes the flow from a call site to a	 * Returns the flow function that computes the flow from a call site to a	 *            exceptional flow, this may actually be the start of an	 *            exceptional flow, this may actually be the start of an	 *            exception handler.	 *            exception handler.	 */	 */ public FlowFunction<F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);publicFlowFunction<F>getCallToReturnFlowFunction(StmtcallSite,StmtreturnSite); public FlowFunction<FieldRef, F> getCallToReturnFlowFunction(Stmt callSite, Stmt returnSite);publicFlowFunction<FieldRefFieldRef,, F>getCallToReturnFlowFunction(StmtcallSite,StmtreturnSite);  








src/heros/alias/IFDSTabulationProblem.java








View file @ 1cd34e9e






......@@ -28,7 +28,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,D extends FieldSensitiveFact<?, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......@@ -37,7 +37,7 @@ public interface IFDSTabulationProblem<N,D extends FieldSensitiveFact<?, D>,M, I









	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 FlowFunctions<N,D,M> flowFunctions();










 FlowFunctions<N,FieldRef,D,M> flowFunctions();










 










 /**










	 * Returns the interprocedural control-flow graph which this problem is computed over.



......












src/heros/alias/IFDSTabulationProblem.java








View file @ 1cd34e9e








src/heros/alias/IFDSTabulationProblem.java










View file @ 1cd34e9e


1cd34e9e



......@@ -28,7 +28,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,D extends FieldSensitiveFact<?, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......@@ -37,7 +37,7 @@ public interface IFDSTabulationProblem<N,D extends FieldSensitiveFact<?, D>,M, I









	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 FlowFunctions<N,D,M> flowFunctions();










 FlowFunctions<N,FieldRef,D,M> flowFunctions();










 










 /**










	 * Returns the interprocedural control-flow graph which this problem is computed over.



......






......@@ -28,7 +28,7 @@ import java.util.Set;









 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}.










 * @param <I> The type of inter-procedural control-flow graph being used.










 */










public interface IFDSTabulationProblem<N,D extends FieldSensitiveFact<?, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {










public interface IFDSTabulationProblem<N,FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {





















 /**










	 * Returns a set of flow functions. Those functions are used to compute data-flow facts



......@@ -37,7 +37,7 @@ public interface IFDSTabulationProblem<N,D extends FieldSensitiveFact<?, D>,M, I









	 * <b>NOTE:</b> this method could be called many times. Implementations of this










	 * interface should therefore cache the return value! 










	 */










 FlowFunctions<N,D,M> flowFunctions();










 FlowFunctions<N,FieldRef,D,M> flowFunctions();










 










 /**










	 * Returns the interprocedural control-flow graph which this problem is computed over.



......


 * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}. * @param <M> The type of objects used to represent methods. Typically {@link SootMethod}. * @param <I> The type of inter-procedural control-flow graph being used. * @param <I> The type of inter-procedural control-flow graph being used. */ */public interface IFDSTabulationProblem<N,D extends FieldSensitiveFact<?, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {publicinterfaceIFDSTabulationProblem<N,DextendsFieldSensitiveFact<?,D>,M,IextendsInterproceduralCFG<N,M>>extendsSolverConfiguration{public interface IFDSTabulationProblem<N,FieldRef, D extends FieldSensitiveFact<?, FieldRef, D>,M, I extends InterproceduralCFG<N,M>> extends SolverConfiguration {publicinterfaceIFDSTabulationProblem<N,FieldRefFieldRef,, DextendsFieldSensitiveFact<?,FieldRefFieldRef,, D>,M,IextendsInterproceduralCFG<N,M>>extendsSolverConfiguration{ /**/**	 * Returns a set of flow functions. Those functions are used to compute data-flow facts	 * Returns a set of flow functions. Those functions are used to compute data-flow facts	 * <b>NOTE:</b> this method could be called many times. Implementations of this	 * <b>NOTE:</b> this method could be called many times. Implementations of this	 * interface should therefore cache the return value! 	 * interface should therefore cache the return value! 	 */	 */ FlowFunctions<N,D,M> flowFunctions();FlowFunctions<N,D,M>flowFunctions(); FlowFunctions<N,FieldRef,D,M> flowFunctions();FlowFunctions<N,FieldRefFieldRef,,D,M>flowFunctions();  /**/**	 * Returns the interprocedural control-flow graph which this problem is computed over.	 * Returns the interprocedural control-flow graph which this problem is computed over.








src/heros/solver/CountLatch.java








View file @ 1cd34e9e






......@@ -72,7 +72,7 @@ public class CountLatch {









 }





















 public void awaitZero() throws InterruptedException {










 sync.acquireSharedInterruptibly(1);










 sync.acquireShared(1);










 }





















 public boolean awaitZero(long timeout, TimeUnit unit) throws InterruptedException {



......












src/heros/solver/CountLatch.java








View file @ 1cd34e9e








src/heros/solver/CountLatch.java










View file @ 1cd34e9e


1cd34e9e



......@@ -72,7 +72,7 @@ public class CountLatch {









 }





















 public void awaitZero() throws InterruptedException {










 sync.acquireSharedInterruptibly(1);










 sync.acquireShared(1);










 }





















 public boolean awaitZero(long timeout, TimeUnit unit) throws InterruptedException {



......






......@@ -72,7 +72,7 @@ public class CountLatch {









 }





















 public void awaitZero() throws InterruptedException {










 sync.acquireSharedInterruptibly(1);










 sync.acquireShared(1);










 }





















 public boolean awaitZero(long timeout, TimeUnit unit) throws InterruptedException {



......


 }} public void awaitZero() throws InterruptedException {publicvoidawaitZero()throwsInterruptedException{ sync.acquireSharedInterruptibly(1);sync.acquireSharedInterruptiblyInterruptibly(1); sync.acquireShared(1);sync.acquireShared(1); }} public boolean awaitZero(long timeout, TimeUnit unit) throws InterruptedException {publicbooleanawaitZero(longtimeout,TimeUnitunit)throwsInterruptedException{








test/heros/alias/AccessPathUtilTest.java








View file @ 1cd34e9e






......@@ -53,21 +53,22 @@ public class AccessPathUtilTest {









 










 @Test










 public void testDifferentExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.g")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.h")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.f.g")));










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a.g.g")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a.f.h")));










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^g")));










 }





















 @Test



......@@ -76,10 +77,15 @@ public class AccessPathUtilTest {









 }










 










 @Test










 public void testExclusionDoesNotRequireFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 assertTrue(isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 public void testExclusionRequiresFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a"), new Fact("a^f")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a")));










 










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 assertFalse(isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g^h")));










 assertFalse(isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 }










 










 @Test



......@@ -133,19 +139,4 @@ public class AccessPathUtilTest {









 public void testNullOnImpossibleSubsumption() {










 assertFalse(applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).isPresent());










 }










 










 @Test










 public void testConcretizeCallerSourceFact() {










 assertEquals(new Fact("0.f"), AccessPathUtil.concretizeCallerSourceFact(new IncomingEdge<>(new Fact("2"), null, new Fact("0"), null), new Fact("2.f")));










 }










 










 @Test










 public void testConcretizeCallerSourceFactIdentity() {










 assertEquals(new Fact("0.f"), AccessPathUtil.concretizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2.f")));










 }










 










 @Test(expected=IllegalArgumentException.class)










 public void testConcretizeCallerSourceFactNoPrefix() {










 AccessPathUtil.concretizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2"));










 }










}












test/heros/alias/AccessPathUtilTest.java








View file @ 1cd34e9e








test/heros/alias/AccessPathUtilTest.java










View file @ 1cd34e9e


1cd34e9e



......@@ -53,21 +53,22 @@ public class AccessPathUtilTest {









 










 @Test










 public void testDifferentExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.g")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.h")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.f.g")));










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a.g.g")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a.f.h")));










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^g")));










 }





















 @Test



......@@ -76,10 +77,15 @@ public class AccessPathUtilTest {









 }










 










 @Test










 public void testExclusionDoesNotRequireFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 assertTrue(isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 public void testExclusionRequiresFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a"), new Fact("a^f")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a")));










 










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 assertFalse(isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g^h")));










 assertFalse(isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 }










 










 @Test



......@@ -133,19 +139,4 @@ public class AccessPathUtilTest {









 public void testNullOnImpossibleSubsumption() {










 assertFalse(applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).isPresent());










 }










 










 @Test










 public void testConcretizeCallerSourceFact() {










 assertEquals(new Fact("0.f"), AccessPathUtil.concretizeCallerSourceFact(new IncomingEdge<>(new Fact("2"), null, new Fact("0"), null), new Fact("2.f")));










 }










 










 @Test










 public void testConcretizeCallerSourceFactIdentity() {










 assertEquals(new Fact("0.f"), AccessPathUtil.concretizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2.f")));










 }










 










 @Test(expected=IllegalArgumentException.class)










 public void testConcretizeCallerSourceFactNoPrefix() {










 AccessPathUtil.concretizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2"));










 }










}






......@@ -53,21 +53,22 @@ public class AccessPathUtilTest {









 










 @Test










 public void testDifferentExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.g")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.h")));










 assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.f.g")));










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a.g.g")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a.f.h")));










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^g")));










 }





















 @Test



......@@ -76,10 +77,15 @@ public class AccessPathUtilTest {









 }










 










 @Test










 public void testExclusionDoesNotRequireFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a")));










 assertTrue(isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 assertTrue(isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 public void testExclusionRequiresFieldAccess() {










 assertTrue(isPrefixOf(new Fact("a"), new Fact("a^f")));










 assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a")));










 










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 assertFalse(isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 










 assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g^h")));










 assertFalse(isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 }










 










 @Test



......@@ -133,19 +139,4 @@ public class AccessPathUtilTest {









 public void testNullOnImpossibleSubsumption() {










 assertFalse(applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).isPresent());










 }










 










 @Test










 public void testConcretizeCallerSourceFact() {










 assertEquals(new Fact("0.f"), AccessPathUtil.concretizeCallerSourceFact(new IncomingEdge<>(new Fact("2"), null, new Fact("0"), null), new Fact("2.f")));










 }










 










 @Test










 public void testConcretizeCallerSourceFactIdentity() {










 assertEquals(new Fact("0.f"), AccessPathUtil.concretizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2.f")));










 }










 










 @Test(expected=IllegalArgumentException.class)










 public void testConcretizeCallerSourceFactNoPrefix() {










 AccessPathUtil.concretizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2"));










 }










}


  @Test@Test public void testDifferentExclusions() {publicvoidtestDifferentExclusions(){ assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^g")));assertTrueTru(isPrefixOf(newFact("a^f"),newFact("a^g"))); assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a^g")));assertFalseFals(isPrefixOf(newFact("a^f"),newFact("a^g"))); }}  @Test@Test public void testMixedFieldAccess() {publicvoidtestMixedFieldAccess(){ assertTrue(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.g")));assertTrue(isPrefixOf(newFact("a^f.g"),newFact("a.g.g"))); assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.g.h")));assertFalse(isPrefixOf(newFact("a^f.g"),newFact("a.g.h"))); assertFalse(isPrefixOf(new Fact("a^f.g"), new Fact("a.f.g")));assertFalse(isPrefixOf(newFact("a^f.g"),newFact("a.f.g"))); assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a.g.g")));assertTrue(isPrefixOf(newFact("a^f"),newFact("a.g.g"))); assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a.f.h")));assertFalse(isPrefixOf(newFact("a^f"),newFact("a.f.h"))); assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));assertTrue(isPrefixOf(newFact("a.f"),newFact("a.f^g"))); }}  @Test@Test public void testMultipleExclusions() {publicvoidtestMultipleExclusions(){ assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));assertTrue(isPrefixOf(newFact("a^f,g"),newFact("a^f"))); assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));assertTrue(isPrefixOf(newFact("a^f"),newFact("a^f,g"))); assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));assertFalse(isPrefixOf(newFact("a^f"),newFact("a^f,g"))); assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));assertTrue(isPrefixOf(newFact("a^f,g"),newFact("a^f"))); assertTrue(isPrefixOf(new Fact("a^f,g"), new Fact("a^g")));assertTrue(isPrefixOf(newFact("a^f,g"),newFact("a^g"))); }} @Test@Test }}  @Test@Test public void testExclusionDoesNotRequireFieldAccess() {publicvoidtestExclusionDoesNotRequireFieldAccess(){ assertTrue(isPrefixOf(new Fact("a^f"), new Fact("a")));assertTrue(isPrefixOf(newFact("a^f"),newFact("a"))); assertTrue(isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));assertTrue(isPrefixOf(newFact("a.f^g"),newFact("a.f"))); assertTrue(isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));assertTrue(isPrefixOf(newFact("a.f^g^h"),newFact("a.f"))); public void testExclusionRequiresFieldAccess() {publicvoidtestExclusionRequiresFieldAccess(){ assertTrue(isPrefixOf(new Fact("a"), new Fact("a^f")));assertTrue(isPrefixOf(newFact("a"),newFact("a^f"))); assertFalse(isPrefixOf(new Fact("a^f"), new Fact("a")));assertFalse(isPrefixOf(newFact("a^f"),newFact("a")));  assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));assertTrue(isPrefixOf(newFact("a.f"),newFact("a.f^g"))); assertFalse(isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));assertFalse(isPrefixOf(newFact("a.f^g"),newFact("a.f")));  assertTrue(isPrefixOf(new Fact("a.f"), new Fact("a.f^g^h")));assertTrue(isPrefixOf(newFact("a.f"),newFact("a.f^g^h"))); assertFalse(isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));assertFalse(isPrefixOf(newFact("a.f^g^h"),newFact("a.f"))); }}  @Test@Test public void testNullOnImpossibleSubsumption() {publicvoidtestNullOnImpossibleSubsumption(){ assertFalse(applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).isPresent());assertFalse(applyAbstractedSummary(newFact("a.f"),newSummaryEdge<>(newFact("a"),null,newFact("a^f"))).isPresent()); }}  @Test@Test public void testConcretizeCallerSourceFact() {publicvoidtestConcretizeCallerSourceFact(){ assertEquals(new Fact("0.f"), AccessPathUtil.concretizeCallerSourceFact(new IncomingEdge<>(new Fact("2"), null, new Fact("0"), null), new Fact("2.f")));assertEquals(newFact("0.f"),AccessPathUtil.concretizeCallerSourceFact(newIncomingEdge<>(newFact("2"),null,newFact("0"),null),newFact("2.f"))); }}  @Test@Test public void testConcretizeCallerSourceFactIdentity() {publicvoidtestConcretizeCallerSourceFactIdentity(){ assertEquals(new Fact("0.f"), AccessPathUtil.concretizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2.f")));assertEquals(newFact("0.f"),AccessPathUtil.concretizeCallerSourceFact(newIncomingEdge<>(newFact("2.f"),null,newFact("0.f"),null),newFact("2.f"))); }}  @Test(expected=IllegalArgumentException.class)@Test(expected=IllegalArgumentException.class) public void testConcretizeCallerSourceFactNoPrefix() {publicvoidtestConcretizeCallerSourceFactNoPrefix(){ AccessPathUtil.concretizeCallerSourceFact(new IncomingEdge<>(new Fact("2.f"), null, new Fact("0.f"), null), new Fact("2"));AccessPathUtil.concretizeCallerSourceFact(newIncomingEdge<>(newFact("2.f"),null,newFact("0.f"),null),newFact("2")); }}}}








test/heros/alias/Fact.java








View file @ 1cd34e9e






......@@ -20,15 +20,16 @@ import com.google.common.base.Joiner;









import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, Fact> {










public class Fact implements FieldSensitiveFact<String, String, Fact> {





















 public final String baseValue;










 public final FieldReference[] accessPath;










 public final AccessPath<String> accessPath;










 










 public Fact(String name) {










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 ArrayList<FieldReference> accessPath = Lists.newArrayList();










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();










 baseValue = name.substring(0, firstSeparator);



......@@ -39,23 +40,25 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 String identifier = matcher.group(2);










 










 if(separator.equals(".")) {










 accessPath.add(new FieldReference.SpecificFieldReference(identifier));










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(identifier);










 } else {










 accessPath.add(new FieldReference.Any(identifier.split(",")));










 addedExclusions=true;










 accessPath = accessPath.appendExcludedFieldReference(identifier.split(","));










 }










 }










 this.accessPath = accessPath.toArray(new FieldReference[accessPath.size()]);










 this.accessPath = accessPath;










 }










 










 public Fact(String baseValue, FieldReference[] accessPath) {










 public Fact(String baseValue, AccessPath<String> accessPath) {










 this.baseValue = baseValue;










 this.accessPath = accessPath;










 }





















 










 @Override










 public String toString() {










 return "[Fact "+baseValue+(accessPath.length>0 ? "."+Joiner.on(".").join(accessPath) : "" )+"]";










 return "[Fact "+baseValue+(accessPath.isEmpty() ? "" : accessPath)+"]";










 }





















 @Override



......@@ -64,30 +67,26 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 }





















 @Override










 public FieldReference[] getAccessPath() {










 public AccessPath<String> getAccessPath() {










 return accessPath;










 }
































 @Override










 public void addNeighbor(FieldSensitiveFact<String, Fact> originalAbstraction) {










 public void addNeighbor(Fact originalAbstraction) {










 










 }
































 @Override










 public void setCallingContext(FieldSensitiveFact<String, Fact> callingContext) {










 public void setCallingContext(Fact callingContext) {










 










 }
































 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accessPath);










 result = prime * result










 + ((baseValue == null) ? 0 : baseValue.hashCode());










 result = prime * result + ((accessPath == null) ? 0 : accessPath.hashCode());










 result = prime * result + ((baseValue == null) ? 0 : baseValue.hashCode());










 return result;










 }














......@@ -97,10 +96,13 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 if (!(obj instanceof Fact))










 return false;










 Fact other = (Fact) obj;










 if (!Arrays.equals(accessPath, other.accessPath))










 if (accessPath == null) {










 if (other.accessPath != null)










 return false;










 } else if (!accessPath.equals(other.accessPath))










 return false;










 if (baseValue == null) {










 if (other.baseValue != null)



......@@ -110,11 +112,8 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 return true;










 }






















































 @Override










 public Fact cloneWithAccessPath(FieldReference... accessPath) {










 public Fact cloneWithAccessPath(AccessPath<String> accessPath) {










 return new Fact(baseValue, accessPath);










 }










 



......












test/heros/alias/Fact.java








View file @ 1cd34e9e








test/heros/alias/Fact.java










View file @ 1cd34e9e


1cd34e9e



......@@ -20,15 +20,16 @@ import com.google.common.base.Joiner;









import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, Fact> {










public class Fact implements FieldSensitiveFact<String, String, Fact> {





















 public final String baseValue;










 public final FieldReference[] accessPath;










 public final AccessPath<String> accessPath;










 










 public Fact(String name) {










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 ArrayList<FieldReference> accessPath = Lists.newArrayList();










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();










 baseValue = name.substring(0, firstSeparator);



......@@ -39,23 +40,25 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 String identifier = matcher.group(2);










 










 if(separator.equals(".")) {










 accessPath.add(new FieldReference.SpecificFieldReference(identifier));










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(identifier);










 } else {










 accessPath.add(new FieldReference.Any(identifier.split(",")));










 addedExclusions=true;










 accessPath = accessPath.appendExcludedFieldReference(identifier.split(","));










 }










 }










 this.accessPath = accessPath.toArray(new FieldReference[accessPath.size()]);










 this.accessPath = accessPath;










 }










 










 public Fact(String baseValue, FieldReference[] accessPath) {










 public Fact(String baseValue, AccessPath<String> accessPath) {










 this.baseValue = baseValue;










 this.accessPath = accessPath;










 }





















 










 @Override










 public String toString() {










 return "[Fact "+baseValue+(accessPath.length>0 ? "."+Joiner.on(".").join(accessPath) : "" )+"]";










 return "[Fact "+baseValue+(accessPath.isEmpty() ? "" : accessPath)+"]";










 }





















 @Override



......@@ -64,30 +67,26 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 }





















 @Override










 public FieldReference[] getAccessPath() {










 public AccessPath<String> getAccessPath() {










 return accessPath;










 }
































 @Override










 public void addNeighbor(FieldSensitiveFact<String, Fact> originalAbstraction) {










 public void addNeighbor(Fact originalAbstraction) {










 










 }
































 @Override










 public void setCallingContext(FieldSensitiveFact<String, Fact> callingContext) {










 public void setCallingContext(Fact callingContext) {










 










 }
































 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accessPath);










 result = prime * result










 + ((baseValue == null) ? 0 : baseValue.hashCode());










 result = prime * result + ((accessPath == null) ? 0 : accessPath.hashCode());










 result = prime * result + ((baseValue == null) ? 0 : baseValue.hashCode());










 return result;










 }














......@@ -97,10 +96,13 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 if (!(obj instanceof Fact))










 return false;










 Fact other = (Fact) obj;










 if (!Arrays.equals(accessPath, other.accessPath))










 if (accessPath == null) {










 if (other.accessPath != null)










 return false;










 } else if (!accessPath.equals(other.accessPath))










 return false;










 if (baseValue == null) {










 if (other.baseValue != null)



......@@ -110,11 +112,8 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 return true;










 }






















































 @Override










 public Fact cloneWithAccessPath(FieldReference... accessPath) {










 public Fact cloneWithAccessPath(AccessPath<String> accessPath) {










 return new Fact(baseValue, accessPath);










 }










 



......






......@@ -20,15 +20,16 @@ import com.google.common.base.Joiner;









import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, Fact> {










public class Fact implements FieldSensitiveFact<String, String, Fact> {





















 public final String baseValue;










 public final FieldReference[] accessPath;










 public final AccessPath<String> accessPath;










 










 public Fact(String name) {










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 ArrayList<FieldReference> accessPath = Lists.newArrayList();










 AccessPath<String> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();










 baseValue = name.substring(0, firstSeparator);



......@@ -39,23 +40,25 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 String identifier = matcher.group(2);










 










 if(separator.equals(".")) {










 accessPath.add(new FieldReference.SpecificFieldReference(identifier));










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(identifier);










 } else {










 accessPath.add(new FieldReference.Any(identifier.split(",")));










 addedExclusions=true;










 accessPath = accessPath.appendExcludedFieldReference(identifier.split(","));










 }










 }










 this.accessPath = accessPath.toArray(new FieldReference[accessPath.size()]);










 this.accessPath = accessPath;










 }










 










 public Fact(String baseValue, FieldReference[] accessPath) {










 public Fact(String baseValue, AccessPath<String> accessPath) {










 this.baseValue = baseValue;










 this.accessPath = accessPath;










 }





















 










 @Override










 public String toString() {










 return "[Fact "+baseValue+(accessPath.length>0 ? "."+Joiner.on(".").join(accessPath) : "" )+"]";










 return "[Fact "+baseValue+(accessPath.isEmpty() ? "" : accessPath)+"]";










 }





















 @Override



......@@ -64,30 +67,26 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 }





















 @Override










 public FieldReference[] getAccessPath() {










 public AccessPath<String> getAccessPath() {










 return accessPath;










 }
































 @Override










 public void addNeighbor(FieldSensitiveFact<String, Fact> originalAbstraction) {










 public void addNeighbor(Fact originalAbstraction) {










 










 }
































 @Override










 public void setCallingContext(FieldSensitiveFact<String, Fact> callingContext) {










 public void setCallingContext(Fact callingContext) {










 










 }
































 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + Arrays.hashCode(accessPath);










 result = prime * result










 + ((baseValue == null) ? 0 : baseValue.hashCode());










 result = prime * result + ((accessPath == null) ? 0 : accessPath.hashCode());










 result = prime * result + ((baseValue == null) ? 0 : baseValue.hashCode());










 return result;










 }














......@@ -97,10 +96,13 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 return true;










 if (obj == null)










 return false;










 if (getClass() != obj.getClass())










 if (!(obj instanceof Fact))










 return false;










 Fact other = (Fact) obj;










 if (!Arrays.equals(accessPath, other.accessPath))










 if (accessPath == null) {










 if (other.accessPath != null)










 return false;










 } else if (!accessPath.equals(other.accessPath))










 return false;










 if (baseValue == null) {










 if (other.baseValue != null)



......@@ -110,11 +112,8 @@ public class Fact implements FieldSensitiveFact<String, Fact> {









 return true;










 }






















































 @Override










 public Fact cloneWithAccessPath(FieldReference... accessPath) {










 public Fact cloneWithAccessPath(AccessPath<String> accessPath) {










 return new Fact(baseValue, accessPath);










 }










 



......


import com.google.common.collect.Lists;importcom.google.common.collect.Lists;public class Fact implements FieldSensitiveFact<String, Fact> {publicclassFactimplementsFieldSensitiveFact<String,Fact>{public class Fact implements FieldSensitiveFact<String, String, Fact> {publicclassFactimplementsFieldSensitiveFact<String,StringString,, Fact>{ public final String baseValue;publicfinalStringbaseValue; public final FieldReference[] accessPath;publicfinalFieldReferenceFieldReference[][]accessPath; public final AccessPath<String> accessPath;publicfinalAccessPathAccessPath<<StringString>>accessPath;  public Fact(String name) {publicFact(Stringname){ Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");Patternpattern=Pattern.compile("(\\.|\\^)([^\\.\\^]+)"); Matcher matcher = pattern.matcher(name);Matchermatcher=pattern.matcher(name); ArrayList<FieldReference> accessPath = Lists.newArrayList();ArrayList<FieldReference>accessPath=Lists.newArrayList(); AccessPath<String> accessPath = new AccessPath<>();AccessPath<String>accessPath=newAccessPath<>(); boolean addedExclusions = false;booleanaddedExclusions=false;  int firstSeparator = matcher.find() ? matcher.start() : name.length();intfirstSeparator=matcher.find()?matcher.start():name.length(); baseValue = name.substring(0, firstSeparator);baseValue=name.substring(0,firstSeparator); String identifier = matcher.group(2);Stringidentifier=matcher.group(2);  if(separator.equals(".")) {if(separator.equals(".")){ accessPath.add(new FieldReference.SpecificFieldReference(identifier));accessPath.add(newFieldReference.SpecificFieldReference(identifier)); if(addedExclusions)if(addedExclusions) throw new IllegalArgumentException("Access path contains field references after exclusions.");thrownewIllegalArgumentException("Access path contains field references after exclusions."); accessPath = accessPath.addFieldReference(identifier);accessPath=accessPath.addFieldReference(identifier); } else {}else{ accessPath.add(new FieldReference.Any(identifier.split(",")));accessPath.add(newFieldReference.Any(identifier.split(","))); addedExclusions=true;addedExclusions=true; accessPath = accessPath.appendExcludedFieldReference(identifier.split(","));accessPath=accessPath.appendExcludedFieldReference(identifier.split(",")); }} }} this.accessPath = accessPath.toArray(new FieldReference[accessPath.size()]);this.accessPath=accessPath..toArraytoArray((newnew FieldReferenceFieldReference[[accessPathaccessPath..sizesize()]);()]) this.accessPath = accessPath;this.accessPath=accessPath; }}  public Fact(String baseValue, FieldReference[] accessPath) {publicFact(StringbaseValue,FieldReferenceFieldReference[][]accessPath){ public Fact(String baseValue, AccessPath<String> accessPath) {publicFact(StringbaseValue,AccessPathAccessPath<<StringString>>accessPath){ this.baseValue = baseValue;this.baseValue=baseValue; this.accessPath = accessPath;this.accessPath=accessPath; }}  @Override@Override public String toString() {publicStringtoString(){ return "[Fact "+baseValue+(accessPath.length>0 ? "."+Joiner.on(".").join(accessPath) : "" )+"]";return"[Fact "+baseValue+(accessPath.lengthlength>>00 ?? ".""."++JoinerJoiner..onon(("."".").).joinjoin((accessPath) :: """" )+)"]"; return "[Fact "+baseValue+(accessPath.isEmpty() ? "" : accessPath)+"]";return"[Fact "+baseValue+(accessPath.isEmptyisEmpty()() ?? """" :: accessPath)+"]"; }} @Override@Override }} @Override@Override public FieldReference[] getAccessPath() {publicFieldReferenceFieldReference[][]getAccessPath(){ public AccessPath<String> getAccessPath() {publicAccessPathAccessPath<<StringString>>getAccessPath(){ return accessPath;returnaccessPath; }} @Override@Override public void addNeighbor(FieldSensitiveFact<String, Fact> originalAbstraction) {publicvoidaddNeighbor(FieldSensitiveFactieldSensitiveFact<<StringString,, FactFact>>originalAbstraction){ public void addNeighbor(Fact originalAbstraction) {publicvoidaddNeighbor(FactactoriginalAbstraction){  }} @Override@Override public void setCallingContext(FieldSensitiveFact<String, Fact> callingContext) {publicvoidsetCallingContext(FieldSensitiveFactieldSensitiveFact<<StringString,, FactFact>>callingContext){ public void setCallingContext(Fact callingContext) {publicvoidsetCallingContext(FactactcallingContext){  }} @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + Arrays.hashCode(accessPath);result=prime*result+Arrays.hashCode(accessPath); result = prime * resultresult=prime*result + ((baseValue == null) ? 0 : baseValue.hashCode());+((baseValue==null)?0:baseValue.hashCode()); result = prime * result + ((accessPath == null) ? 0 : accessPath.hashCode());result=prime*result+((accessPath==null)?0:accessPath.hashCode()); result = prime * result + ((baseValue == null) ? 0 : baseValue.hashCode());result=prime*result+((baseValue==null)?0:baseValue.hashCode()); return result;returnresult; }} return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (getClass() != obj.getClass())if(getClassgetClass()() !=!= objobj..getClassgetClass())( if (!(obj instanceof Fact))if(!(!(objobj instanceofinstanceof FactFact)) return false;returnfalse; Fact other = (Fact) obj;Factother=(Fact)obj; if (!Arrays.equals(accessPath, other.accessPath))if(!Arrays.equals(accessPath,other.accessPath)) if (accessPath == null) {if(accessPath==null){ if (other.accessPath != null)if(other.accessPath!=null) return false;returnfalse; } else if (!accessPath.equals(other.accessPath))}elseif(!accessPath.equals(other.accessPath)) return false;returnfalse; if (baseValue == null) {if(baseValue==null){ if (other.baseValue != null)if(other.baseValue!=null) return true;returntrue; }} @Override@Override public Fact cloneWithAccessPath(FieldReference... accessPath) {publicFactcloneWithAccessPath(FieldReferenceFieldReference......accessPath){ public Fact cloneWithAccessPath(AccessPath<String> accessPath) {publicFactcloneWithAccessPath(AccessPathAccessPath<<StringString>>accessPath){ return new Fact(baseValue, accessPath);returnnewFact(baseValue,accessPath); }} 








test/heros/alias/FieldSensitiveSolverTest.java








View file @ 1cd34e9e






......@@ -245,7 +245,7 @@ public class FieldSensitiveSolverTest {









 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2")));










 callSite("b").calls("bar", flow("1.f", "2"), flow("1.f^f", "2^f")));










 










 helper.method("bar",










 startPoints("c"),



......@@ -255,6 +255,44 @@ public class FieldSensitiveSolverTest {









 helper.runSolver(false, "a");










 }










 










 @Test










 public void pauseOnTransitiveExclusion() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("2", "3")));










 










 helper.method("xyz",










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", writeField("f"), "3^f")),










 normalStmt("e").succ("f")); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumePausedOnTransitiveExclusion() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("2", "3"), flow("2^f", "3^f")));










 










 helper.method("xyz",










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", writeField("f"), "3^f"), flow("3", "4")),










 callSite("e").calls("bar", flow("4", "2.g"), kill("3^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeEdgePausedOnOverwrittenField() {










 helper.method("foo",



......@@ -277,12 +315,12 @@ public class FieldSensitiveSolverTest {









 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")));










 callSite("e").calls("bar", flow("4", "2"), flow("4^f", "2^f")).retSite("f", kill("4"), kill("4^f") /*unwanted call2ret*/));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("3^f"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }



......












test/heros/alias/FieldSensitiveSolverTest.java








View file @ 1cd34e9e








test/heros/alias/FieldSensitiveSolverTest.java










View file @ 1cd34e9e


1cd34e9e



......@@ -245,7 +245,7 @@ public class FieldSensitiveSolverTest {









 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2")));










 callSite("b").calls("bar", flow("1.f", "2"), flow("1.f^f", "2^f")));










 










 helper.method("bar",










 startPoints("c"),



......@@ -255,6 +255,44 @@ public class FieldSensitiveSolverTest {









 helper.runSolver(false, "a");










 }










 










 @Test










 public void pauseOnTransitiveExclusion() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("2", "3")));










 










 helper.method("xyz",










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", writeField("f"), "3^f")),










 normalStmt("e").succ("f")); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumePausedOnTransitiveExclusion() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("2", "3"), flow("2^f", "3^f")));










 










 helper.method("xyz",










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", writeField("f"), "3^f"), flow("3", "4")),










 callSite("e").calls("bar", flow("4", "2.g"), kill("3^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeEdgePausedOnOverwrittenField() {










 helper.method("foo",



......@@ -277,12 +315,12 @@ public class FieldSensitiveSolverTest {









 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")));










 callSite("e").calls("bar", flow("4", "2"), flow("4^f", "2^f")).retSite("f", kill("4"), kill("4^f") /*unwanted call2ret*/));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("3^f"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }



......






......@@ -245,7 +245,7 @@ public class FieldSensitiveSolverTest {









 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2")));










 callSite("b").calls("bar", flow("1.f", "2"), flow("1.f^f", "2^f")));










 










 helper.method("bar",










 startPoints("c"),



......@@ -255,6 +255,44 @@ public class FieldSensitiveSolverTest {









 helper.runSolver(false, "a");










 }










 










 @Test










 public void pauseOnTransitiveExclusion() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("2", "3")));










 










 helper.method("xyz",










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", writeField("f"), "3^f")),










 normalStmt("e").succ("f")); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumePausedOnTransitiveExclusion() {










 helper.method("foo",










 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")));










 










 helper.method("bar",










 startPoints("c"),










 callSite("c").calls("xyz", flow("2", "3"), flow("2^f", "3^f")));










 










 helper.method("xyz",










 startPoints("d"),










 normalStmt("d").succ("e", flow("3", writeField("f"), "3^f"), flow("3", "4")),










 callSite("e").calls("bar", flow("4", "2.g"), kill("3^f"))); 










 










 helper.runSolver(false, "a");










 }










 










 @Test










 public void resumeEdgePausedOnOverwrittenField() {










 helper.method("foo",



......@@ -277,12 +315,12 @@ public class FieldSensitiveSolverTest {









 startPoints("a"),










 normalStmt("a").succ("b", flow("0", "1.f")),










 callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),










 callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")));










 callSite("e").calls("bar", flow("4", "2"), flow("4^f", "2^f")).retSite("f", kill("4"), kill("4^f") /*unwanted call2ret*/));










 










 helper.method("bar",










 startPoints("c"),










 normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); 










 exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("3^f"), kill("2^f"))); 










 










 helper.runSolver(false, "a");










 }



......


 helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1.f")),normalStmt("a").succ("b",flow("0","1.f")), callSite("b").calls("bar", flow("1.f", "2")));callSite("b").calls("bar",flow("1.f","2"))); callSite("b").calls("bar", flow("1.f", "2"), flow("1.f^f", "2^f")));callSite("b").calls("bar",flow("1.f","2"),, flowflow(("1.f^f""1.f^f",, "2^f""2^f")));)  helper.method("bar",helper.method("bar", startPoints("c"),startPoints("c"), helper.runSolver(false, "a");helper.runSolver(false,"a"); }}  @Test@Test public void pauseOnTransitiveExclusion() {publicvoidpauseOnTransitiveExclusion(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1.f")),normalStmt("a").succ("b",flow("0","1.f")), callSite("b").calls("bar", flow("1.f", "2.f")));callSite("b").calls("bar",flow("1.f","2.f")));  helper.method("bar",helper.method("bar", startPoints("c"),startPoints("c"), callSite("c").calls("xyz", flow("2", "3")));callSite("c").calls("xyz",flow("2","3")));  helper.method("xyz",helper.method("xyz", startPoints("d"),startPoints("d"), normalStmt("d").succ("e", flow("3", writeField("f"), "3^f")),normalStmt("d").succ("e",flow("3",writeField("f"),"3^f")), normalStmt("e").succ("f")); normalStmt("e").succ("f"));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }}  @Test@Test public void resumePausedOnTransitiveExclusion() {publicvoidresumePausedOnTransitiveExclusion(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1.f")),normalStmt("a").succ("b",flow("0","1.f")), callSite("b").calls("bar", flow("1.f", "2.f")));callSite("b").calls("bar",flow("1.f","2.f")));  helper.method("bar",helper.method("bar", startPoints("c"),startPoints("c"), callSite("c").calls("xyz", flow("2", "3"), flow("2^f", "3^f")));callSite("c").calls("xyz",flow("2","3"),flow("2^f","3^f")));  helper.method("xyz",helper.method("xyz", startPoints("d"),startPoints("d"), normalStmt("d").succ("e", flow("3", writeField("f"), "3^f"), flow("3", "4")),normalStmt("d").succ("e",flow("3",writeField("f"),"3^f"),flow("3","4")), callSite("e").calls("bar", flow("4", "2.g"), kill("3^f"))); callSite("e").calls("bar",flow("4","2.g"),kill("3^f")));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }}  @Test@Test public void resumeEdgePausedOnOverwrittenField() {publicvoidresumeEdgePausedOnOverwrittenField(){ helper.method("foo",helper.method("foo", startPoints("a"),startPoints("a"), normalStmt("a").succ("b", flow("0", "1.f")),normalStmt("a").succ("b",flow("0","1.f")), callSite("b").calls("bar", flow("1.f", "2.f")).retSite("e", kill("1.f")),callSite("b").calls("bar",flow("1.f","2.f")).retSite("e",kill("1.f")), callSite("e").calls("bar", flow("4", "2")).retSite("f", kill("4")));callSite("e").calls("bar",flow("4","2")).retSite("f",kill("4"))); callSite("e").calls("bar", flow("4", "2"), flow("4^f", "2^f")).retSite("f", kill("4"), kill("4^f") /*unwanted call2ret*/));callSite("e").calls("bar",flow("4","2"),, flowflow(("4^f""4^f",, "2^f""2^f")).)retSite("f",kill("4"),, killkill(("4^f""4^f")) /*unwanted call2ret*//*unwanted call2ret*/));  helper.method("bar",helper.method("bar", startPoints("c"),startPoints("c"), normalStmt("c").succ("d", flow("2", writeField("f"), "2^f"), flow("2", "3")),normalStmt("c").succ("d",flow("2",writeField("f"),"2^f"),flow("2","3")), exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("2^f"))); exitStmt("d").returns(over("b"),to("e"),flow("3.f","4")).returns(over("e"),to("f"),kill("3"),kill("2^f"))); exitStmt("d").returns(over("b"), to("e"), flow("3.f", "4")).returns(over("e"), to("f"), kill("3"), kill("3^f"), kill("2^f"))); exitStmt("d").returns(over("b"),to("e"),flow("3.f","4")).returns(over("e"),to("f"),kill("3"),killkill(("3^f""3^f"),), kill("2^f")));  helper.runSolver(false, "a");helper.runSolver(false,"a"); }}








test/heros/alias/TestHelper.java








View file @ 1cd34e9e






......@@ -12,6 +12,7 @@ package heros.alias;




















import static org.junit.Assert.assertTrue;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.FlowFunction.Constraint;










import heros.alias.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.solver.IFDSSolver;



......@@ -89,22 +90,22 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static Pair<String, String> readField(String fieldName) {










 return new Pair<String, String>(fieldName, null);










 public static Constraint<String> readField(String fieldName) {










 return new FlowFunction.ReadFieldConstraint<String>(fieldName);










 }










 










 public static Pair<String, String> writeField(String fieldName) {










 return new Pair<String, String>(null, fieldName);










 public static Constraint<String> writeField(String fieldName) {










 return new FlowFunction.WriteFieldConstraint<String>(fieldName);










 }










 










 public static ExpectedFlowFunction flow(String source, Pair<String, String> fieldAccess, String... targets) {










 return flow(1, source, fieldAccess, targets);










 public static ExpectedFlowFunction flow(String source, Constraint<String> constraint, String... targets) {










 return flow(1, source, constraint, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Pair<String, String> fieldAccess, String... targets) {










 AnnotatedFact<Fact>[] targetFacts = new AnnotatedFact[targets.length];










 public static ExpectedFlowFunction flow(int times, String source, Constraint<String> constraint, String... targets) {










 AnnotatedFact<String, Fact>[] targetFacts = new AnnotatedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new AnnotatedFact<Fact>(new Fact(targets[i]), fieldAccess.getO1(), fieldAccess.getO2());










 targetFacts[i] = new AnnotatedFact<String, Fact>(new Fact(targets[i]), constraint);










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 }



......@@ -114,7 +115,7 @@ public class TestHelper {









 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new Pair<String, String>(null, null), targets);










 return flow(times, source, null, targets);










 }










 










 public static int times(int times) {



......@@ -301,11 +302,11 @@ public class TestHelper {









 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final AnnotatedFact<Fact>[] targets;










 public final AnnotatedFact<String, Fact>[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, AnnotatedFact<Fact>... targets) {










 public ExpectedFlowFunction(int times, Fact source, AnnotatedFact<String, Fact>... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;



......@@ -437,11 +438,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, Fact, Method>() {










 public FlowFunctions<Statement, String, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, String, Fact, Method>() {





















 @Override










 public FlowFunction<Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 public FlowFunction<String, Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -453,7 +454,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 public FlowFunction<String, Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr) && edge.succUnit.equals(succ)) {










 return createFlowFunction(edge);



......@@ -463,7 +464,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 public FlowFunction<String, Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -473,7 +474,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 public FlowFunction<String, Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -482,11 +483,11 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<Fact>() {










 private FlowFunction<String, Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<String, Fact>() {










 @Override










 public Set<AnnotatedFact<Fact>> computeTargets(Fact source) {










 Set<AnnotatedFact<Fact>> result = Sets.newHashSet();










 public Set<AnnotatedFact<String, Fact>> computeTargets(Fact source) {










 Set<AnnotatedFact<String, Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {



......@@ -509,17 +510,17 @@ public class TestHelper {









 }





















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 FieldSensitiveIFDSSolver<Statement, String,Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement, String,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 FieldSensitiveIFDSSolver<Statement, String, String, Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement,String,  String,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 solver.solve();










 assertAllFlowFunctionsUsed();










 }










 










 










 private IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 private IFDSTabulationProblem<Statement, String, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, Method> icfg = buildIcfg();










 final FlowFunctions<Statement, Fact, Method> flowFunctions = flowFunctions();










 final FlowFunctions<Statement, String, Fact, Method> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>() {










 return new IFDSTabulationProblem<Statement,String,  Fact, Method, InterproceduralCFG<Statement, Method>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -542,7 +543,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 public FlowFunctions<Statement,String,  Fact, Method> flowFunctions() {










 return flowFunctions;










 }














......












test/heros/alias/TestHelper.java








View file @ 1cd34e9e








test/heros/alias/TestHelper.java










View file @ 1cd34e9e


1cd34e9e



......@@ -12,6 +12,7 @@ package heros.alias;




















import static org.junit.Assert.assertTrue;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.FlowFunction.Constraint;










import heros.alias.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.solver.IFDSSolver;



......@@ -89,22 +90,22 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static Pair<String, String> readField(String fieldName) {










 return new Pair<String, String>(fieldName, null);










 public static Constraint<String> readField(String fieldName) {










 return new FlowFunction.ReadFieldConstraint<String>(fieldName);










 }










 










 public static Pair<String, String> writeField(String fieldName) {










 return new Pair<String, String>(null, fieldName);










 public static Constraint<String> writeField(String fieldName) {










 return new FlowFunction.WriteFieldConstraint<String>(fieldName);










 }










 










 public static ExpectedFlowFunction flow(String source, Pair<String, String> fieldAccess, String... targets) {










 return flow(1, source, fieldAccess, targets);










 public static ExpectedFlowFunction flow(String source, Constraint<String> constraint, String... targets) {










 return flow(1, source, constraint, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Pair<String, String> fieldAccess, String... targets) {










 AnnotatedFact<Fact>[] targetFacts = new AnnotatedFact[targets.length];










 public static ExpectedFlowFunction flow(int times, String source, Constraint<String> constraint, String... targets) {










 AnnotatedFact<String, Fact>[] targetFacts = new AnnotatedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new AnnotatedFact<Fact>(new Fact(targets[i]), fieldAccess.getO1(), fieldAccess.getO2());










 targetFacts[i] = new AnnotatedFact<String, Fact>(new Fact(targets[i]), constraint);










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 }



......@@ -114,7 +115,7 @@ public class TestHelper {









 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new Pair<String, String>(null, null), targets);










 return flow(times, source, null, targets);










 }










 










 public static int times(int times) {



......@@ -301,11 +302,11 @@ public class TestHelper {









 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final AnnotatedFact<Fact>[] targets;










 public final AnnotatedFact<String, Fact>[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, AnnotatedFact<Fact>... targets) {










 public ExpectedFlowFunction(int times, Fact source, AnnotatedFact<String, Fact>... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;



......@@ -437,11 +438,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, Fact, Method>() {










 public FlowFunctions<Statement, String, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, String, Fact, Method>() {





















 @Override










 public FlowFunction<Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 public FlowFunction<String, Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -453,7 +454,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 public FlowFunction<String, Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr) && edge.succUnit.equals(succ)) {










 return createFlowFunction(edge);



......@@ -463,7 +464,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 public FlowFunction<String, Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -473,7 +474,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 public FlowFunction<String, Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -482,11 +483,11 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<Fact>() {










 private FlowFunction<String, Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<String, Fact>() {










 @Override










 public Set<AnnotatedFact<Fact>> computeTargets(Fact source) {










 Set<AnnotatedFact<Fact>> result = Sets.newHashSet();










 public Set<AnnotatedFact<String, Fact>> computeTargets(Fact source) {










 Set<AnnotatedFact<String, Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {



......@@ -509,17 +510,17 @@ public class TestHelper {









 }





















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 FieldSensitiveIFDSSolver<Statement, String,Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement, String,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 FieldSensitiveIFDSSolver<Statement, String, String, Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement,String,  String,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 solver.solve();










 assertAllFlowFunctionsUsed();










 }










 










 










 private IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 private IFDSTabulationProblem<Statement, String, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, Method> icfg = buildIcfg();










 final FlowFunctions<Statement, Fact, Method> flowFunctions = flowFunctions();










 final FlowFunctions<Statement, String, Fact, Method> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>() {










 return new IFDSTabulationProblem<Statement,String,  Fact, Method, InterproceduralCFG<Statement, Method>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -542,7 +543,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 public FlowFunctions<Statement,String,  Fact, Method> flowFunctions() {










 return flowFunctions;










 }














......






......@@ -12,6 +12,7 @@ package heros.alias;




















import static org.junit.Assert.assertTrue;










import heros.alias.FlowFunction.AnnotatedFact;










import heros.alias.FlowFunction.Constraint;










import heros.alias.IFDSTabulationProblem;










import heros.InterproceduralCFG;










import heros.solver.IFDSSolver;



......@@ -89,22 +90,22 @@ public class TestHelper {









 return new ExpectedFlowFunction(times, new Fact(source));










 }





















 public static Pair<String, String> readField(String fieldName) {










 return new Pair<String, String>(fieldName, null);










 public static Constraint<String> readField(String fieldName) {










 return new FlowFunction.ReadFieldConstraint<String>(fieldName);










 }










 










 public static Pair<String, String> writeField(String fieldName) {










 return new Pair<String, String>(null, fieldName);










 public static Constraint<String> writeField(String fieldName) {










 return new FlowFunction.WriteFieldConstraint<String>(fieldName);










 }










 










 public static ExpectedFlowFunction flow(String source, Pair<String, String> fieldAccess, String... targets) {










 return flow(1, source, fieldAccess, targets);










 public static ExpectedFlowFunction flow(String source, Constraint<String> constraint, String... targets) {










 return flow(1, source, constraint, targets);










 }










 










 public static ExpectedFlowFunction flow(int times, String source, Pair<String, String> fieldAccess, String... targets) {










 AnnotatedFact<Fact>[] targetFacts = new AnnotatedFact[targets.length];










 public static ExpectedFlowFunction flow(int times, String source, Constraint<String> constraint, String... targets) {










 AnnotatedFact<String, Fact>[] targetFacts = new AnnotatedFact[targets.length];










 for(int i=0; i<targets.length; i++) {










 targetFacts[i] = new AnnotatedFact<Fact>(new Fact(targets[i]), fieldAccess.getO1(), fieldAccess.getO2());










 targetFacts[i] = new AnnotatedFact<String, Fact>(new Fact(targets[i]), constraint);










 }










 return new ExpectedFlowFunction(times, new Fact(source), targetFacts);










 }



......@@ -114,7 +115,7 @@ public class TestHelper {









 }










 










 public static ExpectedFlowFunction flow(int times, String source, String... targets) {










 return flow(times, source, new Pair<String, String>(null, null), targets);










 return flow(times, source, null, targets);










 }










 










 public static int times(int times) {



......@@ -301,11 +302,11 @@ public class TestHelper {









 public static class ExpectedFlowFunction {





















 public final Fact source;










 public final AnnotatedFact<Fact>[] targets;










 public final AnnotatedFact<String, Fact>[] targets;










 public Edge edge;










 private int times;





















 public ExpectedFlowFunction(int times, Fact source, AnnotatedFact<Fact>... targets) {










 public ExpectedFlowFunction(int times, Fact source, AnnotatedFact<String, Fact>... targets) {










 this.times = times;










 this.source = source;










 this.targets = targets;



......@@ -437,11 +438,11 @@ public class TestHelper {









 return a.equals(b);










 }





















 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, Fact, Method>() {










 public FlowFunctions<Statement, String, Fact, Method> flowFunctions() {










 return new FlowFunctions<Statement, String, Fact, Method>() {





















 @Override










 public FlowFunction<Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 public FlowFunction<String, Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {










 for (final ReturnEdge edge : returnEdges) {










 if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)










 && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {



......@@ -453,7 +454,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 public FlowFunction<String, Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {










 for (final NormalEdge edge : normalEdges) {










 if (edge.unit.equals(curr) && edge.succUnit.equals(succ)) {










 return createFlowFunction(edge);



......@@ -463,7 +464,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 public FlowFunction<String, Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {










 for (final Call2ReturnEdge edge : call2retEdges) {










 if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {










 return createFlowFunction(edge);



......@@ -473,7 +474,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunction<Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 public FlowFunction<String, Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {










 for (final CallEdge edge : callEdges) {










 if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {










 return createFlowFunction(edge);



......@@ -482,11 +483,11 @@ public class TestHelper {









 throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));










 }





















 private FlowFunction<Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<Fact>() {










 private FlowFunction<String, Fact> createFlowFunction(final Edge edge) {










 return new FlowFunction<String, Fact>() {










 @Override










 public Set<AnnotatedFact<Fact>> computeTargets(Fact source) {










 Set<AnnotatedFact<Fact>> result = Sets.newHashSet();










 public Set<AnnotatedFact<String, Fact>> computeTargets(Fact source) {










 Set<AnnotatedFact<String, Fact>> result = Sets.newHashSet();










 boolean found = false;










 for (ExpectedFlowFunction ff : edge.flowFunctions) {










 if (ff.source.equals(source)) {



......@@ -509,17 +510,17 @@ public class TestHelper {









 }





















 public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {










 FieldSensitiveIFDSSolver<Statement, String,Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement, String,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 FieldSensitiveIFDSSolver<Statement, String, String, Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement,String,  String,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));










 solver.solve();










 assertAllFlowFunctionsUsed();










 }










 










 










 private IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 private IFDSTabulationProblem<Statement, String, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {










 final InterproceduralCFG<Statement, Method> icfg = buildIcfg();










 final FlowFunctions<Statement, Fact, Method> flowFunctions = flowFunctions();










 final FlowFunctions<Statement, String, Fact, Method> flowFunctions = flowFunctions();










 










 return new IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>() {










 return new IFDSTabulationProblem<Statement,String,  Fact, Method, InterproceduralCFG<Statement, Method>>() {





















 @Override










 public boolean followReturnsPastSeeds() {



......@@ -542,7 +543,7 @@ public class TestHelper {









 }





















 @Override










 public FlowFunctions<Statement, Fact, Method> flowFunctions() {










 public FlowFunctions<Statement,String,  Fact, Method> flowFunctions() {










 return flowFunctions;










 }














......


import static org.junit.Assert.assertTrue;importstaticorg.junit.Assert.assertTrue;import heros.alias.FlowFunction.AnnotatedFact;importheros.alias.FlowFunction.AnnotatedFact;import heros.alias.FlowFunction.Constraint;importheros.alias.FlowFunction.Constraint;import heros.alias.IFDSTabulationProblem;importheros.alias.IFDSTabulationProblem;import heros.InterproceduralCFG;importheros.InterproceduralCFG;import heros.solver.IFDSSolver;importheros.solver.IFDSSolver; return new ExpectedFlowFunction(times, new Fact(source));returnnewExpectedFlowFunction(times,newFact(source)); }} public static Pair<String, String> readField(String fieldName) {publicstaticPairPair<<StringSg,, String>readField(StringfieldName){ return new Pair<String, String>(fieldName, null);returnnewPairPair<<StringSg,, String>(fieldName,, nullnull); public static Constraint<String> readField(String fieldName) {publicstaticConstraintConsat<<String>readField(StringfieldName){ return new FlowFunction.ReadFieldConstraint<String>(fieldName);returnnewFlowFunctionFlowFunction..ReadFieldConstraintReadFieldConsat<<String>(fieldName); }}  public static Pair<String, String> writeField(String fieldName) {publicstaticPairPair<<StringSg,, String>writeField(StringfieldName){ return new Pair<String, String>(null, fieldName);returnnewPairPair<<StringSg,, String>(nullnull,, fieldName); public static Constraint<String> writeField(String fieldName) {publicstaticConstraintConsat<<String>writeField(StringfieldName){ return new FlowFunction.WriteFieldConstraint<String>(fieldName);returnnewFlowFunctionFlowFunction..WriteFieldConstraintWriteFieldConsat<<String>(fieldName); }}  public static ExpectedFlowFunction flow(String source, Pair<String, String> fieldAccess, String... targets) {publicstaticExpectedFlowFunctionflow(Stringsource,PairPair<String,, StringSg>> fieldAccessfieldAccess,String...targets){ return flow(1, source, fieldAccess, targets);returnflow(1,source,fieldAccessfieldAccess,targets); public static ExpectedFlowFunction flow(String source, Constraint<String> constraint, String... targets) {publicstaticExpectedFlowFunctionflow(Stringsource,ConstraintConstraint<String>> constraintconsat,String...targets){ return flow(1, source, constraint, targets);returnflow(1,source,constraintconstraint,targets); }}  public static ExpectedFlowFunction flow(int times, String source, Pair<String, String> fieldAccess, String... targets) {publicstaticExpectedFlowFunctionflow(inttimes,Stringsource,PairPair<String,, StringSg>> fieldAccessfieldAccess,String...targets){ AnnotatedFact<Fact>[] targetFacts = new AnnotatedFact[targets.length];AnnotatedFact<Fact>[]targetFacts=newAnnotatedFact[targets.length]; public static ExpectedFlowFunction flow(int times, String source, Constraint<String> constraint, String... targets) {publicstaticExpectedFlowFunctionflow(inttimes,Stringsource,ConstraintConstraint<String>> constraintconsat,String...targets){ AnnotatedFact<String, Fact>[] targetFacts = new AnnotatedFact[targets.length];AnnotatedFact<StringString,, Fact>[]targetFacts=newAnnotatedFact[targets.length]; for(int i=0; i<targets.length; i++) {for(inti=0;i<targets.length;i++){ targetFacts[i] = new AnnotatedFact<Fact>(new Fact(targets[i]), fieldAccess.getO1(), fieldAccess.getO2());targetFacts[i]=newAnnotatedFact<Fact>(newFact(targets[i]),fieldAccessfieldAccess..getO1getO1(),(), fieldAccessfieldAccess..getO2getO2());() targetFacts[i] = new AnnotatedFact<String, Fact>(new Fact(targets[i]), constraint);targetFacts[i]=newAnnotatedFact<StringString,, Fact>(newFact(targets[i]),constraintconstraint); }} return new ExpectedFlowFunction(times, new Fact(source), targetFacts);returnnewExpectedFlowFunction(times,newFact(source),targetFacts); }} }}  public static ExpectedFlowFunction flow(int times, String source, String... targets) {publicstaticExpectedFlowFunctionflow(inttimes,Stringsource,String...targets){ return flow(times, source, new Pair<String, String>(null, null), targets);returnflow(times,source,newew PairPair<<StringString,, StringString>(>(nullnull,, nullnull),)targets); return flow(times, source, null, targets);returnflow(times,source,nullull,targets); }}  public static int times(int times) {publicstaticinttimes(inttimes){ public static class ExpectedFlowFunction {publicstaticclassExpectedFlowFunction{ public final Fact source;publicfinalFactsource; public final AnnotatedFact<Fact>[] targets;publicfinalAnnotatedFact<Fact>[]targets; public final AnnotatedFact<String, Fact>[] targets;publicfinalAnnotatedFact<StringString,, Fact>[]targets; public Edge edge;publicEdgeedge; private int times;privateinttimes; public ExpectedFlowFunction(int times, Fact source, AnnotatedFact<Fact>... targets) {publicExpectedFlowFunction(inttimes,Factsource,AnnotatedFact<Fact>...targets){ public ExpectedFlowFunction(int times, Fact source, AnnotatedFact<String, Fact>... targets) {publicExpectedFlowFunction(inttimes,Factsource,AnnotatedFact<StringString,, Fact>...targets){ this.times = times;this.times=times; this.source = source;this.source=source; this.targets = targets;this.targets=targets; return a.equals(b);returna.equals(b); }} public FlowFunctions<Statement, Fact, Method> flowFunctions() {publicFlowFunctions<Statement,Fact,Method>flowFunctions(){ return new FlowFunctions<Statement, Fact, Method>() {returnnewFlowFunctions<Statement,Fact,Method>(){ public FlowFunctions<Statement, String, Fact, Method> flowFunctions() {publicFlowFunctions<Statement,StringString,, Fact,Method>flowFunctions(){ return new FlowFunctions<Statement, String, Fact, Method>() {returnnewFlowFunctions<Statement,StringString,, Fact,Method>(){ @Override@Override public FlowFunction<Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {publicFlowFunction<Fact>getReturnFlowFunction(StatementcallSite,MethodcalleeMethod,StatementexitStmt,StatementreturnSite){ public FlowFunction<String, Fact> getReturnFlowFunction(Statement callSite, Method calleeMethod, Statement exitStmt, Statement returnSite) {publicFlowFunction<StringString,, Fact>getReturnFlowFunction(StatementcallSite,MethodcalleeMethod,StatementexitStmt,StatementreturnSite){ for (final ReturnEdge edge : returnEdges) {for(finalReturnEdgeedge:returnEdges){ if (nullAwareEquals(callSite, edge.callSite) && edge.calleeMethod.equals(calleeMethod)if(nullAwareEquals(callSite,edge.callSite)&&edge.calleeMethod.equals(calleeMethod) && edge.exitStmt.equals(exitStmt) && nullAwareEquals(edge.returnSite, returnSite)) {&&edge.exitStmt.equals(exitStmt)&&nullAwareEquals(edge.returnSite,returnSite)){ }} @Override@Override public FlowFunction<Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {publicFlowFunction<Fact>getNormalFlowFunction(finalStatementcurr,finalStatementsucc){ public FlowFunction<String, Fact> getNormalFlowFunction(final Statement curr, final Statement succ) {publicFlowFunction<StringString,, Fact>getNormalFlowFunction(finalStatementcurr,finalStatementsucc){ for (final NormalEdge edge : normalEdges) {for(finalNormalEdgeedge:normalEdges){ if (edge.unit.equals(curr) && edge.succUnit.equals(succ)) {if(edge.unit.equals(curr)&&edge.succUnit.equals(succ)){ return createFlowFunction(edge);returncreateFlowFunction(edge); }} @Override@Override public FlowFunction<Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {publicFlowFunction<Fact>getCallToReturnFlowFunction(StatementcallSite,StatementreturnSite){ public FlowFunction<String, Fact> getCallToReturnFlowFunction(Statement callSite, Statement returnSite) {publicFlowFunction<StringString,, Fact>getCallToReturnFlowFunction(StatementcallSite,StatementreturnSite){ for (final Call2ReturnEdge edge : call2retEdges) {for(finalCall2ReturnEdgeedge:call2retEdges){ if (edge.callSite.equals(callSite) && edge.returnSite.equals(returnSite)) {if(edge.callSite.equals(callSite)&&edge.returnSite.equals(returnSite)){ return createFlowFunction(edge);returncreateFlowFunction(edge); }} @Override@Override public FlowFunction<Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {publicFlowFunction<Fact>getCallFlowFunction(StatementcallStmt,MethoddestinationMethod){ public FlowFunction<String, Fact> getCallFlowFunction(Statement callStmt, Method destinationMethod) {publicFlowFunction<StringString,, Fact>getCallFlowFunction(StatementcallStmt,MethoddestinationMethod){ for (final CallEdge edge : callEdges) {for(finalCallEdgeedge:callEdges){ if (edge.callSite.equals(callStmt) && edge.destinationMethod.equals(destinationMethod)) {if(edge.callSite.equals(callStmt)&&edge.destinationMethod.equals(destinationMethod)){ return createFlowFunction(edge);returncreateFlowFunction(edge); throw new AssertionError(String.format("No Flow Function expected for call %s -> %s", callStmt, destinationMethod));thrownewAssertionError(String.format("No Flow Function expected for call %s -> %s",callStmt,destinationMethod)); }} private FlowFunction<Fact> createFlowFunction(final Edge edge) {privateFlowFunction<Fact>createFlowFunction(finalEdgeedge){ return new FlowFunction<Fact>() {returnnewFlowFunction<Fact>(){ private FlowFunction<String, Fact> createFlowFunction(final Edge edge) {privateFlowFunction<StringString,, Fact>createFlowFunction(finalEdgeedge){ return new FlowFunction<String, Fact>() {returnnewFlowFunction<StringString,, Fact>(){ @Override@Override public Set<AnnotatedFact<Fact>> computeTargets(Fact source) {publicSet<AnnotatedFact<Fact>>computeTargets(Factsource){ Set<AnnotatedFact<Fact>> result = Sets.newHashSet();Set<AnnotatedFact<Fact>>result=Sets.newHashSet(); public Set<AnnotatedFact<String, Fact>> computeTargets(Fact source) {publicSet<AnnotatedFact<StringString,, Fact>>computeTargets(Factsource){ Set<AnnotatedFact<String, Fact>> result = Sets.newHashSet();Set<AnnotatedFact<StringString,, Fact>>result=Sets.newHashSet(); boolean found = false;booleanfound=false; for (ExpectedFlowFunction ff : edge.flowFunctions) {for(ExpectedFlowFunctionff:edge.flowFunctions){ if (ff.source.equals(source)) {if(ff.source.equals(source)){ }} public void runSolver(final boolean followReturnsPastSeeds, final String...initialSeeds) {publicvoidrunSolver(finalbooleanfollowReturnsPastSeeds,finalString...initialSeeds){ FieldSensitiveIFDSSolver<Statement, String,Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement, String,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));FieldSensitiveIFDSSolver<Statement,String,Fact,Method,InterproceduralCFG<Statement,Method>>solver=newFieldSensitiveIFDSSolver<Statement,String,Fact,Method,InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds,initialSeeds)); FieldSensitiveIFDSSolver<Statement, String, String, Fact, Method, InterproceduralCFG<Statement,Method>> solver = new FieldSensitiveIFDSSolver<Statement,String,  String,Fact, Method, InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds, initialSeeds));FieldSensitiveIFDSSolver<Statement,String, StringString,, Fact,Method,InterproceduralCFG<Statement,Method>>solver=newFieldSensitiveIFDSSolver<Statement,StringString,, String,Fact,Method,InterproceduralCFG<Statement,Method>>(createTabulationProblem(followReturnsPastSeeds,initialSeeds)); solver.solve();solver.solve(); assertAllFlowFunctionsUsed();assertAllFlowFunctionsUsed(); }}   private IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {privateIFDSTabulationProblem<Statement,Fact,Method,InterproceduralCFG<Statement,Method>>createTabulationProblem(finalbooleanfollowReturnsPastSeeds,finalString[]initialSeeds){ private IFDSTabulationProblem<Statement, String, Fact, Method, InterproceduralCFG<Statement, Method>> createTabulationProblem(final boolean followReturnsPastSeeds, final String[] initialSeeds) {privateIFDSTabulationProblem<Statement,StringString,, Fact,Method,InterproceduralCFG<Statement,Method>>createTabulationProblem(finalbooleanfollowReturnsPastSeeds,finalString[]initialSeeds){ final InterproceduralCFG<Statement, Method> icfg = buildIcfg();finalInterproceduralCFG<Statement,Method>icfg=buildIcfg(); final FlowFunctions<Statement, Fact, Method> flowFunctions = flowFunctions();finalFlowFunctions<Statement,Fact,Method>flowFunctions=flowFunctions(); final FlowFunctions<Statement, String, Fact, Method> flowFunctions = flowFunctions();finalFlowFunctions<Statement,StringString,, Fact,Method>flowFunctions=flowFunctions();  return new IFDSTabulationProblem<Statement, Fact, Method, InterproceduralCFG<Statement, Method>>() {returnnewIFDSTabulationProblem<Statement,Fact,Method,InterproceduralCFG<Statement,Method>>(){ return new IFDSTabulationProblem<Statement,String,  Fact, Method, InterproceduralCFG<Statement, Method>>() {returnnewIFDSTabulationProblem<Statement,StringString,, Fact,Method,InterproceduralCFG<Statement,Method>>(){ @Override@Override public boolean followReturnsPastSeeds() {publicbooleanfollowReturnsPastSeeds(){ }} @Override@Override public FlowFunctions<Statement, Fact, Method> flowFunctions() {publicFlowFunctions<Statement,Fact,Method>flowFunctions(){ public FlowFunctions<Statement,String,  Fact, Method> flowFunctions() {publicFlowFunctions<Statement,StringString,, Fact,Method>flowFunctions(){ return flowFunctions;returnflowFunctions; }}









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel







Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Write




Preview

























Write



Preview

















































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel












Supports Markdown






0%










Try again


or


attach a new file


.



Cancel




Supports Markdown





0%










Try again


or


attach a new file


.



Cancel






0%


0%







Try again


or


attach a new file


.




Try again

attach a new file

Cancel



You are about to add

0
people

to the discussion. Proceed with caution.



You are about to add

0
people

to the discussion. Proceed with caution.
0

Finish editing this message first!



Cancel



Finish editing this message first!

Cancel


Please register or sign in to comment






