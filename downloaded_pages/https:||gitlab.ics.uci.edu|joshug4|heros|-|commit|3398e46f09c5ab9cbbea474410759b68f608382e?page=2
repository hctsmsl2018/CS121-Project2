



GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu








GitLab


















Projects
Groups
Snippets


















/












Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Toggle navigation

Menu






GitLab


















Projects
Groups
Snippets



GitLab






GitLab









Projects
Groups
Snippets






Projects
Groups
Snippets















/




















/














/










Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab







Sign in





Help









Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help





Help


Support


Community forum



Keyboard shortcuts
?




Submit feedback


Contribute to GitLab





Help

Support

Community forum


Keyboard shortcuts
?


Submit feedback

Contribute to GitLab



Sign in


Sign in
Toggle navigation
Menu

Menu




H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar








Open sidebar



Joshua Garcia heros
Commits

3398e46f















Commit
3398e46f


authored
Feb 25, 2015
by


Johannes Lerch



Browse files




rewrite of ifds solver







parent
55cdd2d8













Changes
45




Expand all
Hide whitespace changes

Inline
Side-by-side















src/heros/alias/InterestCallback.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public interface InterestCallback<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver);










 










//	void partiallyResolved(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver, AccessPath<Field> resolvedAccPath);










 










 void canBeResolvedEmpty();










}














src/heros/alias/JsonArray.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.List;





















import com.google.common.collect.Lists;





















class JsonArray {










 










 private List<String> items = Lists.newLinkedList();










 










 public void add(String item) {










 items.add(item);










 }





















 public void write(StringBuilder builder, int tabs) {










 builder.append("[\n");










 for(String item: items) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+item+"\",\n");










 }










 TestDebugger.tabs(tabs, builder); builder.append("]");










 }










}




\ No newline at end of file














src/heros/alias/JsonDocument.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Map;










import java.util.Map.Entry;





















import com.google.common.collect.Maps;





















class JsonDocument {










 










 private CacheMap<String, JsonDocument> documents = new CacheMap<String, JsonDocument>() {










 @Override










 protected JsonDocument createItem(String key) {










 return new JsonDocument();










 }










 };










 private CacheMap<String, JsonArray> arrays = new CacheMap<String, JsonArray>() {










 @Override










 protected JsonArray createItem(String key) {










 return new JsonArray();










 }










 };










 private Map<String, String> keyValuePairs = Maps.newHashMap();










 










 public JsonDocument doc(String key) {










 return documents.getOrCreate(key);










 }










 










 public JsonArray array(String key) {










 return arrays.getOrCreate(key);










 }










 










 public void keyValue(String key, String value) {










 keyValuePairs.put(key, value);










 }










 










 public void write(StringBuilder builder, int tabs) {










 builder.append("{\n");










 










 for(Entry<String, String> entry : keyValuePairs.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n");










 }










 










 for(Entry<String, JsonArray> entry : arrays.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");





















 }










 










 for(Entry<String, JsonDocument> entry : documents.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");










 }










 










 TestDebugger.tabs(tabs, builder); builder.append("}");










 }





















}




\ No newline at end of file














src/heros/alias/MethodAnalyzer.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;
































public class MethodAnalyzer<Field extends AccessPath.FieldRef<Field>,










 Fact, 










 Stmt, 










 Method> {





















 private Method method;










 private CacheMap<Fact, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> perSourceAnalyzer = 










 new CacheMap<Fact, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>>() {










 @Override










 protected PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> createItem(Fact key) {










 return new PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>(method, key, context);










 }










 };










 private Context<Field, Fact, Stmt, Method> context;










 










 MethodAnalyzer(Method method, Context<Field, Fact, Stmt, Method> context) {










 this.method = method;










 this.context = context;










 }










 










 public void addIncomingEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact = incEdge.getCalleeSourceFact();










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer = perSourceAnalyzer.getOrCreate(calleeSourceFact.getFact());










 analyzer.bootstrapAtMethodStartPoints();










 analyzer.addIncomingEdge(incEdge);










 }





















 public void addInitialSeed(Stmt startPoint, Fact val) {










 perSourceAnalyzer.getOrCreate(val).addInitialSeed(startPoint);










 }










 










 public void addUnbalancedReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> target) {










 perSourceAnalyzer.getOrCreate(context.zeroValue).scheduleUnbalancedReturnEdgeTo(target);










 }










}














src/heros/alias/PerAccessPathMethodAnalyzer.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.ConstrainedFact;





















import java.io.FileWriter;










import java.io.IOException;










import java.util.Collection;










import java.util.List;










import java.util.Map;










import java.util.Set;





















import org.slf4j.Logger;










import org.slf4j.LoggerFactory;





















import com.google.common.collect.Lists;










import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class PerAccessPathMethodAnalyzer<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 protected static final Logger logger = LoggerFactory.getLogger(PerAccessPathMethodAnalyzer.class);










 private Fact sourceFact;










 private final AccessPath<Field> accessPath;










 private Map<WrappedFactAtStatement<Field,Fact, Stmt, Method>, WrappedFactAtStatement<Field,Fact, Stmt, Method>> reachableStatements = Maps.newHashMap();










 private List<WrappedFactAtStatement<Field, Fact, Stmt, Method>> summaries = Lists.newLinkedList();










 private Context<Field, Fact, Stmt, Method> context;










 private Method method;










 private Set<IncomingEdge<Field, Fact, Stmt, Method>> incomingEdges = Sets.newHashSet();










 private Map<AccessPath<Field>, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> nestedAnalyzers = Maps.newHashMap();










 private boolean bootstrapped = false;










 private CacheMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field, Fact, Stmt, Method>> returnSiteResolvers = new CacheMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ReturnSiteResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ReturnSiteResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private CacheMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> ctrFlowJoinResolvers = new CacheMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ControlFlowJoinResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ControlFlowJoinResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private CallEdgeResolver<Field, Fact, Stmt, Method> callEdgeResolver;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> parent;





















 public PerAccessPathMethodAnalyzer(Method method, Fact sourceFact, Context<Field, Fact, Stmt, Method> context) {










 this(method, sourceFact, context, new AccessPath<Field>(), null);










 }










 










 private PerAccessPathMethodAnalyzer(Method method, Fact sourceFact, Context<Field, Fact, Stmt, Method> context, AccessPath<Field> accPath, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> parent) {










 if(method == null)










 throw new IllegalArgumentException("Method must be not null");










 this.parent = parent;










 this.method = method;










 this.sourceFact = sourceFact;










 this.accessPath = accPath;










 this.context = context;










 this.callEdgeResolver = isZeroSource() ? new ZeroCallEdgeResolver<>(this, context.zeroHandler) : new CallEdgeResolver<>(this);










 log("initialized");










 }










 










 WrappedFact<Field, Fact, Stmt, Method> wrappedSource() {










 return new WrappedFact<>(sourceFact, accessPath, callEdgeResolver);










 }










 










 public AccessPath<Field> getAccessPath() {










 return accessPath;










 }










 










 public void bootstrapAtMethodStartPoints() {










 if(bootstrapped)










 return;










 










 callEdgeResolver.interest(this, callEdgeResolver);










 bootstrapped = true;










 for(Stmt startPoint : context.icfg.getStartPointsOf(method)) {










 WrappedFactAtStatement<Field, Fact, Stmt, Method> target = new WrappedFactAtStatement<>(startPoint, wrappedSource());










 if(!reachableStatements.containsKey(target))










 scheduleEdgeTo(target);










 }










 }










 










 public void addInitialSeed(Stmt stmt) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, wrappedSource()));










 }





















 void scheduleEdgeTo(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 if (reachableStatements.containsKey(factAtStmt)) {










 log("Merging "+factAtStmt);










 context.factHandler.merge(reachableStatements.get(factAtStmt).getFact().getFact(), factAtStmt.getFact().getFact());










 } else {










 log("Edge to "+factAtStmt);










 reachableStatements.put(factAtStmt, factAtStmt);










 context.scheduler.schedule(new Job(factAtStmt));










 }










 }





















 void log(String message) {










 logger.trace("[{}; {}{}: "+message+"]", method, sourceFact, accessPath);










 }










 










 @Override










 public String toString() {










 return method+"; "+sourceFact+accessPath;










 }





















 void processCall(WrappedFactAtStatement<Field,Fact, Stmt, Method> factAtStmt) {










 Collection<Method> calledMethods = context.icfg.getCalleesOfCallAt(factAtStmt.getStatement());










 for (Method calledMethod : calledMethods) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeCallFlow(factAtStmt, calledMethod);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 MethodAnalyzer<Field, Fact, Stmt, Method> analyzer = context.getAnalyzer(calledMethod);










 analyzer.addIncomingEdge(new IncomingEdge<Field, Fact, Stmt, Method>(this,










 factAtStmt, targetFact.getFact()));










 }










 }










 










 processCallToReturnEdge(factAtStmt);










 }





















 void processExit(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 log("New Summary: "+factAtStmt);










 if(!summaries.add(factAtStmt))










 throw new AssertionError();





















 










 for(IncomingEdge<Field, Fact, Stmt, Method> incEdge : incomingEdges) {










 applySummary(incEdge, factAtStmt);










 }





















 if(context.followReturnsPastSeeds && isZeroSource()) {










 Collection<Stmt> callSites = context.icfg.getCallersOf(method);










 for(Stmt callSite : callSites) {










 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(callSite);










 for(Stmt returnSite : returnSites) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeUnbalancedReturnFlow(










 sourceFact, factAtStmt, method, returnSite, callSite);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(new WrappedFactAtStatement<>(returnSite, targetFact.getFact()));










 }










 }










 }










 //in cases where there are no callers, the return statement would normally not be processed at all;










 //this might be undesirable if the flow function has a side effect such as registering a taint;










 //instead we thus call the return flow function will a null caller










 if(callSites.isEmpty()) {










 context.flowProcessor.computeUnbalancedReturnFlow(










 sourceFact, factAtStmt, method, null, null);










 }










 }










 }










 










 private void scheduleEdgeTo(Collection<Stmt> successors, WrappedFact<Field, Fact, Stmt, Method> fact) {










 for (Stmt stmt : successors) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, fact));










 }










 }










 










 private void processCallToReturnEdge(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 Stmt stmt = factAtStmt.getStatement();










 int numberOfPredecessors = context.icfg.getPredsOf(stmt).size(); 










 if(numberOfPredecessors > 1 || (context.icfg.isStartPoint(stmt) && numberOfPredecessors > 0)) {










 ctrFlowJoinResolvers.getOrCreate(factAtStmt.getAsFactAtStatement()).addIncoming(factAtStmt.getFact());










 }










 else {










 processNonJoiningCallToReturnFlow(factAtStmt);










 }










 }





















 private void processNonJoiningCallToReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(factAtStmt.getStatement());










 for(Stmt returnSite : returnSites) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeCallToReturnFlow(factAtStmt, returnSite);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, targetFact.getFact()));










 }










 }










 }





















 private void processNormalFlow(WrappedFactAtStatement<Field,Fact, Stmt, Method> factAtStmt) {










 Stmt stmt = factAtStmt.getStatement();










 int numberOfPredecessors = context.icfg.getPredsOf(stmt).size();










 if((numberOfPredecessors > 1 && !context.icfg.isExitStmt(stmt)) || (context.icfg.isStartPoint(stmt) && numberOfPredecessors > 0)) {










 ctrFlowJoinResolvers.getOrCreate(factAtStmt.getAsFactAtStatement()).addIncoming(factAtStmt.getFact());










 }










 else {










 processNormalNonJoiningFlow(factAtStmt);










 }










 }





















 void processFlowFromJoinStmt(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 if(context.icfg.isCallStmt(factAtStmt.getStatement()))










 processNonJoiningCallToReturnFlow(factAtStmt);










 else










 processNormalNonJoiningFlow(factAtStmt);










 }










 










 private void processNormalNonJoiningFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 final List<Stmt> successors = context.icfg.getSuccsOf(factAtStmt.getStatement());










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeNormalFlow(factAtStmt);










 for (final ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 if(targetFact.getConstraint() == null)










 scheduleEdgeTo(successors, targetFact.getFact());










 else {










 targetFact.getFact().getResolver().resolve(targetFact.getConstraint(), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer,










 Resolver<Field, Fact, Stmt, Method> resolver) {










 analyzer.scheduleEdgeTo(successors, new WrappedFact<>(targetFact.getFact().getFact(), targetFact.getFact().getAccessPath(), resolver));










 }





















 @Override










 public void canBeResolvedEmpty() {










 callEdgeResolver.resolve(targetFact.getConstraint(), this);










 }










 });










 }










 }










 }










 










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> getOrCreateNestedAnalyzer(AccessPath<Field> newAccPath) {










 if(newAccPath.equals(accessPath) || isZeroSource())










 return this;










 










 if(!nestedAnalyzers.containsKey(newAccPath)) {










 










 if(token)










 throw new AssertionError();










 










 assert accessPath.getDeltaTo(newAccPath).accesses.length <= 1;










 










 final PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> nestedAnalyzer = new PerAccessPathMethodAnalyzer<>(method, sourceFact, context, newAccPath, this);










 nestedAnalyzers.put(newAccPath, nestedAnalyzer);










 for(IncomingEdge<Field, Fact, Stmt, Method> incEdge : incomingEdges) {










 if(newAccPath.isPrefixOf(incEdge.getCalleeSourceFact().getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX)










 nestedAnalyzer.addIncomingEdge(incEdge);










 else if(incEdge.getCalleeSourceFact().getAccessPath().isPrefixOf(newAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX))










 incEdge.registerInterestCallback(nestedAnalyzer);










 }










 }










 return nestedAnalyzers.get(newAccPath);










 }










 










 boolean token;










 boolean recursiveLock;










 










 boolean isLocked() {










 if(recursiveLock)










 return true;










 if(parent == null)










 return false;










 return parent.isLocked();










 }










 










 public void addIncomingEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 if(accessPath.isPrefixOf(incEdge.getCalleeSourceFact().getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Edge: "+incEdge);










 if(!incomingEdges.add(incEdge))










 return;










 










 callEdgeResolver.interest(this, callEdgeResolver);










 










 applySummaries(incEdge);










 token=true;










 for(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> nestedAnalyzer : nestedAnalyzers.values())










 nestedAnalyzer.addIncomingEdge(incEdge);










 token=false;










 }










 else if(incEdge.getCalleeSourceFact().getAccessPath().isPrefixOf(accessPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 recursiveLock = true;










 incEdge.registerInterestCallback(this);










 recursiveLock = false;










 }










 }





















 private void applySummary(IncomingEdge<Field, Fact, Stmt, Method> incEdge, WrappedFactAtStatement<Field, Fact, Stmt, Method> exitFact) {










 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(incEdge.getCallSite());










 for(Stmt returnSite : returnSites) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeReturnFlow(context.factHandler, exitFact, method, returnSite, incEdge);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 scheduleReturnEdge(incEdge, targetFact.getFact(), returnSite);










 }










 }










 }





















 void scheduleUnbalancedReturnEdgeTo(WrappedFactAtStatement<Field, Fact, Stmt, Method> fact) {










 ReturnSiteResolver<Field,Fact,Stmt,Method> resolver = returnSiteResolvers.getOrCreate(fact.getAsFactAtStatement());










 resolver.addIncoming(new WrappedFact<>(fact.getFact().getFact(), fact.getFact().getAccessPath(), 










 fact.getFact().getResolver()), null, Delta.<Field>empty());










 }










 










 private void scheduleReturnEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge, WrappedFact<Field, Fact, Stmt, Method> fact, Stmt returnSite) {










 Delta<Field> delta = accessPath.getDeltaTo(incEdge.getCalleeSourceFact().getAccessPath());










 ReturnSiteResolver<Field, Fact, Stmt, Method> returnSiteResolver = incEdge.getCallerAnalyzer().returnSiteResolvers.getOrCreate(










 new FactAtStatement<Fact, Stmt>(fact.getFact(), returnSite));










 returnSiteResolver.addIncoming(fact, incEdge.getCalleeSourceFact().getResolver(), delta);










 }





















 private void applySummaries(IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 for(WrappedFactAtStatement<Field, Fact, Stmt, Method> summary : summaries) {










 applySummary(incEdge, summary);










 }










 }










 










 public boolean isZeroSource() {










 return sourceFact.equals(context.zeroValue);










 }





















 private class Job implements Runnable {





















 private WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt;





















 public Job(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 this.factAtStmt = factAtStmt;










 }





















 @Override










 public void run() {










 if (context.icfg.isCallStmt(factAtStmt.getStatement())) {










 processCall(factAtStmt);










 } else {










 if (context.icfg.isExitStmt(factAtStmt.getStatement())) {










 processExit(factAtStmt);










 }










 if (!context.icfg.getSuccsOf(factAtStmt.getStatement()).isEmpty()) {










 processNormalFlow(factAtStmt);










 }










 }










 }










 }





















 public CallEdgeResolver<Field, Fact, Stmt, Method> getCallEdgeResolver() {










 return callEdgeResolver;










 }










 










 public void debugInterest() {










 JsonDocument root = new JsonDocument();










 










 List<PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> worklist = Lists.newLinkedList();










 worklist.add(this);










 Set<PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> visited = Sets.newHashSet();










 










 while(!worklist.isEmpty()) {










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> current = worklist.remove(0);










 if(!visited.add(current))










 continue;










 










 JsonDocument currentMethodDoc = root.doc(current.method.toString()+ "___"+current.sourceFact);










 JsonDocument currentDoc = currentMethodDoc.doc("accPath").doc("_"+current.accessPath.toString());










 










 for(IncomingEdge<Field, Fact, Stmt, Method> incEdge : current.incomingEdges) {










 currentDoc.doc("incoming").doc(incEdge.getCallerAnalyzer().method+"___"+incEdge.getCallerAnalyzer().sourceFact).doc("_"+incEdge.getCallerAnalyzer().accessPath.toString());










 worklist.add(incEdge.getCallerAnalyzer());










 }










 }










 










 try {










 FileWriter writer = new FileWriter("debug/incoming.json");










 StringBuilder builder = new StringBuilder();










 builder.append("var root=");










 root.write(builder, 0);










 writer.write(builder.toString());










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }










 










 public void debugNestings() {










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> current = this;










 while(current.parent != null)










 current = current.parent;










 










 JsonDocument root = new JsonDocument();










 debugNestings(current, root);










 










 try {










 FileWriter writer = new FileWriter("debug/nestings.json");










 StringBuilder builder = new StringBuilder();










 builder.append("var root=");










 root.write(builder, 0);










 writer.write(builder.toString());










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }





















 private void debugNestings(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> current, JsonDocument parentDoc) {










 JsonDocument currentDoc = parentDoc.doc(current.accessPath.toString());










 for(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> nestedAnalyzer : current.nestedAnalyzers.values()) {










 debugNestings(nestedAnalyzer, currentDoc);










 }










 }










}














src/heros/alias/Resolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.List;










import java.util.Map;





















import com.google.common.collect.HashMultimap;










import com.google.common.collect.Lists;





















import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.Constraint;





















public abstract class Resolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private boolean interest = false;










 private List<InterestCallback<Field, Fact, Stmt, Method>> interestCallbacks = Lists.newLinkedList();










 protected PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer;










 private boolean canBeResolvedEmpty = false;










 










 public Resolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 this.analyzer = analyzer;










 }





















 public abstract void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback);










 










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 if(interest)










 return;










 










 log("Interest given");










 interest = true;










 for(InterestCallback<Field, Fact, Stmt, Method> callback : Lists.newLinkedList(interestCallbacks)) {










 callback.interest(analyzer, resolver);










 }










 










 if(canBeResolvedEmpty)










 interestCallbacks = null;










 }










 










 protected void canBeResolvedEmpty() {










 if(canBeResolvedEmpty)










 return;










 










 canBeResolvedEmpty = true;










 for(InterestCallback<Field, Fact, Stmt, Method> callback : Lists.newLinkedList(interestCallbacks)) {










 callback.canBeResolvedEmpty();










 }










 










 if(interest)










 interestCallbacks = null;










 }





















 public boolean isInterestGiven() {










 return interest;










 }





















 protected void registerCallback(InterestCallback<Field, Fact, Stmt, Method> callback) {










 if(interest) {










 callback.interest(analyzer, this);










 }










 else {










 log("Callback registered");










 interestCallbacks.add(callback);










 }





















 if(canBeResolvedEmpty)










 callback.canBeResolvedEmpty();










 }










 










 protected abstract void log(String message);










 










}














src/heros/alias/ReturnSiteResolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















import java.util.Map;










import java.util.Set;





















import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private Stmt returnSite;










 private AccessPath<Field> resolvedAccPath;










 private boolean propagated = false;










 private Set<ReturnEdge> incomingFacts;










 private Map<AccessPath<Field>, ReturnSiteResolver<Field, Fact, Stmt, Method>> nestedResolvers = Maps.newHashMap();










 private ReturnSiteResolver<Field, Fact, Stmt, Method> parent;





















 public ReturnSiteResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt returnSite) {










 this(analyzer, returnSite, new AccessPath<Field>(), null);










 }





















 private ReturnSiteResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt returnSite, AccessPath<Field> resolvedAccPath, ReturnSiteResolver<Field, Fact, Stmt, Method> parent) {










 super(analyzer);










 this.returnSite = returnSite;










 this.resolvedAccPath = resolvedAccPath;










 this.parent = parent;










 this.incomingFacts = Sets.newHashSet();










 }










 










 @Override










 public String toString() {










 return "<"+resolvedAccPath+":"+returnSite+">";










 }










 










 public AccessPath<Field> getResolvedAccessPath() {










 return resolvedAccPath;










 }










 










 public void addIncoming(final WrappedFact<Field, Fact, Stmt, Method> fact, 










 Resolver<Field, Fact, Stmt, Method> resolverAtCaller, 










 Delta<Field> callDelta) {










 










 addIncoming(new ReturnEdge(fact, resolverAtCaller, callDelta));










 }










 










 private void addIncoming(final ReturnEdge retEdge) {










 if(resolvedAccPath.isPrefixOf(retEdge.incAccessPath) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Edge "+retEdge);










 if(!incomingFacts.add(retEdge))










 return;





















 interest(analyzer, this);










 










 for(ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver : nestedResolvers.values())










 nestedResolver.addIncoming(nestedResolver.new ReturnEdge(retEdge.incFact, retEdge.incAccessPath, retEdge.incResolver, 










 retEdge.resolverAtCaller, retEdge.callDelta, retEdge.usedAccessPathOfIncResolver));





















 if(!propagated) {










 propagated=true;










 analyzer.scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, 










 new WrappedFact<>(retEdge.incFact, new AccessPath<Field>(), this)));










 }










 }










 else if(retEdge.incAccessPath.isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 log("Incoming potential prefix:  "+retEdge);










 retEdge.resolveViaDelta();










 }










 }










 










 protected void log(String message) {










 analyzer.log("Return Site "+toString()+": "+message);










 }





















 @Override










 public void resolve(Constraint<Field> constraint, final InterestCallback<Field, Fact, Stmt, Method> callback) {










 log("Resolve: "+constraint);










 if(!constraint.canBeAppliedTo(resolvedAccPath))










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);










 }










 










 private ReturnSiteResolver<Field, Fact, Stmt, Method> getOrCreateNestedResolver(AccessPath<Field> candidateAccPath) {










 if(resolvedAccPath.equals(candidateAccPath))










 return this;










 










 if(!nestedResolvers.containsKey(candidateAccPath)) {










 assert resolvedAccPath.getDeltaTo(candidateAccPath).accesses.length <= 1;










 final ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver = new ReturnSiteResolver<>(analyzer, returnSite, candidateAccPath, this);










 nestedResolver.propagated = true;










 nestedResolvers.put(candidateAccPath, nestedResolver);





















 for(ReturnSiteResolver<Field, Fact, Stmt, Method>.ReturnEdge retEdge: incomingFacts) {










 nestedResolver.addIncoming(nestedResolver.new ReturnEdge(retEdge.incFact, retEdge.incAccessPath, retEdge.incResolver, 










 retEdge.resolverAtCaller, retEdge.callDelta, retEdge.usedAccessPathOfIncResolver));










 } 










 }










 return nestedResolvers.get(candidateAccPath);










 }










 










 private class ReturnEdge {





















 final Fact incFact;










 final Resolver<Field, Fact, Stmt, Method> resolverAtCaller;










 final Delta<Field> callDelta;










 final AccessPath<Field> incAccessPath;










 final Resolver<Field, Fact, Stmt, Method> incResolver;










 final Delta<Field> usedAccessPathOfIncResolver;





















 public ReturnEdge(WrappedFact<Field, Fact, Stmt, Method> fact, Resolver<Field, Fact, Stmt, Method> resolverAtCaller,










 Delta<Field> callDelta) {










 this(fact.getFact(), fact.getAccessPath(), fact.getResolver(), resolverAtCaller, callDelta, Delta.<Field>empty());










 }










 










 private ReturnEdge(Fact incFact, AccessPath<Field> incAccessPath, Resolver<Field, Fact, Stmt, Method> incResolver, 










 Resolver<Field, Fact, Stmt, Method> resolverAtCaller, Delta<Field> callDelta, Delta<Field> usedAccessPathOfIncResolver) {










 this.incFact = incFact;










 this.incAccessPath = incAccessPath;










 this.incResolver = incResolver;










 this.resolverAtCaller = resolverAtCaller;










 this.callDelta = callDelta;










 this.usedAccessPathOfIncResolver = usedAccessPathOfIncResolver;










 }










 










 @Override










 public String toString() {










 return String.format("IncFact: %s%s, Delta: %s, IncResolver: <%s:%s>, ResolverAtCallSite: %s", incFact, incAccessPath, callDelta, usedAccessPathOfIncResolver, incResolver, resolverAtCaller);










 }










 










 public void resolveViaDelta() {










 if(incResolver == null || incResolver instanceof CallEdgeResolver) {










 resolveViaDeltaAndPotentiallyDelegateToCallSite();










 } else {










 //resolve via incoming facts resolver










 Delta<Field> delta = usedAccessPathOfIncResolver.applyTo(incAccessPath, true).getDeltaTo(resolvedAccPath);










 assert delta.accesses.length <= 1;










 incResolver.resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {





















 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, resolver, resolverAtCaller, callDelta, incAccessPath.getDeltaTo(resolvedAccPath)));










 ReturnSiteResolver.this.interest(analyzer, resolver);










 }










 










 @Override










 public void canBeResolvedEmpty() {










 resolveViaDeltaAndPotentiallyDelegateToCallSite();










 }










 });










 } 










 }





















 private void resolveViaDeltaAndPotentiallyDelegateToCallSite() {










 final AccessPath<Field> currAccPath = callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath, true), true);










 if(resolvedAccPath.isPrefixOf(currAccPath) == PrefixTestResult.GUARANTEED_PREFIX) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver));










 ReturnSiteResolver.this.interest(analyzer, ReturnSiteResolver.this);










 } else if(currAccPath.isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 resolveViaCallSiteResolver(currAccPath);










 }










 }





















 protected void resolveViaCallSiteResolver(AccessPath<Field> currAccPath) {










 if(resolverAtCaller == null || resolverAtCaller instanceof CallEdgeResolver) {










 ReturnSiteResolver.this.canBeResolvedEmpty();










 } else {










 resolverAtCaller.resolve(new DeltaConstraint<>(currAccPath.getDeltaTo(resolvedAccPath)), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, null, resolver, Delta.<Field>empty(), incAccessPath.getDeltaTo(resolvedAccPath)));










 ReturnSiteResolver.this.interest(analyzer, ReturnSiteResolver.this);










 }










 










 @Override










 public void canBeResolvedEmpty() {










 ReturnSiteResolver.this.canBeResolvedEmpty();










 }










 });










 }










 }










 }





















 public Stmt getReturnSite() {










 return returnSite;










 }










}














src/heros/alias/Scheduler.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.LinkedList;










import com.google.common.collect.Lists;





















public class Scheduler {





















 private LinkedList<Runnable> worklist = Lists.newLinkedList();










 










 public void schedule(Runnable job) {










 worklist.add(job);










 }





















 public void runAndAwaitCompletion() {










 while(!worklist.isEmpty()) {










 worklist.removeLast().run();










 }










 }





















}














src/heros/alias/TestDebugger.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.io.FileWriter;










import java.io.IOException;










import java.util.Set;





















import com.google.common.collect.Sets;





















import heros.InterproceduralCFG;










import heros.alias.TestHelper.Edge;





















public class TestDebugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 private JsonDocument root = new JsonDocument();










 private I icfg;










 










 public void writeJsonDebugFile(String filename) {










 try {










 FileWriter writer = new FileWriter(filename);










 StringBuilder builder = new StringBuilder();










 builder.append("var root=");










 root.write(builder, 0);










 writer.write(builder.toString());










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }










 










 /* (non-Javadoc)










	 * @see heros.alias.Debugger#setICFG(I)










	 */










 @Override










 public void setICFG(I icfg) {










 this.icfg = icfg;










 }





















 /* (non-Javadoc)










	 * @see heros.alias.Debugger#initialSeed(Stmt)










	 */










 @Override










 public void initialSeed(Stmt stmt) {










 stmt(stmt).keyValue("seed", "true");










 










 includeSuccessors(stmt, Sets.<Stmt> newHashSet());










 }










 










 private void includeSuccessors(Stmt stmt, Set<Stmt> visited) {










 if(!visited.add(stmt))










 return;










 










 JsonDocument doc = stmt(stmt);










 for(Stmt succ : icfg.getSuccsOf(stmt)) {










 doc.array("successors").add(succ.toString());










 stmt(succ);










 includeSuccessors(succ, visited);










 }










 










 if(icfg.isCallStmt(stmt)) {










 for(Method m : icfg.getCalleesOfCallAt(stmt)) {










 doc.doc("calls").doc(m.toString());










 for(Stmt sp : icfg.getStartPointsOf(m)) {










 stmt(sp).keyValue("startPoint", "true");










 includeSuccessors(sp, visited);










 }










 }










 for(Stmt retSite :icfg.getReturnSitesOfCallAt(stmt)) {










 doc.array("successors").add(retSite.toString());










 stmt(retSite);










 includeSuccessors(retSite, visited);










 }










 }










 if(icfg.isExitStmt(stmt)) {










 for(Stmt callSite : icfg.getCallersOf(icfg.getMethodOf(stmt))) {










 for(Stmt retSite : icfg.getReturnSitesOfCallAt(callSite)) {










 doc.doc("returns").doc(retSite.toString());










 includeSuccessors(retSite, visited);










 }










 }










 }










 }





















 protected JsonDocument stmt(Stmt stmt) {










 Method methodOf = icfg.getMethodOf(stmt);










 return root.doc("methods").doc(methodOf.toString()).doc(stmt.toString());










 }










 










 public void expectNormalFlow(Stmt unit, String expectedFlowFunctionsToString) {










 stmt(unit).keyValue("flow", expectedFlowFunctionsToString);










 }





















 public void expectCallFlow(Stmt callSite, Method destinationMethod, String expectedFlowFunctionsToString) {










 stmt(callSite).doc("calls").doc(destinationMethod.toString()).keyValue("flow", expectedFlowFunctionsToString);










 }





















 public void expectReturnFlow(Stmt exitStmt, Stmt returnSite, String expectedFlowFunctionsToString) {










 if(returnSite != null)










 stmt(exitStmt).doc("returns").doc(returnSite.toString()).keyValue("flow", expectedFlowFunctionsToString);










 }





















 static void tabs(int tabs, StringBuilder builder) {










 for(int i=0; i<tabs; i++)










 builder.append("\t");










 }





















}














src/heros/alias/Transition.java








View file @ 3398e46f






......@@ -72,14 +72,16 @@ public interface Transition<FieldRef> {









 } else {










 Set<FieldRef> otherExcludedFields = ((ExclusionPathTransition<FieldRef>) t).excludedFields;










 boolean intersection = false;










 boolean containsAll = true;










 boolean containsAll = excludedFields.containsAll(otherExcludedFields);










 boolean oppositeContainsAll = otherExcludedFields.containsAll(excludedFields);










 for(FieldRef field : excludedFields) {










 if(otherExcludedFields.contains(field))










 if(otherExcludedFields.contains(field)) {










 intersection = true;










 else










  containsAll = false;










  break;










 }










 }










 return new MatchResult<>(containsAll || !intersection, containsAll);










 boolean potentialMatch = oppositeContainsAll || !intersection || (!containsAll && !oppositeContainsAll);










 return new MatchResult<>(potentialMatch, oppositeContainsAll);










 }










 










 return new MatchResult<>(false, false);



......














test/heros/alias/Fact.java

→

src/heros/alias/WrappedFact.java








View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at



......@@ -10,87 +10,58 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;





















import java.util.ArrayList;










import java.util.Arrays;










import java.util.regex.Matcher;










import java.util.regex.Pattern;










public class WrappedFact<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method>{





















import com.google.common.base.Joiner;










import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, TestFieldRef, Fact> {





















 public final String baseValue;










 public final AccessPath<TestFieldRef> accessPath;










 private final Fact fact;










 private final AccessPath<Field> accessPath;










 private final Resolver<Field, Fact, Stmt, Method> resolver;










 










 public Fact(String name) {










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 AccessPath<TestFieldRef> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();










 baseValue = name.substring(0, firstSeparator);










 matcher.reset();










 WrappedFact(Fact fact, AccessPath<Field> accessPath, Resolver<Field, Fact, Stmt, Method> resolver) {










 assert fact != null;










 assert accessPath != null;










 assert resolver != null;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(separator.equals(".")) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(new TestFieldRef(identifier));










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 TestFieldRef[] fExcl = new TestFieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new TestFieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 }










 }










 this.fact = fact;










 this.accessPath = accessPath;










 this.resolver = resolver;










 }










 










 public Fact(String baseValue, AccessPath<TestFieldRef> accessPath) {










 this.baseValue = baseValue;










 this.accessPath = accessPath;










 public Fact getFact() {










 return fact;










 }










 










 @Override










 public String toString() {










 return "[Fact "+baseValue+(accessPath.isEmpty() ? "" : accessPath)+"]";










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta, boolean merge) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath, merge), resolver); //TODO keep resolver?










 }





















 @Override










 public String getBaseValue() {










 return baseValue;










 }





















 @Override










 public AccessPath<TestFieldRef> getAccessPath() {










 public AccessPath<Field> getAccessPath() {










 return accessPath;










 }





















 @Override










 public void addNeighbor(Fact originalAbstraction) {










 










 










 public WrappedFact<Field, Fact, Stmt, Method> applyConstraint(Constraint<Field> constraint, Fact zeroValue, boolean sourceFact) {










 if(fact.equals(zeroValue))










 return this;










 else










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath, sourceFact), resolver);










 }





















 










 @Override










 public void setCallingContext(Fact callingContext) {










 










 public String toString() {










 String result = fact.toString()+accessPath;










 if(resolver != null)










 result+=resolver.toString();










 return result;










 }





















 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((accessPath == null) ? 0 : accessPath.hashCode());










 result = prime * result + ((baseValue == null) ? 0 : baseValue.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -100,25 +71,29 @@ public class Fact implements FieldSensitiveFact<String, TestFieldRef, Fact> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof Fact))










 if (getClass() != obj.getClass())










 return false;










 Fact other = (Fact) obj;










 WrappedFact other = (WrappedFact) obj;










 if (accessPath == null) {










 if (other.accessPath != null)










 return false;










 } else if (!accessPath.equals(other.accessPath))










 return false;










 if (baseValue == null) {










 if (other.baseValue != null)










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!baseValue.equals(other.baseValue))










 } else if (!fact.equals(other.fact))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }





















 @Override










 public Fact cloneWithAccessPath(AccessPath<TestFieldRef> accessPath) {










 return new Fact(baseValue, accessPath);










 public Resolver<Field, Fact, Stmt, Method> getResolver() {










 return resolver;










 }










 










 



......














src/heros/alias/SummaryEdge.java

→

src/heros/alias/WrappedFactAtStatement.java








View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at



......@@ -10,70 +10,66 @@









 ******************************************************************************/










package heros.alias;





















public class SummaryEdge<D, N> {










public class WrappedFactAtStatement<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private D sourceFact;










 private N targetStmt;










 private D targetFact;










 private WrappedFact<Field,Fact, Stmt, Method> fact;










 private Stmt stmt;





















 public WrappedFactAtStatement(Stmt stmt, WrappedFact<Field, Fact, Stmt, Method> fact) {










 this.stmt = stmt;










 this.fact = fact;










 }





















 public WrappedFact<Field,Fact, Stmt, Method> getFact() {










 return fact;










 }





















 public Stmt getStatement() {










 return stmt;










 }










 










 public FactAtStatement<Fact, Stmt> getAsFactAtStatement() {










 return new FactAtStatement<Fact, Stmt>(fact.getFact(), stmt);










 }










 










 public SummaryEdge(D sourceFact, N targetStmt, D targetFact) {










 this.sourceFact = sourceFact;










 this.targetStmt = targetStmt;










 this.targetFact = targetFact;










 public boolean canDeltaBeApplied(AccessPath.Delta<Field> delta) {










 return delta.canBeAppliedTo(fact.getAccessPath());










 }










 










 @Override










 public String toString() {










 return "[SummaryEdge: "+sourceFact+" -> "+targetFact+" @stmt: "+targetStmt+"]";










 return fact+" @ "+stmt;










 }





















 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((sourceFact == null) ? 0 : sourceFact.hashCode());










 result = prime * result + ((targetFact == null) ? 0 : targetFact.hashCode());










 result = prime * result + ((targetStmt == null) ? 0 : targetStmt.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((stmt == null) ? 0 : stmt.hashCode());










 return result;










 }










 





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SummaryEdge))










 if (getClass() != obj.getClass())










 return false;










 SummaryEdge other = (SummaryEdge) obj;










 if (sourceFact == null) {










 if (other.sourceFact != null)










 WrappedFactAtStatement other = (WrappedFactAtStatement) obj;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!sourceFact.equals(other.sourceFact))










 } else if (!fact.equals(other.fact))










 return false;










 if (targetFact == null) {










 if (other.targetFact != null)










 if (stmt == null) {










 if (other.stmt != null)










 return false;










 } else if (!targetFact.equals(other.targetFact))










 return false;










 if (targetStmt == null) {










 if (other.targetStmt != null)










 return false;










 } else if (!targetStmt.equals(other.targetStmt))










 } else if (!stmt.equals(other.stmt))










 return false;










 return true;










 }





















 public D getSourceFact() {










 return sourceFact;










 }










 










 public D getTargetFact() {










 return targetFact;










 }










 










 public N getTargetStmt() {










 return targetStmt;










 }










 










}














src/heros/alias/ZeroCallEdgeResolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class ZeroCallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends CallEdgeResolver<Field, Fact, Stmt, Method> {





















 private ZeroHandler<Field> zeroHandler;





















 public ZeroCallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, ZeroHandler<Field> zeroHandler) {










 super(analyzer);










 this.zeroHandler = zeroHandler;










 }





















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) {










 if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(new AccessPath<Field>(), true)))










 callback.interest(analyzer, this);










 }










 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 }










}














src/heros/alias/FieldSensitiveFact.java

→

src/heros/alias/ZeroHandler.java








View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch, Johannes Späth.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch, Johannes Späth - initial API and implementation










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.solver.LinkedNode;










public interface ZeroHandler<Field extends AccessPath.FieldRef<Field>> {





















public interface FieldSensitiveFact<BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D> extends LinkedNode<D>{





















 BaseValue getBaseValue();










 










 AccessPath<FieldRef> getAccessPath();










 










 D cloneWithAccessPath(AccessPath<FieldRef> accessPath);










 










 boolean shouldGenerateAccessPath(AccessPath<Field> accPath);










}














test/heros/alias/AccessPathTest.java








View file @ 3398e46f






......@@ -19,6 +19,7 @@ import org.junit.Test;




















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.SubAccessPath.*;














......@@ -36,7 +37,7 @@ public class AccessPathTest {









 }










 return result;










 }










 





















 private static SetOfPossibleFieldAccesses<TestFieldRef> anyOf(String...fields) {










 Set<TestFieldRef> set = Sets.newHashSet();










 for(String f : fields)



......@@ -49,7 +50,7 @@ public class AccessPathTest {









 }










 










 private static AccessPath<TestFieldRef> ap(SubAccessPath<TestFieldRef>... path) {










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet(), null);










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet());










 }










 










 @Test



......@@ -64,6 +65,12 @@ public class AccessPathTest {









 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMultipleFieldsAndMerge() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(f("b", "a")));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<TestFieldRef> sut = ap(s("a"));



......@@ -190,6 +197,20 @@ public class AccessPathTest {









 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaFromSetToSet() {










 Delta<TestFieldRef> actual = ap(anyOf("a")).appendExcludedFieldReference(f("f")).getDeltaTo(ap(anyOf("a")).appendExcludedFieldReference(f("g")));










 assertArrayEquals(new SubAccessPath[] { anyOf("a") }, actual.accesses);










 assertEquals(Sets.newHashSet(f("g")), actual.exclusions);










 }










 










 @Test










 public void emptyDeltaOnEqualExclusions() {










 AccessPath<TestFieldRef> actual = ap().appendExcludedFieldReference(f("f"));










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).exclusions.equals(Sets.newHashSet(f("f"))));










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;



......@@ -227,6 +248,12 @@ public class AccessPathTest {









 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void multipleExclPrefixOfMultipleExcl() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference(f("f", "h"))));










 }










 










 @Test










 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));



......














test/heros/alias/AccessPathUtilTest.java








View file @ 3398e46f






......@@ -11,125 +11,109 @@









package heros.alias;





















import static heros.alias.AccessPath.PrefixTestResult.*;










import static heros.alias.AccessPathUtil.applyAbstractedSummary;










import static heros.alias.AccessPathUtil.isPrefixOf;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertTrue;





















import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import heros.alias.AccessPath.PrefixTestResult;





















import org.junit.Test;





















public class AccessPathUtilTest {





















 public static AccessPath<TestFieldRef> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<TestFieldRef> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(new TestFieldRef(identifier));










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 TestFieldRef[] fExcl = new TestFieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new TestFieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 }










 }










 return accessPath;










 }










 










 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a"), new Fact("a.f")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a")));










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("f")));










 assertEquals(NO_PREFIX, ap("f").isPrefixOf(ap("")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a"), new Fact("a")));










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.b"), new Fact("a.b.c")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.b.c"), new Fact("a.b")));










 assertEquals(GUARANTEED_PREFIX, ap("b").isPrefixOf(ap("b.c")));










 assertEquals(NO_PREFIX, ap("b.c").isPrefixOf(ap("b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.g")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.g"), new Fact("a^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g")));










 assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a^f")));










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f,g"), new Fact("a^f,g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertEquals(POTENTIAL_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.g.g")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.f.h")));










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f,g"), new Fact("a^g")));










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f")));










 assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.g.h")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h")));










 }










 










 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a"), new Fact("a^f")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a")));










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));










 










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a.f^g^h")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 }










 










 @Test










 public void testAbstractedSummary() {










 assertEquals(new Fact("z.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h")));










 assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f")));










 }










 










 @Test










 public void testAbstractedFieldAccessSummary() {










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryIntroducesFieldAccess() {










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.c"), new SummaryEdge<>(new Fact("a"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryRemovesFieldAccess() {










 assertEquals(new Fact("z.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testNonAbstractedSummary() {










 assertEquals(new Fact("z"), applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testSummaryWithExcludedField() {










 assertEquals(new Fact("a.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testIdentityForExclusions() {










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a"))).get());










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).get());










 }










 










 @Test










 public void testMergeExclusions() {










 assertEquals(new Fact("a^f,g"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testNullOnImpossibleSubsumption() {










 assertFalse(applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).isPresent());










 }










}














test/heros/alias/ControlFlowJoinResolverTest.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;





















import org.junit.Before;










import org.junit.Test;










import org.mockito.ArgumentMatcher;










import org.mockito.Mockito;










import org.mockito.invocation.InvocationOnMock;










import org.mockito.stubbing.Answer;










import org.mockito.verification.VerificationMode;





















public class ControlFlowJoinResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement joinStmt;










 private ControlFlowJoinResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 joinStmt = new TestStatement("joinStmt");










 sut = new ControlFlowJoinResolver<>(analyzer, joinStmt);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);










 }





















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver));










 verify(analyzer).processFlowFromJoinStmt(eq(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver));










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));










 }










 










 










 private class ResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;





















 public ResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 this.accPath = accPath;










 }





















 @Override










 public boolean matches(Object argument) {










 ControlFlowJoinResolver resolver = (ControlFlowJoinResolver) argument;










 return resolver.isInterestGiven() && resolver.getResolvedAccessPath().equals(accPath) && resolver.getJoinStmt().equals(joinStmt);










 }










 }










}














test/heros/alias/EdgeBuilder.java








View file @ 3398e46f






......@@ -32,43 +32,44 @@ public abstract class EdgeBuilder {




















 public static class CallSiteBuilder extends EdgeBuilder {





















 private Statement callSite;










 private TestStatement callSite;





















 public CallSiteBuilder(Statement callSite) {










 public CallSiteBuilder(TestStatement callSite) {










 this.callSite = callSite;










 }





















 public CallSiteBuilder calls(String method, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.CallEdge(callSite, new Method(method), flows));










 edges.add(new TestHelper.CallEdge(callSite, new TestMethod(method), flows));










 return this;










 }










 










 public CallSiteBuilder retSite(String returnSite, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new Statement(returnSite), flows));










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new TestStatement(returnSite), flows));










 return this;










 }










 }










 










 public static class NormalStmtBuilder extends EdgeBuilder {





















 private Statement stmt;










 private TestStatement stmt;










 private ExpectedFlowFunction[] flowFunctions;





















 public NormalStmtBuilder(Statement stmt) {










 public NormalStmtBuilder(TestStatement stmt, ExpectedFlowFunction[] flowFunctions) {










 this.stmt = stmt;










 this.flowFunctions = flowFunctions;










 }





















 public NormalStmtBuilder succ(String succ, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.NormalEdge(stmt, new Statement(succ), flows));










 public NormalStmtBuilder succ(String succ) {










 edges.add(new TestHelper.NormalEdge(stmt, new TestStatement(succ), flowFunctions));










 return this;










 }










 










 }










 










 public static class ExitStmtBuilder extends EdgeBuilder {





















 private Statement exitStmt;










 private TestStatement exitStmt;





















 public ExitStmtBuilder(Statement exitStmt) {










 public ExitStmtBuilder(TestStatement exitStmt) {










 this.exitStmt = exitStmt;










 }










 



......@@ -77,7 +78,7 @@ public abstract class EdgeBuilder {









 return this;










 }





















 public ExitStmtBuilder returns(Statement callSite, Statement returnSite, ExpectedFlowFunction... flows) {










 public ExitStmtBuilder returns(TestStatement callSite, TestStatement returnSite, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.ReturnEdge(callSite, exitStmt, returnSite, flows));










 return this;










 }



......














test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ 3398e46f





This diff is collapsed.
Click to expand it.













test/heros/alias/ReturnSiteResolverTest.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;





















import org.junit.Before;










import org.junit.Test;










import org.mockito.ArgumentMatcher;










import org.mockito.Mockito;










import org.mockito.invocation.InvocationOnMock;










import org.mockito.stubbing.Answer;










import org.mockito.verification.VerificationMode;





















public class ReturnSiteResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement returnSite;










 private ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 returnSite = new TestStatement("returnSite");










 sut = new ReturnSiteResolver<>(analyzer, returnSite);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);










 }





















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 verify(analyzer).scheduleEdgeTo(eq(new WrappedFactAtStatement<>(returnSite, new WrappedFact<>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver), callEdgeResolver, getDelta());










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }










 










 @Test










 public void resolveViaDelta() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }










 










 @Test










 public void resolveViaDeltaTwice() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a", "b"));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(innerCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));










 }










 










 @Test










 public void resolveViaDeltaAndThenViaCallSite() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(innerCallback).canBeResolvedEmpty();










 }





















 @Test










 public void resolveViaCallEdgeResolverAtCallSite() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).canBeResolvedEmpty();










 }










 










 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 @Test










 public void resolveViaResolverAtCallSiteTwice() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback innerCallback = (InterestCallback) invocation.getArguments()[1];










 innerCallback.interest(analyzer, nestedResolver);










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback innerCallback = (InterestCallback) invocation.getArguments()[1];










 innerCallback.interest(analyzer, nestedResolver);










 return null;










 }










 }).when(nestedResolver).resolve(eq(getDeltaConstraint("b")), any(InterestCallback.class));










 










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), secondCallback);










 return null;










 }










 










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(secondCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));










 }










 










 @Test










 public void resolveAsEmptyViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Delta<TestFieldRef> delta = new AccessPath<TestFieldRef>().getDeltaTo(new AccessPath<TestFieldRef>().appendExcludedFieldReference(new TestFieldRef("a")));










 










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback innerCallback = (InterestCallback) invocation.getArguments()[1];










 innerCallback.canBeResolvedEmpty();










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));





















 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, delta);










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback, never()).canBeResolvedEmpty();










 verify(callback, never()).interest(any(PerAccessPathMethodAnalyzer.class), any(Resolver.class));










 }










 










 @Test










 public void resolveViaCallSiteResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 private class ReturnSiteResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;





















 public ReturnSiteResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 this.accPath = accPath;










 }





















 @Override










 public boolean matches(Object argument) {










 ReturnSiteResolver resolver = (ReturnSiteResolver) argument;










 return resolver.isInterestGiven() && resolver.getResolvedAccessPath().equals(accPath) && resolver.getReturnSite().equals(returnSite);










 }










 }










}









Prev


1


2


3


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










H


heros






Project information




Project information




Activity


Labels


Members







Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare







Issues

0



Issues

0



List


Boards


Service Desk


Milestones







Merge requests

0



Merge requests

0






CI/CD




CI/CD




Pipelines


Jobs


Schedules







Deployments




Deployments




Environments


Releases







Monitor




Monitor




Incidents







Analytics




Analytics




Value stream


CI/CD


Repository







Wiki




Wiki





Activity


Graph


Create a new issue


Jobs


Commits


Issue Boards




Collapse sidebar


Close sidebar


H


heros


H
H
heros




Project information




Project information




Activity


Labels


Members






Project information


Project information




Project information


Activity


Activity

Labels


Labels

Members


Members




Repository




Repository




Files


Commits


Branches


Tags


Contributors


Graph


Compare






Repository


Repository




Repository


Files


Files

Commits


Commits

Branches


Branches

Tags


Tags

Contributors


Contributors

Graph


Graph

Compare


Compare




Issues

0



Issues

0



List


Boards


Service Desk


Milestones






Issues
0


Issues

0



Issues

0
0

List


List

Boards


Boards

Service Desk


Service Desk

Milestones


Milestones




Merge requests

0



Merge requests

0





Merge requests
0


Merge requests

0



Merge requests

0
0




CI/CD




CI/CD




Pipelines


Jobs


Schedules






CI/CD


CI/CD




CI/CD


Pipelines


Pipelines

Jobs


Jobs

Schedules


Schedules




Deployments




Deployments




Environments


Releases






Deployments


Deployments




Deployments


Environments


Environments

Releases


Releases




Monitor




Monitor




Incidents






Monitor


Monitor




Monitor


Incidents


Incidents




Analytics




Analytics




Value stream


CI/CD


Repository






Analytics


Analytics




Analytics


Value stream


Value stream

CI/CD


CI/CD

Repository


Repository




Wiki




Wiki






Wiki


Wiki




Wiki


Activity

Graph

Create a new issue

Jobs

Commits

Issue Boards
Collapse sidebarClose sidebar




Open sidebar



Joshua Garcia heros
Commits

3398e46f















Commit
3398e46f


authored
Feb 25, 2015
by


Johannes Lerch



Browse files




rewrite of ifds solver







parent
55cdd2d8













Changes
45




Expand all
Hide whitespace changes

Inline
Side-by-side















src/heros/alias/InterestCallback.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public interface InterestCallback<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver);










 










//	void partiallyResolved(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver, AccessPath<Field> resolvedAccPath);










 










 void canBeResolvedEmpty();










}














src/heros/alias/JsonArray.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.List;





















import com.google.common.collect.Lists;





















class JsonArray {










 










 private List<String> items = Lists.newLinkedList();










 










 public void add(String item) {










 items.add(item);










 }





















 public void write(StringBuilder builder, int tabs) {










 builder.append("[\n");










 for(String item: items) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+item+"\",\n");










 }










 TestDebugger.tabs(tabs, builder); builder.append("]");










 }










}




\ No newline at end of file














src/heros/alias/JsonDocument.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Map;










import java.util.Map.Entry;





















import com.google.common.collect.Maps;





















class JsonDocument {










 










 private CacheMap<String, JsonDocument> documents = new CacheMap<String, JsonDocument>() {










 @Override










 protected JsonDocument createItem(String key) {










 return new JsonDocument();










 }










 };










 private CacheMap<String, JsonArray> arrays = new CacheMap<String, JsonArray>() {










 @Override










 protected JsonArray createItem(String key) {










 return new JsonArray();










 }










 };










 private Map<String, String> keyValuePairs = Maps.newHashMap();










 










 public JsonDocument doc(String key) {










 return documents.getOrCreate(key);










 }










 










 public JsonArray array(String key) {










 return arrays.getOrCreate(key);










 }










 










 public void keyValue(String key, String value) {










 keyValuePairs.put(key, value);










 }










 










 public void write(StringBuilder builder, int tabs) {










 builder.append("{\n");










 










 for(Entry<String, String> entry : keyValuePairs.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n");










 }










 










 for(Entry<String, JsonArray> entry : arrays.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");





















 }










 










 for(Entry<String, JsonDocument> entry : documents.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");










 }










 










 TestDebugger.tabs(tabs, builder); builder.append("}");










 }





















}




\ No newline at end of file














src/heros/alias/MethodAnalyzer.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;
































public class MethodAnalyzer<Field extends AccessPath.FieldRef<Field>,










 Fact, 










 Stmt, 










 Method> {





















 private Method method;










 private CacheMap<Fact, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> perSourceAnalyzer = 










 new CacheMap<Fact, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>>() {










 @Override










 protected PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> createItem(Fact key) {










 return new PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>(method, key, context);










 }










 };










 private Context<Field, Fact, Stmt, Method> context;










 










 MethodAnalyzer(Method method, Context<Field, Fact, Stmt, Method> context) {










 this.method = method;










 this.context = context;










 }










 










 public void addIncomingEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact = incEdge.getCalleeSourceFact();










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer = perSourceAnalyzer.getOrCreate(calleeSourceFact.getFact());










 analyzer.bootstrapAtMethodStartPoints();










 analyzer.addIncomingEdge(incEdge);










 }





















 public void addInitialSeed(Stmt startPoint, Fact val) {










 perSourceAnalyzer.getOrCreate(val).addInitialSeed(startPoint);










 }










 










 public void addUnbalancedReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> target) {










 perSourceAnalyzer.getOrCreate(context.zeroValue).scheduleUnbalancedReturnEdgeTo(target);










 }










}














src/heros/alias/PerAccessPathMethodAnalyzer.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.ConstrainedFact;





















import java.io.FileWriter;










import java.io.IOException;










import java.util.Collection;










import java.util.List;










import java.util.Map;










import java.util.Set;





















import org.slf4j.Logger;










import org.slf4j.LoggerFactory;





















import com.google.common.collect.Lists;










import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class PerAccessPathMethodAnalyzer<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 protected static final Logger logger = LoggerFactory.getLogger(PerAccessPathMethodAnalyzer.class);










 private Fact sourceFact;










 private final AccessPath<Field> accessPath;










 private Map<WrappedFactAtStatement<Field,Fact, Stmt, Method>, WrappedFactAtStatement<Field,Fact, Stmt, Method>> reachableStatements = Maps.newHashMap();










 private List<WrappedFactAtStatement<Field, Fact, Stmt, Method>> summaries = Lists.newLinkedList();










 private Context<Field, Fact, Stmt, Method> context;










 private Method method;










 private Set<IncomingEdge<Field, Fact, Stmt, Method>> incomingEdges = Sets.newHashSet();










 private Map<AccessPath<Field>, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> nestedAnalyzers = Maps.newHashMap();










 private boolean bootstrapped = false;










 private CacheMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field, Fact, Stmt, Method>> returnSiteResolvers = new CacheMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ReturnSiteResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ReturnSiteResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private CacheMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> ctrFlowJoinResolvers = new CacheMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ControlFlowJoinResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ControlFlowJoinResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private CallEdgeResolver<Field, Fact, Stmt, Method> callEdgeResolver;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> parent;





















 public PerAccessPathMethodAnalyzer(Method method, Fact sourceFact, Context<Field, Fact, Stmt, Method> context) {










 this(method, sourceFact, context, new AccessPath<Field>(), null);










 }










 










 private PerAccessPathMethodAnalyzer(Method method, Fact sourceFact, Context<Field, Fact, Stmt, Method> context, AccessPath<Field> accPath, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> parent) {










 if(method == null)










 throw new IllegalArgumentException("Method must be not null");










 this.parent = parent;










 this.method = method;










 this.sourceFact = sourceFact;










 this.accessPath = accPath;










 this.context = context;










 this.callEdgeResolver = isZeroSource() ? new ZeroCallEdgeResolver<>(this, context.zeroHandler) : new CallEdgeResolver<>(this);










 log("initialized");










 }










 










 WrappedFact<Field, Fact, Stmt, Method> wrappedSource() {










 return new WrappedFact<>(sourceFact, accessPath, callEdgeResolver);










 }










 










 public AccessPath<Field> getAccessPath() {










 return accessPath;










 }










 










 public void bootstrapAtMethodStartPoints() {










 if(bootstrapped)










 return;










 










 callEdgeResolver.interest(this, callEdgeResolver);










 bootstrapped = true;










 for(Stmt startPoint : context.icfg.getStartPointsOf(method)) {










 WrappedFactAtStatement<Field, Fact, Stmt, Method> target = new WrappedFactAtStatement<>(startPoint, wrappedSource());










 if(!reachableStatements.containsKey(target))










 scheduleEdgeTo(target);










 }










 }










 










 public void addInitialSeed(Stmt stmt) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, wrappedSource()));










 }





















 void scheduleEdgeTo(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 if (reachableStatements.containsKey(factAtStmt)) {










 log("Merging "+factAtStmt);










 context.factHandler.merge(reachableStatements.get(factAtStmt).getFact().getFact(), factAtStmt.getFact().getFact());










 } else {










 log("Edge to "+factAtStmt);










 reachableStatements.put(factAtStmt, factAtStmt);










 context.scheduler.schedule(new Job(factAtStmt));










 }










 }





















 void log(String message) {










 logger.trace("[{}; {}{}: "+message+"]", method, sourceFact, accessPath);










 }










 










 @Override










 public String toString() {










 return method+"; "+sourceFact+accessPath;










 }





















 void processCall(WrappedFactAtStatement<Field,Fact, Stmt, Method> factAtStmt) {










 Collection<Method> calledMethods = context.icfg.getCalleesOfCallAt(factAtStmt.getStatement());










 for (Method calledMethod : calledMethods) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeCallFlow(factAtStmt, calledMethod);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 MethodAnalyzer<Field, Fact, Stmt, Method> analyzer = context.getAnalyzer(calledMethod);










 analyzer.addIncomingEdge(new IncomingEdge<Field, Fact, Stmt, Method>(this,










 factAtStmt, targetFact.getFact()));










 }










 }










 










 processCallToReturnEdge(factAtStmt);










 }





















 void processExit(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 log("New Summary: "+factAtStmt);










 if(!summaries.add(factAtStmt))










 throw new AssertionError();





















 










 for(IncomingEdge<Field, Fact, Stmt, Method> incEdge : incomingEdges) {










 applySummary(incEdge, factAtStmt);










 }





















 if(context.followReturnsPastSeeds && isZeroSource()) {










 Collection<Stmt> callSites = context.icfg.getCallersOf(method);










 for(Stmt callSite : callSites) {










 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(callSite);










 for(Stmt returnSite : returnSites) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeUnbalancedReturnFlow(










 sourceFact, factAtStmt, method, returnSite, callSite);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(new WrappedFactAtStatement<>(returnSite, targetFact.getFact()));










 }










 }










 }










 //in cases where there are no callers, the return statement would normally not be processed at all;










 //this might be undesirable if the flow function has a side effect such as registering a taint;










 //instead we thus call the return flow function will a null caller










 if(callSites.isEmpty()) {










 context.flowProcessor.computeUnbalancedReturnFlow(










 sourceFact, factAtStmt, method, null, null);










 }










 }










 }










 










 private void scheduleEdgeTo(Collection<Stmt> successors, WrappedFact<Field, Fact, Stmt, Method> fact) {










 for (Stmt stmt : successors) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, fact));










 }










 }










 










 private void processCallToReturnEdge(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 Stmt stmt = factAtStmt.getStatement();










 int numberOfPredecessors = context.icfg.getPredsOf(stmt).size(); 










 if(numberOfPredecessors > 1 || (context.icfg.isStartPoint(stmt) && numberOfPredecessors > 0)) {










 ctrFlowJoinResolvers.getOrCreate(factAtStmt.getAsFactAtStatement()).addIncoming(factAtStmt.getFact());










 }










 else {










 processNonJoiningCallToReturnFlow(factAtStmt);










 }










 }





















 private void processNonJoiningCallToReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(factAtStmt.getStatement());










 for(Stmt returnSite : returnSites) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeCallToReturnFlow(factAtStmt, returnSite);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, targetFact.getFact()));










 }










 }










 }





















 private void processNormalFlow(WrappedFactAtStatement<Field,Fact, Stmt, Method> factAtStmt) {










 Stmt stmt = factAtStmt.getStatement();










 int numberOfPredecessors = context.icfg.getPredsOf(stmt).size();










 if((numberOfPredecessors > 1 && !context.icfg.isExitStmt(stmt)) || (context.icfg.isStartPoint(stmt) && numberOfPredecessors > 0)) {










 ctrFlowJoinResolvers.getOrCreate(factAtStmt.getAsFactAtStatement()).addIncoming(factAtStmt.getFact());










 }










 else {










 processNormalNonJoiningFlow(factAtStmt);










 }










 }





















 void processFlowFromJoinStmt(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 if(context.icfg.isCallStmt(factAtStmt.getStatement()))










 processNonJoiningCallToReturnFlow(factAtStmt);










 else










 processNormalNonJoiningFlow(factAtStmt);










 }










 










 private void processNormalNonJoiningFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 final List<Stmt> successors = context.icfg.getSuccsOf(factAtStmt.getStatement());










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeNormalFlow(factAtStmt);










 for (final ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 if(targetFact.getConstraint() == null)










 scheduleEdgeTo(successors, targetFact.getFact());










 else {










 targetFact.getFact().getResolver().resolve(targetFact.getConstraint(), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer,










 Resolver<Field, Fact, Stmt, Method> resolver) {










 analyzer.scheduleEdgeTo(successors, new WrappedFact<>(targetFact.getFact().getFact(), targetFact.getFact().getAccessPath(), resolver));










 }





















 @Override










 public void canBeResolvedEmpty() {










 callEdgeResolver.resolve(targetFact.getConstraint(), this);










 }










 });










 }










 }










 }










 










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> getOrCreateNestedAnalyzer(AccessPath<Field> newAccPath) {










 if(newAccPath.equals(accessPath) || isZeroSource())










 return this;










 










 if(!nestedAnalyzers.containsKey(newAccPath)) {










 










 if(token)










 throw new AssertionError();










 










 assert accessPath.getDeltaTo(newAccPath).accesses.length <= 1;










 










 final PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> nestedAnalyzer = new PerAccessPathMethodAnalyzer<>(method, sourceFact, context, newAccPath, this);










 nestedAnalyzers.put(newAccPath, nestedAnalyzer);










 for(IncomingEdge<Field, Fact, Stmt, Method> incEdge : incomingEdges) {










 if(newAccPath.isPrefixOf(incEdge.getCalleeSourceFact().getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX)










 nestedAnalyzer.addIncomingEdge(incEdge);










 else if(incEdge.getCalleeSourceFact().getAccessPath().isPrefixOf(newAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX))










 incEdge.registerInterestCallback(nestedAnalyzer);










 }










 }










 return nestedAnalyzers.get(newAccPath);










 }










 










 boolean token;










 boolean recursiveLock;










 










 boolean isLocked() {










 if(recursiveLock)










 return true;










 if(parent == null)










 return false;










 return parent.isLocked();










 }










 










 public void addIncomingEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 if(accessPath.isPrefixOf(incEdge.getCalleeSourceFact().getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Edge: "+incEdge);










 if(!incomingEdges.add(incEdge))










 return;










 










 callEdgeResolver.interest(this, callEdgeResolver);










 










 applySummaries(incEdge);










 token=true;










 for(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> nestedAnalyzer : nestedAnalyzers.values())










 nestedAnalyzer.addIncomingEdge(incEdge);










 token=false;










 }










 else if(incEdge.getCalleeSourceFact().getAccessPath().isPrefixOf(accessPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 recursiveLock = true;










 incEdge.registerInterestCallback(this);










 recursiveLock = false;










 }










 }





















 private void applySummary(IncomingEdge<Field, Fact, Stmt, Method> incEdge, WrappedFactAtStatement<Field, Fact, Stmt, Method> exitFact) {










 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(incEdge.getCallSite());










 for(Stmt returnSite : returnSites) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeReturnFlow(context.factHandler, exitFact, method, returnSite, incEdge);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 scheduleReturnEdge(incEdge, targetFact.getFact(), returnSite);










 }










 }










 }





















 void scheduleUnbalancedReturnEdgeTo(WrappedFactAtStatement<Field, Fact, Stmt, Method> fact) {










 ReturnSiteResolver<Field,Fact,Stmt,Method> resolver = returnSiteResolvers.getOrCreate(fact.getAsFactAtStatement());










 resolver.addIncoming(new WrappedFact<>(fact.getFact().getFact(), fact.getFact().getAccessPath(), 










 fact.getFact().getResolver()), null, Delta.<Field>empty());










 }










 










 private void scheduleReturnEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge, WrappedFact<Field, Fact, Stmt, Method> fact, Stmt returnSite) {










 Delta<Field> delta = accessPath.getDeltaTo(incEdge.getCalleeSourceFact().getAccessPath());










 ReturnSiteResolver<Field, Fact, Stmt, Method> returnSiteResolver = incEdge.getCallerAnalyzer().returnSiteResolvers.getOrCreate(










 new FactAtStatement<Fact, Stmt>(fact.getFact(), returnSite));










 returnSiteResolver.addIncoming(fact, incEdge.getCalleeSourceFact().getResolver(), delta);










 }





















 private void applySummaries(IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 for(WrappedFactAtStatement<Field, Fact, Stmt, Method> summary : summaries) {










 applySummary(incEdge, summary);










 }










 }










 










 public boolean isZeroSource() {










 return sourceFact.equals(context.zeroValue);










 }





















 private class Job implements Runnable {





















 private WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt;





















 public Job(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 this.factAtStmt = factAtStmt;










 }





















 @Override










 public void run() {










 if (context.icfg.isCallStmt(factAtStmt.getStatement())) {










 processCall(factAtStmt);










 } else {










 if (context.icfg.isExitStmt(factAtStmt.getStatement())) {










 processExit(factAtStmt);










 }










 if (!context.icfg.getSuccsOf(factAtStmt.getStatement()).isEmpty()) {










 processNormalFlow(factAtStmt);










 }










 }










 }










 }





















 public CallEdgeResolver<Field, Fact, Stmt, Method> getCallEdgeResolver() {










 return callEdgeResolver;










 }










 










 public void debugInterest() {










 JsonDocument root = new JsonDocument();










 










 List<PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> worklist = Lists.newLinkedList();










 worklist.add(this);










 Set<PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> visited = Sets.newHashSet();










 










 while(!worklist.isEmpty()) {










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> current = worklist.remove(0);










 if(!visited.add(current))










 continue;










 










 JsonDocument currentMethodDoc = root.doc(current.method.toString()+ "___"+current.sourceFact);










 JsonDocument currentDoc = currentMethodDoc.doc("accPath").doc("_"+current.accessPath.toString());










 










 for(IncomingEdge<Field, Fact, Stmt, Method> incEdge : current.incomingEdges) {










 currentDoc.doc("incoming").doc(incEdge.getCallerAnalyzer().method+"___"+incEdge.getCallerAnalyzer().sourceFact).doc("_"+incEdge.getCallerAnalyzer().accessPath.toString());










 worklist.add(incEdge.getCallerAnalyzer());










 }










 }










 










 try {










 FileWriter writer = new FileWriter("debug/incoming.json");










 StringBuilder builder = new StringBuilder();










 builder.append("var root=");










 root.write(builder, 0);










 writer.write(builder.toString());










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }










 










 public void debugNestings() {










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> current = this;










 while(current.parent != null)










 current = current.parent;










 










 JsonDocument root = new JsonDocument();










 debugNestings(current, root);










 










 try {










 FileWriter writer = new FileWriter("debug/nestings.json");










 StringBuilder builder = new StringBuilder();










 builder.append("var root=");










 root.write(builder, 0);










 writer.write(builder.toString());










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }





















 private void debugNestings(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> current, JsonDocument parentDoc) {










 JsonDocument currentDoc = parentDoc.doc(current.accessPath.toString());










 for(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> nestedAnalyzer : current.nestedAnalyzers.values()) {










 debugNestings(nestedAnalyzer, currentDoc);










 }










 }










}














src/heros/alias/Resolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.List;










import java.util.Map;





















import com.google.common.collect.HashMultimap;










import com.google.common.collect.Lists;





















import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.Constraint;





















public abstract class Resolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private boolean interest = false;










 private List<InterestCallback<Field, Fact, Stmt, Method>> interestCallbacks = Lists.newLinkedList();










 protected PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer;










 private boolean canBeResolvedEmpty = false;










 










 public Resolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 this.analyzer = analyzer;










 }





















 public abstract void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback);










 










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 if(interest)










 return;










 










 log("Interest given");










 interest = true;










 for(InterestCallback<Field, Fact, Stmt, Method> callback : Lists.newLinkedList(interestCallbacks)) {










 callback.interest(analyzer, resolver);










 }










 










 if(canBeResolvedEmpty)










 interestCallbacks = null;










 }










 










 protected void canBeResolvedEmpty() {










 if(canBeResolvedEmpty)










 return;










 










 canBeResolvedEmpty = true;










 for(InterestCallback<Field, Fact, Stmt, Method> callback : Lists.newLinkedList(interestCallbacks)) {










 callback.canBeResolvedEmpty();










 }










 










 if(interest)










 interestCallbacks = null;










 }





















 public boolean isInterestGiven() {










 return interest;










 }





















 protected void registerCallback(InterestCallback<Field, Fact, Stmt, Method> callback) {










 if(interest) {










 callback.interest(analyzer, this);










 }










 else {










 log("Callback registered");










 interestCallbacks.add(callback);










 }





















 if(canBeResolvedEmpty)










 callback.canBeResolvedEmpty();










 }










 










 protected abstract void log(String message);










 










}














src/heros/alias/ReturnSiteResolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















import java.util.Map;










import java.util.Set;





















import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private Stmt returnSite;










 private AccessPath<Field> resolvedAccPath;










 private boolean propagated = false;










 private Set<ReturnEdge> incomingFacts;










 private Map<AccessPath<Field>, ReturnSiteResolver<Field, Fact, Stmt, Method>> nestedResolvers = Maps.newHashMap();










 private ReturnSiteResolver<Field, Fact, Stmt, Method> parent;





















 public ReturnSiteResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt returnSite) {










 this(analyzer, returnSite, new AccessPath<Field>(), null);










 }





















 private ReturnSiteResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt returnSite, AccessPath<Field> resolvedAccPath, ReturnSiteResolver<Field, Fact, Stmt, Method> parent) {










 super(analyzer);










 this.returnSite = returnSite;










 this.resolvedAccPath = resolvedAccPath;










 this.parent = parent;










 this.incomingFacts = Sets.newHashSet();










 }










 










 @Override










 public String toString() {










 return "<"+resolvedAccPath+":"+returnSite+">";










 }










 










 public AccessPath<Field> getResolvedAccessPath() {










 return resolvedAccPath;










 }










 










 public void addIncoming(final WrappedFact<Field, Fact, Stmt, Method> fact, 










 Resolver<Field, Fact, Stmt, Method> resolverAtCaller, 










 Delta<Field> callDelta) {










 










 addIncoming(new ReturnEdge(fact, resolverAtCaller, callDelta));










 }










 










 private void addIncoming(final ReturnEdge retEdge) {










 if(resolvedAccPath.isPrefixOf(retEdge.incAccessPath) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Edge "+retEdge);










 if(!incomingFacts.add(retEdge))










 return;





















 interest(analyzer, this);










 










 for(ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver : nestedResolvers.values())










 nestedResolver.addIncoming(nestedResolver.new ReturnEdge(retEdge.incFact, retEdge.incAccessPath, retEdge.incResolver, 










 retEdge.resolverAtCaller, retEdge.callDelta, retEdge.usedAccessPathOfIncResolver));





















 if(!propagated) {










 propagated=true;










 analyzer.scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, 










 new WrappedFact<>(retEdge.incFact, new AccessPath<Field>(), this)));










 }










 }










 else if(retEdge.incAccessPath.isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 log("Incoming potential prefix:  "+retEdge);










 retEdge.resolveViaDelta();










 }










 }










 










 protected void log(String message) {










 analyzer.log("Return Site "+toString()+": "+message);










 }





















 @Override










 public void resolve(Constraint<Field> constraint, final InterestCallback<Field, Fact, Stmt, Method> callback) {










 log("Resolve: "+constraint);










 if(!constraint.canBeAppliedTo(resolvedAccPath))










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);










 }










 










 private ReturnSiteResolver<Field, Fact, Stmt, Method> getOrCreateNestedResolver(AccessPath<Field> candidateAccPath) {










 if(resolvedAccPath.equals(candidateAccPath))










 return this;










 










 if(!nestedResolvers.containsKey(candidateAccPath)) {










 assert resolvedAccPath.getDeltaTo(candidateAccPath).accesses.length <= 1;










 final ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver = new ReturnSiteResolver<>(analyzer, returnSite, candidateAccPath, this);










 nestedResolver.propagated = true;










 nestedResolvers.put(candidateAccPath, nestedResolver);





















 for(ReturnSiteResolver<Field, Fact, Stmt, Method>.ReturnEdge retEdge: incomingFacts) {










 nestedResolver.addIncoming(nestedResolver.new ReturnEdge(retEdge.incFact, retEdge.incAccessPath, retEdge.incResolver, 










 retEdge.resolverAtCaller, retEdge.callDelta, retEdge.usedAccessPathOfIncResolver));










 } 










 }










 return nestedResolvers.get(candidateAccPath);










 }










 










 private class ReturnEdge {





















 final Fact incFact;










 final Resolver<Field, Fact, Stmt, Method> resolverAtCaller;










 final Delta<Field> callDelta;










 final AccessPath<Field> incAccessPath;










 final Resolver<Field, Fact, Stmt, Method> incResolver;










 final Delta<Field> usedAccessPathOfIncResolver;





















 public ReturnEdge(WrappedFact<Field, Fact, Stmt, Method> fact, Resolver<Field, Fact, Stmt, Method> resolverAtCaller,










 Delta<Field> callDelta) {










 this(fact.getFact(), fact.getAccessPath(), fact.getResolver(), resolverAtCaller, callDelta, Delta.<Field>empty());










 }










 










 private ReturnEdge(Fact incFact, AccessPath<Field> incAccessPath, Resolver<Field, Fact, Stmt, Method> incResolver, 










 Resolver<Field, Fact, Stmt, Method> resolverAtCaller, Delta<Field> callDelta, Delta<Field> usedAccessPathOfIncResolver) {










 this.incFact = incFact;










 this.incAccessPath = incAccessPath;










 this.incResolver = incResolver;










 this.resolverAtCaller = resolverAtCaller;










 this.callDelta = callDelta;










 this.usedAccessPathOfIncResolver = usedAccessPathOfIncResolver;










 }










 










 @Override










 public String toString() {










 return String.format("IncFact: %s%s, Delta: %s, IncResolver: <%s:%s>, ResolverAtCallSite: %s", incFact, incAccessPath, callDelta, usedAccessPathOfIncResolver, incResolver, resolverAtCaller);










 }










 










 public void resolveViaDelta() {










 if(incResolver == null || incResolver instanceof CallEdgeResolver) {










 resolveViaDeltaAndPotentiallyDelegateToCallSite();










 } else {










 //resolve via incoming facts resolver










 Delta<Field> delta = usedAccessPathOfIncResolver.applyTo(incAccessPath, true).getDeltaTo(resolvedAccPath);










 assert delta.accesses.length <= 1;










 incResolver.resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {





















 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, resolver, resolverAtCaller, callDelta, incAccessPath.getDeltaTo(resolvedAccPath)));










 ReturnSiteResolver.this.interest(analyzer, resolver);










 }










 










 @Override










 public void canBeResolvedEmpty() {










 resolveViaDeltaAndPotentiallyDelegateToCallSite();










 }










 });










 } 










 }





















 private void resolveViaDeltaAndPotentiallyDelegateToCallSite() {










 final AccessPath<Field> currAccPath = callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath, true), true);










 if(resolvedAccPath.isPrefixOf(currAccPath) == PrefixTestResult.GUARANTEED_PREFIX) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver));










 ReturnSiteResolver.this.interest(analyzer, ReturnSiteResolver.this);










 } else if(currAccPath.isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 resolveViaCallSiteResolver(currAccPath);










 }










 }





















 protected void resolveViaCallSiteResolver(AccessPath<Field> currAccPath) {










 if(resolverAtCaller == null || resolverAtCaller instanceof CallEdgeResolver) {










 ReturnSiteResolver.this.canBeResolvedEmpty();










 } else {










 resolverAtCaller.resolve(new DeltaConstraint<>(currAccPath.getDeltaTo(resolvedAccPath)), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, null, resolver, Delta.<Field>empty(), incAccessPath.getDeltaTo(resolvedAccPath)));










 ReturnSiteResolver.this.interest(analyzer, ReturnSiteResolver.this);










 }










 










 @Override










 public void canBeResolvedEmpty() {










 ReturnSiteResolver.this.canBeResolvedEmpty();










 }










 });










 }










 }










 }





















 public Stmt getReturnSite() {










 return returnSite;










 }










}














src/heros/alias/Scheduler.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.LinkedList;










import com.google.common.collect.Lists;





















public class Scheduler {





















 private LinkedList<Runnable> worklist = Lists.newLinkedList();










 










 public void schedule(Runnable job) {










 worklist.add(job);










 }





















 public void runAndAwaitCompletion() {










 while(!worklist.isEmpty()) {










 worklist.removeLast().run();










 }










 }





















}














src/heros/alias/TestDebugger.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.io.FileWriter;










import java.io.IOException;










import java.util.Set;





















import com.google.common.collect.Sets;





















import heros.InterproceduralCFG;










import heros.alias.TestHelper.Edge;





















public class TestDebugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 private JsonDocument root = new JsonDocument();










 private I icfg;










 










 public void writeJsonDebugFile(String filename) {










 try {










 FileWriter writer = new FileWriter(filename);










 StringBuilder builder = new StringBuilder();










 builder.append("var root=");










 root.write(builder, 0);










 writer.write(builder.toString());










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }










 










 /* (non-Javadoc)










	 * @see heros.alias.Debugger#setICFG(I)










	 */










 @Override










 public void setICFG(I icfg) {










 this.icfg = icfg;










 }





















 /* (non-Javadoc)










	 * @see heros.alias.Debugger#initialSeed(Stmt)










	 */










 @Override










 public void initialSeed(Stmt stmt) {










 stmt(stmt).keyValue("seed", "true");










 










 includeSuccessors(stmt, Sets.<Stmt> newHashSet());










 }










 










 private void includeSuccessors(Stmt stmt, Set<Stmt> visited) {










 if(!visited.add(stmt))










 return;










 










 JsonDocument doc = stmt(stmt);










 for(Stmt succ : icfg.getSuccsOf(stmt)) {










 doc.array("successors").add(succ.toString());










 stmt(succ);










 includeSuccessors(succ, visited);










 }










 










 if(icfg.isCallStmt(stmt)) {










 for(Method m : icfg.getCalleesOfCallAt(stmt)) {










 doc.doc("calls").doc(m.toString());










 for(Stmt sp : icfg.getStartPointsOf(m)) {










 stmt(sp).keyValue("startPoint", "true");










 includeSuccessors(sp, visited);










 }










 }










 for(Stmt retSite :icfg.getReturnSitesOfCallAt(stmt)) {










 doc.array("successors").add(retSite.toString());










 stmt(retSite);










 includeSuccessors(retSite, visited);










 }










 }










 if(icfg.isExitStmt(stmt)) {










 for(Stmt callSite : icfg.getCallersOf(icfg.getMethodOf(stmt))) {










 for(Stmt retSite : icfg.getReturnSitesOfCallAt(callSite)) {










 doc.doc("returns").doc(retSite.toString());










 includeSuccessors(retSite, visited);










 }










 }










 }










 }





















 protected JsonDocument stmt(Stmt stmt) {










 Method methodOf = icfg.getMethodOf(stmt);










 return root.doc("methods").doc(methodOf.toString()).doc(stmt.toString());










 }










 










 public void expectNormalFlow(Stmt unit, String expectedFlowFunctionsToString) {










 stmt(unit).keyValue("flow", expectedFlowFunctionsToString);










 }





















 public void expectCallFlow(Stmt callSite, Method destinationMethod, String expectedFlowFunctionsToString) {










 stmt(callSite).doc("calls").doc(destinationMethod.toString()).keyValue("flow", expectedFlowFunctionsToString);










 }





















 public void expectReturnFlow(Stmt exitStmt, Stmt returnSite, String expectedFlowFunctionsToString) {










 if(returnSite != null)










 stmt(exitStmt).doc("returns").doc(returnSite.toString()).keyValue("flow", expectedFlowFunctionsToString);










 }





















 static void tabs(int tabs, StringBuilder builder) {










 for(int i=0; i<tabs; i++)










 builder.append("\t");










 }





















}














src/heros/alias/Transition.java








View file @ 3398e46f






......@@ -72,14 +72,16 @@ public interface Transition<FieldRef> {









 } else {










 Set<FieldRef> otherExcludedFields = ((ExclusionPathTransition<FieldRef>) t).excludedFields;










 boolean intersection = false;










 boolean containsAll = true;










 boolean containsAll = excludedFields.containsAll(otherExcludedFields);










 boolean oppositeContainsAll = otherExcludedFields.containsAll(excludedFields);










 for(FieldRef field : excludedFields) {










 if(otherExcludedFields.contains(field))










 if(otherExcludedFields.contains(field)) {










 intersection = true;










 else










  containsAll = false;










  break;










 }










 }










 return new MatchResult<>(containsAll || !intersection, containsAll);










 boolean potentialMatch = oppositeContainsAll || !intersection || (!containsAll && !oppositeContainsAll);










 return new MatchResult<>(potentialMatch, oppositeContainsAll);










 }










 










 return new MatchResult<>(false, false);



......














test/heros/alias/Fact.java

→

src/heros/alias/WrappedFact.java








View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at



......@@ -10,87 +10,58 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;





















import java.util.ArrayList;










import java.util.Arrays;










import java.util.regex.Matcher;










import java.util.regex.Pattern;










public class WrappedFact<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method>{





















import com.google.common.base.Joiner;










import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, TestFieldRef, Fact> {





















 public final String baseValue;










 public final AccessPath<TestFieldRef> accessPath;










 private final Fact fact;










 private final AccessPath<Field> accessPath;










 private final Resolver<Field, Fact, Stmt, Method> resolver;










 










 public Fact(String name) {










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 AccessPath<TestFieldRef> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();










 baseValue = name.substring(0, firstSeparator);










 matcher.reset();










 WrappedFact(Fact fact, AccessPath<Field> accessPath, Resolver<Field, Fact, Stmt, Method> resolver) {










 assert fact != null;










 assert accessPath != null;










 assert resolver != null;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(separator.equals(".")) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(new TestFieldRef(identifier));










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 TestFieldRef[] fExcl = new TestFieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new TestFieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 }










 }










 this.fact = fact;










 this.accessPath = accessPath;










 this.resolver = resolver;










 }










 










 public Fact(String baseValue, AccessPath<TestFieldRef> accessPath) {










 this.baseValue = baseValue;










 this.accessPath = accessPath;










 public Fact getFact() {










 return fact;










 }










 










 @Override










 public String toString() {










 return "[Fact "+baseValue+(accessPath.isEmpty() ? "" : accessPath)+"]";










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta, boolean merge) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath, merge), resolver); //TODO keep resolver?










 }





















 @Override










 public String getBaseValue() {










 return baseValue;










 }





















 @Override










 public AccessPath<TestFieldRef> getAccessPath() {










 public AccessPath<Field> getAccessPath() {










 return accessPath;










 }





















 @Override










 public void addNeighbor(Fact originalAbstraction) {










 










 










 public WrappedFact<Field, Fact, Stmt, Method> applyConstraint(Constraint<Field> constraint, Fact zeroValue, boolean sourceFact) {










 if(fact.equals(zeroValue))










 return this;










 else










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath, sourceFact), resolver);










 }





















 










 @Override










 public void setCallingContext(Fact callingContext) {










 










 public String toString() {










 String result = fact.toString()+accessPath;










 if(resolver != null)










 result+=resolver.toString();










 return result;










 }





















 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((accessPath == null) ? 0 : accessPath.hashCode());










 result = prime * result + ((baseValue == null) ? 0 : baseValue.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -100,25 +71,29 @@ public class Fact implements FieldSensitiveFact<String, TestFieldRef, Fact> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof Fact))










 if (getClass() != obj.getClass())










 return false;










 Fact other = (Fact) obj;










 WrappedFact other = (WrappedFact) obj;










 if (accessPath == null) {










 if (other.accessPath != null)










 return false;










 } else if (!accessPath.equals(other.accessPath))










 return false;










 if (baseValue == null) {










 if (other.baseValue != null)










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!baseValue.equals(other.baseValue))










 } else if (!fact.equals(other.fact))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }





















 @Override










 public Fact cloneWithAccessPath(AccessPath<TestFieldRef> accessPath) {










 return new Fact(baseValue, accessPath);










 public Resolver<Field, Fact, Stmt, Method> getResolver() {










 return resolver;










 }










 










 



......














src/heros/alias/SummaryEdge.java

→

src/heros/alias/WrappedFactAtStatement.java








View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at



......@@ -10,70 +10,66 @@









 ******************************************************************************/










package heros.alias;





















public class SummaryEdge<D, N> {










public class WrappedFactAtStatement<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private D sourceFact;










 private N targetStmt;










 private D targetFact;










 private WrappedFact<Field,Fact, Stmt, Method> fact;










 private Stmt stmt;





















 public WrappedFactAtStatement(Stmt stmt, WrappedFact<Field, Fact, Stmt, Method> fact) {










 this.stmt = stmt;










 this.fact = fact;










 }





















 public WrappedFact<Field,Fact, Stmt, Method> getFact() {










 return fact;










 }





















 public Stmt getStatement() {










 return stmt;










 }










 










 public FactAtStatement<Fact, Stmt> getAsFactAtStatement() {










 return new FactAtStatement<Fact, Stmt>(fact.getFact(), stmt);










 }










 










 public SummaryEdge(D sourceFact, N targetStmt, D targetFact) {










 this.sourceFact = sourceFact;










 this.targetStmt = targetStmt;










 this.targetFact = targetFact;










 public boolean canDeltaBeApplied(AccessPath.Delta<Field> delta) {










 return delta.canBeAppliedTo(fact.getAccessPath());










 }










 










 @Override










 public String toString() {










 return "[SummaryEdge: "+sourceFact+" -> "+targetFact+" @stmt: "+targetStmt+"]";










 return fact+" @ "+stmt;










 }





















 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((sourceFact == null) ? 0 : sourceFact.hashCode());










 result = prime * result + ((targetFact == null) ? 0 : targetFact.hashCode());










 result = prime * result + ((targetStmt == null) ? 0 : targetStmt.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((stmt == null) ? 0 : stmt.hashCode());










 return result;










 }










 





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SummaryEdge))










 if (getClass() != obj.getClass())










 return false;










 SummaryEdge other = (SummaryEdge) obj;










 if (sourceFact == null) {










 if (other.sourceFact != null)










 WrappedFactAtStatement other = (WrappedFactAtStatement) obj;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!sourceFact.equals(other.sourceFact))










 } else if (!fact.equals(other.fact))










 return false;










 if (targetFact == null) {










 if (other.targetFact != null)










 if (stmt == null) {










 if (other.stmt != null)










 return false;










 } else if (!targetFact.equals(other.targetFact))










 return false;










 if (targetStmt == null) {










 if (other.targetStmt != null)










 return false;










 } else if (!targetStmt.equals(other.targetStmt))










 } else if (!stmt.equals(other.stmt))










 return false;










 return true;










 }





















 public D getSourceFact() {










 return sourceFact;










 }










 










 public D getTargetFact() {










 return targetFact;










 }










 










 public N getTargetStmt() {










 return targetStmt;










 }










 










}














src/heros/alias/ZeroCallEdgeResolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class ZeroCallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends CallEdgeResolver<Field, Fact, Stmt, Method> {





















 private ZeroHandler<Field> zeroHandler;





















 public ZeroCallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, ZeroHandler<Field> zeroHandler) {










 super(analyzer);










 this.zeroHandler = zeroHandler;










 }





















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) {










 if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(new AccessPath<Field>(), true)))










 callback.interest(analyzer, this);










 }










 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 }










}














src/heros/alias/FieldSensitiveFact.java

→

src/heros/alias/ZeroHandler.java








View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch, Johannes Späth.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch, Johannes Späth - initial API and implementation










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.solver.LinkedNode;










public interface ZeroHandler<Field extends AccessPath.FieldRef<Field>> {





















public interface FieldSensitiveFact<BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D> extends LinkedNode<D>{





















 BaseValue getBaseValue();










 










 AccessPath<FieldRef> getAccessPath();










 










 D cloneWithAccessPath(AccessPath<FieldRef> accessPath);










 










 boolean shouldGenerateAccessPath(AccessPath<Field> accPath);










}














test/heros/alias/AccessPathTest.java








View file @ 3398e46f






......@@ -19,6 +19,7 @@ import org.junit.Test;




















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.SubAccessPath.*;














......@@ -36,7 +37,7 @@ public class AccessPathTest {









 }










 return result;










 }










 





















 private static SetOfPossibleFieldAccesses<TestFieldRef> anyOf(String...fields) {










 Set<TestFieldRef> set = Sets.newHashSet();










 for(String f : fields)



......@@ -49,7 +50,7 @@ public class AccessPathTest {









 }










 










 private static AccessPath<TestFieldRef> ap(SubAccessPath<TestFieldRef>... path) {










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet(), null);










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet());










 }










 










 @Test



......@@ -64,6 +65,12 @@ public class AccessPathTest {









 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMultipleFieldsAndMerge() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(f("b", "a")));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<TestFieldRef> sut = ap(s("a"));



......@@ -190,6 +197,20 @@ public class AccessPathTest {









 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaFromSetToSet() {










 Delta<TestFieldRef> actual = ap(anyOf("a")).appendExcludedFieldReference(f("f")).getDeltaTo(ap(anyOf("a")).appendExcludedFieldReference(f("g")));










 assertArrayEquals(new SubAccessPath[] { anyOf("a") }, actual.accesses);










 assertEquals(Sets.newHashSet(f("g")), actual.exclusions);










 }










 










 @Test










 public void emptyDeltaOnEqualExclusions() {










 AccessPath<TestFieldRef> actual = ap().appendExcludedFieldReference(f("f"));










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).exclusions.equals(Sets.newHashSet(f("f"))));










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;



......@@ -227,6 +248,12 @@ public class AccessPathTest {









 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void multipleExclPrefixOfMultipleExcl() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference(f("f", "h"))));










 }










 










 @Test










 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));



......














test/heros/alias/AccessPathUtilTest.java








View file @ 3398e46f






......@@ -11,125 +11,109 @@









package heros.alias;





















import static heros.alias.AccessPath.PrefixTestResult.*;










import static heros.alias.AccessPathUtil.applyAbstractedSummary;










import static heros.alias.AccessPathUtil.isPrefixOf;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertTrue;





















import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import heros.alias.AccessPath.PrefixTestResult;





















import org.junit.Test;





















public class AccessPathUtilTest {





















 public static AccessPath<TestFieldRef> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<TestFieldRef> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(new TestFieldRef(identifier));










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 TestFieldRef[] fExcl = new TestFieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new TestFieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 }










 }










 return accessPath;










 }










 










 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a"), new Fact("a.f")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a")));










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("f")));










 assertEquals(NO_PREFIX, ap("f").isPrefixOf(ap("")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a"), new Fact("a")));










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.b"), new Fact("a.b.c")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.b.c"), new Fact("a.b")));










 assertEquals(GUARANTEED_PREFIX, ap("b").isPrefixOf(ap("b.c")));










 assertEquals(NO_PREFIX, ap("b.c").isPrefixOf(ap("b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.g")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.g"), new Fact("a^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g")));










 assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a^f")));










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f,g"), new Fact("a^f,g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertEquals(POTENTIAL_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.g.g")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.f.h")));










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f,g"), new Fact("a^g")));










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f")));










 assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.g.h")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h")));










 }










 










 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a"), new Fact("a^f")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a")));










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));










 










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a.f^g^h")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 }










 










 @Test










 public void testAbstractedSummary() {










 assertEquals(new Fact("z.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h")));










 assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f")));










 }










 










 @Test










 public void testAbstractedFieldAccessSummary() {










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryIntroducesFieldAccess() {










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.c"), new SummaryEdge<>(new Fact("a"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryRemovesFieldAccess() {










 assertEquals(new Fact("z.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testNonAbstractedSummary() {










 assertEquals(new Fact("z"), applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testSummaryWithExcludedField() {










 assertEquals(new Fact("a.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testIdentityForExclusions() {










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a"))).get());










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).get());










 }










 










 @Test










 public void testMergeExclusions() {










 assertEquals(new Fact("a^f,g"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testNullOnImpossibleSubsumption() {










 assertFalse(applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).isPresent());










 }










}














test/heros/alias/ControlFlowJoinResolverTest.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;





















import org.junit.Before;










import org.junit.Test;










import org.mockito.ArgumentMatcher;










import org.mockito.Mockito;










import org.mockito.invocation.InvocationOnMock;










import org.mockito.stubbing.Answer;










import org.mockito.verification.VerificationMode;





















public class ControlFlowJoinResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement joinStmt;










 private ControlFlowJoinResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 joinStmt = new TestStatement("joinStmt");










 sut = new ControlFlowJoinResolver<>(analyzer, joinStmt);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);










 }





















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver));










 verify(analyzer).processFlowFromJoinStmt(eq(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver));










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));










 }










 










 










 private class ResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;





















 public ResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 this.accPath = accPath;










 }





















 @Override










 public boolean matches(Object argument) {










 ControlFlowJoinResolver resolver = (ControlFlowJoinResolver) argument;










 return resolver.isInterestGiven() && resolver.getResolvedAccessPath().equals(accPath) && resolver.getJoinStmt().equals(joinStmt);










 }










 }










}














test/heros/alias/EdgeBuilder.java








View file @ 3398e46f






......@@ -32,43 +32,44 @@ public abstract class EdgeBuilder {




















 public static class CallSiteBuilder extends EdgeBuilder {





















 private Statement callSite;










 private TestStatement callSite;





















 public CallSiteBuilder(Statement callSite) {










 public CallSiteBuilder(TestStatement callSite) {










 this.callSite = callSite;










 }





















 public CallSiteBuilder calls(String method, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.CallEdge(callSite, new Method(method), flows));










 edges.add(new TestHelper.CallEdge(callSite, new TestMethod(method), flows));










 return this;










 }










 










 public CallSiteBuilder retSite(String returnSite, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new Statement(returnSite), flows));










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new TestStatement(returnSite), flows));










 return this;










 }










 }










 










 public static class NormalStmtBuilder extends EdgeBuilder {





















 private Statement stmt;










 private TestStatement stmt;










 private ExpectedFlowFunction[] flowFunctions;





















 public NormalStmtBuilder(Statement stmt) {










 public NormalStmtBuilder(TestStatement stmt, ExpectedFlowFunction[] flowFunctions) {










 this.stmt = stmt;










 this.flowFunctions = flowFunctions;










 }





















 public NormalStmtBuilder succ(String succ, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.NormalEdge(stmt, new Statement(succ), flows));










 public NormalStmtBuilder succ(String succ) {










 edges.add(new TestHelper.NormalEdge(stmt, new TestStatement(succ), flowFunctions));










 return this;










 }










 










 }










 










 public static class ExitStmtBuilder extends EdgeBuilder {





















 private Statement exitStmt;










 private TestStatement exitStmt;





















 public ExitStmtBuilder(Statement exitStmt) {










 public ExitStmtBuilder(TestStatement exitStmt) {










 this.exitStmt = exitStmt;










 }










 



......@@ -77,7 +78,7 @@ public abstract class EdgeBuilder {









 return this;










 }





















 public ExitStmtBuilder returns(Statement callSite, Statement returnSite, ExpectedFlowFunction... flows) {










 public ExitStmtBuilder returns(TestStatement callSite, TestStatement returnSite, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.ReturnEdge(callSite, exitStmt, returnSite, flows));










 return this;










 }



......














test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ 3398e46f





This diff is collapsed.
Click to expand it.













test/heros/alias/ReturnSiteResolverTest.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;





















import org.junit.Before;










import org.junit.Test;










import org.mockito.ArgumentMatcher;










import org.mockito.Mockito;










import org.mockito.invocation.InvocationOnMock;










import org.mockito.stubbing.Answer;










import org.mockito.verification.VerificationMode;





















public class ReturnSiteResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement returnSite;










 private ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 returnSite = new TestStatement("returnSite");










 sut = new ReturnSiteResolver<>(analyzer, returnSite);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);










 }





















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 verify(analyzer).scheduleEdgeTo(eq(new WrappedFactAtStatement<>(returnSite, new WrappedFact<>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver), callEdgeResolver, getDelta());










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }










 










 @Test










 public void resolveViaDelta() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }










 










 @Test










 public void resolveViaDeltaTwice() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a", "b"));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(innerCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));










 }










 










 @Test










 public void resolveViaDeltaAndThenViaCallSite() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(innerCallback).canBeResolvedEmpty();










 }





















 @Test










 public void resolveViaCallEdgeResolverAtCallSite() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).canBeResolvedEmpty();










 }










 










 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 @Test










 public void resolveViaResolverAtCallSiteTwice() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback innerCallback = (InterestCallback) invocation.getArguments()[1];










 innerCallback.interest(analyzer, nestedResolver);










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback innerCallback = (InterestCallback) invocation.getArguments()[1];










 innerCallback.interest(analyzer, nestedResolver);










 return null;










 }










 }).when(nestedResolver).resolve(eq(getDeltaConstraint("b")), any(InterestCallback.class));










 










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), secondCallback);










 return null;










 }










 










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(secondCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));










 }










 










 @Test










 public void resolveAsEmptyViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Delta<TestFieldRef> delta = new AccessPath<TestFieldRef>().getDeltaTo(new AccessPath<TestFieldRef>().appendExcludedFieldReference(new TestFieldRef("a")));










 










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback innerCallback = (InterestCallback) invocation.getArguments()[1];










 innerCallback.canBeResolvedEmpty();










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));





















 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, delta);










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback, never()).canBeResolvedEmpty();










 verify(callback, never()).interest(any(PerAccessPathMethodAnalyzer.class), any(Resolver.class));










 }










 










 @Test










 public void resolveViaCallSiteResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 private class ReturnSiteResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;





















 public ReturnSiteResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 this.accPath = accPath;










 }





















 @Override










 public boolean matches(Object argument) {










 ReturnSiteResolver resolver = (ReturnSiteResolver) argument;










 return resolver.isInterestGiven() && resolver.getResolvedAccessPath().equals(accPath) && resolver.getReturnSite().equals(returnSite);










 }










 }










}









Prev


1


2


3


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Open sidebar



Joshua Garcia heros
Commits

3398e46f







Open sidebar



Joshua Garcia heros
Commits

3398e46f




Open sidebar

Joshua Garcia heros
Commits

3398e46f


Joshua GarciaherosherosCommits
3398e46f








Commit
3398e46f


authored
Feb 25, 2015
by


Johannes Lerch



Browse files




rewrite of ifds solver







parent
55cdd2d8













Changes
45




Expand all
Hide whitespace changes

Inline
Side-by-side















src/heros/alias/InterestCallback.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public interface InterestCallback<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver);










 










//	void partiallyResolved(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver, AccessPath<Field> resolvedAccPath);










 










 void canBeResolvedEmpty();










}














src/heros/alias/JsonArray.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.List;





















import com.google.common.collect.Lists;





















class JsonArray {










 










 private List<String> items = Lists.newLinkedList();










 










 public void add(String item) {










 items.add(item);










 }





















 public void write(StringBuilder builder, int tabs) {










 builder.append("[\n");










 for(String item: items) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+item+"\",\n");










 }










 TestDebugger.tabs(tabs, builder); builder.append("]");










 }










}




\ No newline at end of file














src/heros/alias/JsonDocument.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Map;










import java.util.Map.Entry;





















import com.google.common.collect.Maps;





















class JsonDocument {










 










 private CacheMap<String, JsonDocument> documents = new CacheMap<String, JsonDocument>() {










 @Override










 protected JsonDocument createItem(String key) {










 return new JsonDocument();










 }










 };










 private CacheMap<String, JsonArray> arrays = new CacheMap<String, JsonArray>() {










 @Override










 protected JsonArray createItem(String key) {










 return new JsonArray();










 }










 };










 private Map<String, String> keyValuePairs = Maps.newHashMap();










 










 public JsonDocument doc(String key) {










 return documents.getOrCreate(key);










 }










 










 public JsonArray array(String key) {










 return arrays.getOrCreate(key);










 }










 










 public void keyValue(String key, String value) {










 keyValuePairs.put(key, value);










 }










 










 public void write(StringBuilder builder, int tabs) {










 builder.append("{\n");










 










 for(Entry<String, String> entry : keyValuePairs.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n");










 }










 










 for(Entry<String, JsonArray> entry : arrays.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");





















 }










 










 for(Entry<String, JsonDocument> entry : documents.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");










 }










 










 TestDebugger.tabs(tabs, builder); builder.append("}");










 }





















}




\ No newline at end of file














src/heros/alias/MethodAnalyzer.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;
































public class MethodAnalyzer<Field extends AccessPath.FieldRef<Field>,










 Fact, 










 Stmt, 










 Method> {





















 private Method method;










 private CacheMap<Fact, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> perSourceAnalyzer = 










 new CacheMap<Fact, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>>() {










 @Override










 protected PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> createItem(Fact key) {










 return new PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>(method, key, context);










 }










 };










 private Context<Field, Fact, Stmt, Method> context;










 










 MethodAnalyzer(Method method, Context<Field, Fact, Stmt, Method> context) {










 this.method = method;










 this.context = context;










 }










 










 public void addIncomingEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact = incEdge.getCalleeSourceFact();










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer = perSourceAnalyzer.getOrCreate(calleeSourceFact.getFact());










 analyzer.bootstrapAtMethodStartPoints();










 analyzer.addIncomingEdge(incEdge);










 }





















 public void addInitialSeed(Stmt startPoint, Fact val) {










 perSourceAnalyzer.getOrCreate(val).addInitialSeed(startPoint);










 }










 










 public void addUnbalancedReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> target) {










 perSourceAnalyzer.getOrCreate(context.zeroValue).scheduleUnbalancedReturnEdgeTo(target);










 }










}














src/heros/alias/PerAccessPathMethodAnalyzer.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.ConstrainedFact;





















import java.io.FileWriter;










import java.io.IOException;










import java.util.Collection;










import java.util.List;










import java.util.Map;










import java.util.Set;





















import org.slf4j.Logger;










import org.slf4j.LoggerFactory;





















import com.google.common.collect.Lists;










import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class PerAccessPathMethodAnalyzer<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 protected static final Logger logger = LoggerFactory.getLogger(PerAccessPathMethodAnalyzer.class);










 private Fact sourceFact;










 private final AccessPath<Field> accessPath;










 private Map<WrappedFactAtStatement<Field,Fact, Stmt, Method>, WrappedFactAtStatement<Field,Fact, Stmt, Method>> reachableStatements = Maps.newHashMap();










 private List<WrappedFactAtStatement<Field, Fact, Stmt, Method>> summaries = Lists.newLinkedList();










 private Context<Field, Fact, Stmt, Method> context;










 private Method method;










 private Set<IncomingEdge<Field, Fact, Stmt, Method>> incomingEdges = Sets.newHashSet();










 private Map<AccessPath<Field>, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> nestedAnalyzers = Maps.newHashMap();










 private boolean bootstrapped = false;










 private CacheMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field, Fact, Stmt, Method>> returnSiteResolvers = new CacheMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ReturnSiteResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ReturnSiteResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private CacheMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> ctrFlowJoinResolvers = new CacheMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ControlFlowJoinResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ControlFlowJoinResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private CallEdgeResolver<Field, Fact, Stmt, Method> callEdgeResolver;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> parent;





















 public PerAccessPathMethodAnalyzer(Method method, Fact sourceFact, Context<Field, Fact, Stmt, Method> context) {










 this(method, sourceFact, context, new AccessPath<Field>(), null);










 }










 










 private PerAccessPathMethodAnalyzer(Method method, Fact sourceFact, Context<Field, Fact, Stmt, Method> context, AccessPath<Field> accPath, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> parent) {










 if(method == null)










 throw new IllegalArgumentException("Method must be not null");










 this.parent = parent;










 this.method = method;










 this.sourceFact = sourceFact;










 this.accessPath = accPath;










 this.context = context;










 this.callEdgeResolver = isZeroSource() ? new ZeroCallEdgeResolver<>(this, context.zeroHandler) : new CallEdgeResolver<>(this);










 log("initialized");










 }










 










 WrappedFact<Field, Fact, Stmt, Method> wrappedSource() {










 return new WrappedFact<>(sourceFact, accessPath, callEdgeResolver);










 }










 










 public AccessPath<Field> getAccessPath() {










 return accessPath;










 }










 










 public void bootstrapAtMethodStartPoints() {










 if(bootstrapped)










 return;










 










 callEdgeResolver.interest(this, callEdgeResolver);










 bootstrapped = true;










 for(Stmt startPoint : context.icfg.getStartPointsOf(method)) {










 WrappedFactAtStatement<Field, Fact, Stmt, Method> target = new WrappedFactAtStatement<>(startPoint, wrappedSource());










 if(!reachableStatements.containsKey(target))










 scheduleEdgeTo(target);










 }










 }










 










 public void addInitialSeed(Stmt stmt) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, wrappedSource()));










 }





















 void scheduleEdgeTo(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 if (reachableStatements.containsKey(factAtStmt)) {










 log("Merging "+factAtStmt);










 context.factHandler.merge(reachableStatements.get(factAtStmt).getFact().getFact(), factAtStmt.getFact().getFact());










 } else {










 log("Edge to "+factAtStmt);










 reachableStatements.put(factAtStmt, factAtStmt);










 context.scheduler.schedule(new Job(factAtStmt));










 }










 }





















 void log(String message) {










 logger.trace("[{}; {}{}: "+message+"]", method, sourceFact, accessPath);










 }










 










 @Override










 public String toString() {










 return method+"; "+sourceFact+accessPath;










 }





















 void processCall(WrappedFactAtStatement<Field,Fact, Stmt, Method> factAtStmt) {










 Collection<Method> calledMethods = context.icfg.getCalleesOfCallAt(factAtStmt.getStatement());










 for (Method calledMethod : calledMethods) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeCallFlow(factAtStmt, calledMethod);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 MethodAnalyzer<Field, Fact, Stmt, Method> analyzer = context.getAnalyzer(calledMethod);










 analyzer.addIncomingEdge(new IncomingEdge<Field, Fact, Stmt, Method>(this,










 factAtStmt, targetFact.getFact()));










 }










 }










 










 processCallToReturnEdge(factAtStmt);










 }





















 void processExit(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 log("New Summary: "+factAtStmt);










 if(!summaries.add(factAtStmt))










 throw new AssertionError();





















 










 for(IncomingEdge<Field, Fact, Stmt, Method> incEdge : incomingEdges) {










 applySummary(incEdge, factAtStmt);










 }





















 if(context.followReturnsPastSeeds && isZeroSource()) {










 Collection<Stmt> callSites = context.icfg.getCallersOf(method);










 for(Stmt callSite : callSites) {










 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(callSite);










 for(Stmt returnSite : returnSites) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeUnbalancedReturnFlow(










 sourceFact, factAtStmt, method, returnSite, callSite);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(new WrappedFactAtStatement<>(returnSite, targetFact.getFact()));










 }










 }










 }










 //in cases where there are no callers, the return statement would normally not be processed at all;










 //this might be undesirable if the flow function has a side effect such as registering a taint;










 //instead we thus call the return flow function will a null caller










 if(callSites.isEmpty()) {










 context.flowProcessor.computeUnbalancedReturnFlow(










 sourceFact, factAtStmt, method, null, null);










 }










 }










 }










 










 private void scheduleEdgeTo(Collection<Stmt> successors, WrappedFact<Field, Fact, Stmt, Method> fact) {










 for (Stmt stmt : successors) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, fact));










 }










 }










 










 private void processCallToReturnEdge(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 Stmt stmt = factAtStmt.getStatement();










 int numberOfPredecessors = context.icfg.getPredsOf(stmt).size(); 










 if(numberOfPredecessors > 1 || (context.icfg.isStartPoint(stmt) && numberOfPredecessors > 0)) {










 ctrFlowJoinResolvers.getOrCreate(factAtStmt.getAsFactAtStatement()).addIncoming(factAtStmt.getFact());










 }










 else {










 processNonJoiningCallToReturnFlow(factAtStmt);










 }










 }





















 private void processNonJoiningCallToReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(factAtStmt.getStatement());










 for(Stmt returnSite : returnSites) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeCallToReturnFlow(factAtStmt, returnSite);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, targetFact.getFact()));










 }










 }










 }





















 private void processNormalFlow(WrappedFactAtStatement<Field,Fact, Stmt, Method> factAtStmt) {










 Stmt stmt = factAtStmt.getStatement();










 int numberOfPredecessors = context.icfg.getPredsOf(stmt).size();










 if((numberOfPredecessors > 1 && !context.icfg.isExitStmt(stmt)) || (context.icfg.isStartPoint(stmt) && numberOfPredecessors > 0)) {










 ctrFlowJoinResolvers.getOrCreate(factAtStmt.getAsFactAtStatement()).addIncoming(factAtStmt.getFact());










 }










 else {










 processNormalNonJoiningFlow(factAtStmt);










 }










 }





















 void processFlowFromJoinStmt(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 if(context.icfg.isCallStmt(factAtStmt.getStatement()))










 processNonJoiningCallToReturnFlow(factAtStmt);










 else










 processNormalNonJoiningFlow(factAtStmt);










 }










 










 private void processNormalNonJoiningFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 final List<Stmt> successors = context.icfg.getSuccsOf(factAtStmt.getStatement());










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeNormalFlow(factAtStmt);










 for (final ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 if(targetFact.getConstraint() == null)










 scheduleEdgeTo(successors, targetFact.getFact());










 else {










 targetFact.getFact().getResolver().resolve(targetFact.getConstraint(), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer,










 Resolver<Field, Fact, Stmt, Method> resolver) {










 analyzer.scheduleEdgeTo(successors, new WrappedFact<>(targetFact.getFact().getFact(), targetFact.getFact().getAccessPath(), resolver));










 }





















 @Override










 public void canBeResolvedEmpty() {










 callEdgeResolver.resolve(targetFact.getConstraint(), this);










 }










 });










 }










 }










 }










 










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> getOrCreateNestedAnalyzer(AccessPath<Field> newAccPath) {










 if(newAccPath.equals(accessPath) || isZeroSource())










 return this;










 










 if(!nestedAnalyzers.containsKey(newAccPath)) {










 










 if(token)










 throw new AssertionError();










 










 assert accessPath.getDeltaTo(newAccPath).accesses.length <= 1;










 










 final PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> nestedAnalyzer = new PerAccessPathMethodAnalyzer<>(method, sourceFact, context, newAccPath, this);










 nestedAnalyzers.put(newAccPath, nestedAnalyzer);










 for(IncomingEdge<Field, Fact, Stmt, Method> incEdge : incomingEdges) {










 if(newAccPath.isPrefixOf(incEdge.getCalleeSourceFact().getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX)










 nestedAnalyzer.addIncomingEdge(incEdge);










 else if(incEdge.getCalleeSourceFact().getAccessPath().isPrefixOf(newAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX))










 incEdge.registerInterestCallback(nestedAnalyzer);










 }










 }










 return nestedAnalyzers.get(newAccPath);










 }










 










 boolean token;










 boolean recursiveLock;










 










 boolean isLocked() {










 if(recursiveLock)










 return true;










 if(parent == null)










 return false;










 return parent.isLocked();










 }










 










 public void addIncomingEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 if(accessPath.isPrefixOf(incEdge.getCalleeSourceFact().getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Edge: "+incEdge);










 if(!incomingEdges.add(incEdge))










 return;










 










 callEdgeResolver.interest(this, callEdgeResolver);










 










 applySummaries(incEdge);










 token=true;










 for(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> nestedAnalyzer : nestedAnalyzers.values())










 nestedAnalyzer.addIncomingEdge(incEdge);










 token=false;










 }










 else if(incEdge.getCalleeSourceFact().getAccessPath().isPrefixOf(accessPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 recursiveLock = true;










 incEdge.registerInterestCallback(this);










 recursiveLock = false;










 }










 }





















 private void applySummary(IncomingEdge<Field, Fact, Stmt, Method> incEdge, WrappedFactAtStatement<Field, Fact, Stmt, Method> exitFact) {










 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(incEdge.getCallSite());










 for(Stmt returnSite : returnSites) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeReturnFlow(context.factHandler, exitFact, method, returnSite, incEdge);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 scheduleReturnEdge(incEdge, targetFact.getFact(), returnSite);










 }










 }










 }





















 void scheduleUnbalancedReturnEdgeTo(WrappedFactAtStatement<Field, Fact, Stmt, Method> fact) {










 ReturnSiteResolver<Field,Fact,Stmt,Method> resolver = returnSiteResolvers.getOrCreate(fact.getAsFactAtStatement());










 resolver.addIncoming(new WrappedFact<>(fact.getFact().getFact(), fact.getFact().getAccessPath(), 










 fact.getFact().getResolver()), null, Delta.<Field>empty());










 }










 










 private void scheduleReturnEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge, WrappedFact<Field, Fact, Stmt, Method> fact, Stmt returnSite) {










 Delta<Field> delta = accessPath.getDeltaTo(incEdge.getCalleeSourceFact().getAccessPath());










 ReturnSiteResolver<Field, Fact, Stmt, Method> returnSiteResolver = incEdge.getCallerAnalyzer().returnSiteResolvers.getOrCreate(










 new FactAtStatement<Fact, Stmt>(fact.getFact(), returnSite));










 returnSiteResolver.addIncoming(fact, incEdge.getCalleeSourceFact().getResolver(), delta);










 }





















 private void applySummaries(IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 for(WrappedFactAtStatement<Field, Fact, Stmt, Method> summary : summaries) {










 applySummary(incEdge, summary);










 }










 }










 










 public boolean isZeroSource() {










 return sourceFact.equals(context.zeroValue);










 }





















 private class Job implements Runnable {





















 private WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt;





















 public Job(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 this.factAtStmt = factAtStmt;










 }





















 @Override










 public void run() {










 if (context.icfg.isCallStmt(factAtStmt.getStatement())) {










 processCall(factAtStmt);










 } else {










 if (context.icfg.isExitStmt(factAtStmt.getStatement())) {










 processExit(factAtStmt);










 }










 if (!context.icfg.getSuccsOf(factAtStmt.getStatement()).isEmpty()) {










 processNormalFlow(factAtStmt);










 }










 }










 }










 }





















 public CallEdgeResolver<Field, Fact, Stmt, Method> getCallEdgeResolver() {










 return callEdgeResolver;










 }










 










 public void debugInterest() {










 JsonDocument root = new JsonDocument();










 










 List<PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> worklist = Lists.newLinkedList();










 worklist.add(this);










 Set<PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> visited = Sets.newHashSet();










 










 while(!worklist.isEmpty()) {










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> current = worklist.remove(0);










 if(!visited.add(current))










 continue;










 










 JsonDocument currentMethodDoc = root.doc(current.method.toString()+ "___"+current.sourceFact);










 JsonDocument currentDoc = currentMethodDoc.doc("accPath").doc("_"+current.accessPath.toString());










 










 for(IncomingEdge<Field, Fact, Stmt, Method> incEdge : current.incomingEdges) {










 currentDoc.doc("incoming").doc(incEdge.getCallerAnalyzer().method+"___"+incEdge.getCallerAnalyzer().sourceFact).doc("_"+incEdge.getCallerAnalyzer().accessPath.toString());










 worklist.add(incEdge.getCallerAnalyzer());










 }










 }










 










 try {










 FileWriter writer = new FileWriter("debug/incoming.json");










 StringBuilder builder = new StringBuilder();










 builder.append("var root=");










 root.write(builder, 0);










 writer.write(builder.toString());










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }










 










 public void debugNestings() {










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> current = this;










 while(current.parent != null)










 current = current.parent;










 










 JsonDocument root = new JsonDocument();










 debugNestings(current, root);










 










 try {










 FileWriter writer = new FileWriter("debug/nestings.json");










 StringBuilder builder = new StringBuilder();










 builder.append("var root=");










 root.write(builder, 0);










 writer.write(builder.toString());










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }





















 private void debugNestings(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> current, JsonDocument parentDoc) {










 JsonDocument currentDoc = parentDoc.doc(current.accessPath.toString());










 for(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> nestedAnalyzer : current.nestedAnalyzers.values()) {










 debugNestings(nestedAnalyzer, currentDoc);










 }










 }










}














src/heros/alias/Resolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.List;










import java.util.Map;





















import com.google.common.collect.HashMultimap;










import com.google.common.collect.Lists;





















import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.Constraint;





















public abstract class Resolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private boolean interest = false;










 private List<InterestCallback<Field, Fact, Stmt, Method>> interestCallbacks = Lists.newLinkedList();










 protected PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer;










 private boolean canBeResolvedEmpty = false;










 










 public Resolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 this.analyzer = analyzer;










 }





















 public abstract void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback);










 










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 if(interest)










 return;










 










 log("Interest given");










 interest = true;










 for(InterestCallback<Field, Fact, Stmt, Method> callback : Lists.newLinkedList(interestCallbacks)) {










 callback.interest(analyzer, resolver);










 }










 










 if(canBeResolvedEmpty)










 interestCallbacks = null;










 }










 










 protected void canBeResolvedEmpty() {










 if(canBeResolvedEmpty)










 return;










 










 canBeResolvedEmpty = true;










 for(InterestCallback<Field, Fact, Stmt, Method> callback : Lists.newLinkedList(interestCallbacks)) {










 callback.canBeResolvedEmpty();










 }










 










 if(interest)










 interestCallbacks = null;










 }





















 public boolean isInterestGiven() {










 return interest;










 }





















 protected void registerCallback(InterestCallback<Field, Fact, Stmt, Method> callback) {










 if(interest) {










 callback.interest(analyzer, this);










 }










 else {










 log("Callback registered");










 interestCallbacks.add(callback);










 }





















 if(canBeResolvedEmpty)










 callback.canBeResolvedEmpty();










 }










 










 protected abstract void log(String message);










 










}














src/heros/alias/ReturnSiteResolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















import java.util.Map;










import java.util.Set;





















import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private Stmt returnSite;










 private AccessPath<Field> resolvedAccPath;










 private boolean propagated = false;










 private Set<ReturnEdge> incomingFacts;










 private Map<AccessPath<Field>, ReturnSiteResolver<Field, Fact, Stmt, Method>> nestedResolvers = Maps.newHashMap();










 private ReturnSiteResolver<Field, Fact, Stmt, Method> parent;





















 public ReturnSiteResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt returnSite) {










 this(analyzer, returnSite, new AccessPath<Field>(), null);










 }





















 private ReturnSiteResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt returnSite, AccessPath<Field> resolvedAccPath, ReturnSiteResolver<Field, Fact, Stmt, Method> parent) {










 super(analyzer);










 this.returnSite = returnSite;










 this.resolvedAccPath = resolvedAccPath;










 this.parent = parent;










 this.incomingFacts = Sets.newHashSet();










 }










 










 @Override










 public String toString() {










 return "<"+resolvedAccPath+":"+returnSite+">";










 }










 










 public AccessPath<Field> getResolvedAccessPath() {










 return resolvedAccPath;










 }










 










 public void addIncoming(final WrappedFact<Field, Fact, Stmt, Method> fact, 










 Resolver<Field, Fact, Stmt, Method> resolverAtCaller, 










 Delta<Field> callDelta) {










 










 addIncoming(new ReturnEdge(fact, resolverAtCaller, callDelta));










 }










 










 private void addIncoming(final ReturnEdge retEdge) {










 if(resolvedAccPath.isPrefixOf(retEdge.incAccessPath) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Edge "+retEdge);










 if(!incomingFacts.add(retEdge))










 return;





















 interest(analyzer, this);










 










 for(ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver : nestedResolvers.values())










 nestedResolver.addIncoming(nestedResolver.new ReturnEdge(retEdge.incFact, retEdge.incAccessPath, retEdge.incResolver, 










 retEdge.resolverAtCaller, retEdge.callDelta, retEdge.usedAccessPathOfIncResolver));





















 if(!propagated) {










 propagated=true;










 analyzer.scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, 










 new WrappedFact<>(retEdge.incFact, new AccessPath<Field>(), this)));










 }










 }










 else if(retEdge.incAccessPath.isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 log("Incoming potential prefix:  "+retEdge);










 retEdge.resolveViaDelta();










 }










 }










 










 protected void log(String message) {










 analyzer.log("Return Site "+toString()+": "+message);










 }





















 @Override










 public void resolve(Constraint<Field> constraint, final InterestCallback<Field, Fact, Stmt, Method> callback) {










 log("Resolve: "+constraint);










 if(!constraint.canBeAppliedTo(resolvedAccPath))










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);










 }










 










 private ReturnSiteResolver<Field, Fact, Stmt, Method> getOrCreateNestedResolver(AccessPath<Field> candidateAccPath) {










 if(resolvedAccPath.equals(candidateAccPath))










 return this;










 










 if(!nestedResolvers.containsKey(candidateAccPath)) {










 assert resolvedAccPath.getDeltaTo(candidateAccPath).accesses.length <= 1;










 final ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver = new ReturnSiteResolver<>(analyzer, returnSite, candidateAccPath, this);










 nestedResolver.propagated = true;










 nestedResolvers.put(candidateAccPath, nestedResolver);





















 for(ReturnSiteResolver<Field, Fact, Stmt, Method>.ReturnEdge retEdge: incomingFacts) {










 nestedResolver.addIncoming(nestedResolver.new ReturnEdge(retEdge.incFact, retEdge.incAccessPath, retEdge.incResolver, 










 retEdge.resolverAtCaller, retEdge.callDelta, retEdge.usedAccessPathOfIncResolver));










 } 










 }










 return nestedResolvers.get(candidateAccPath);










 }










 










 private class ReturnEdge {





















 final Fact incFact;










 final Resolver<Field, Fact, Stmt, Method> resolverAtCaller;










 final Delta<Field> callDelta;










 final AccessPath<Field> incAccessPath;










 final Resolver<Field, Fact, Stmt, Method> incResolver;










 final Delta<Field> usedAccessPathOfIncResolver;





















 public ReturnEdge(WrappedFact<Field, Fact, Stmt, Method> fact, Resolver<Field, Fact, Stmt, Method> resolverAtCaller,










 Delta<Field> callDelta) {










 this(fact.getFact(), fact.getAccessPath(), fact.getResolver(), resolverAtCaller, callDelta, Delta.<Field>empty());










 }










 










 private ReturnEdge(Fact incFact, AccessPath<Field> incAccessPath, Resolver<Field, Fact, Stmt, Method> incResolver, 










 Resolver<Field, Fact, Stmt, Method> resolverAtCaller, Delta<Field> callDelta, Delta<Field> usedAccessPathOfIncResolver) {










 this.incFact = incFact;










 this.incAccessPath = incAccessPath;










 this.incResolver = incResolver;










 this.resolverAtCaller = resolverAtCaller;










 this.callDelta = callDelta;










 this.usedAccessPathOfIncResolver = usedAccessPathOfIncResolver;










 }










 










 @Override










 public String toString() {










 return String.format("IncFact: %s%s, Delta: %s, IncResolver: <%s:%s>, ResolverAtCallSite: %s", incFact, incAccessPath, callDelta, usedAccessPathOfIncResolver, incResolver, resolverAtCaller);










 }










 










 public void resolveViaDelta() {










 if(incResolver == null || incResolver instanceof CallEdgeResolver) {










 resolveViaDeltaAndPotentiallyDelegateToCallSite();










 } else {










 //resolve via incoming facts resolver










 Delta<Field> delta = usedAccessPathOfIncResolver.applyTo(incAccessPath, true).getDeltaTo(resolvedAccPath);










 assert delta.accesses.length <= 1;










 incResolver.resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {





















 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, resolver, resolverAtCaller, callDelta, incAccessPath.getDeltaTo(resolvedAccPath)));










 ReturnSiteResolver.this.interest(analyzer, resolver);










 }










 










 @Override










 public void canBeResolvedEmpty() {










 resolveViaDeltaAndPotentiallyDelegateToCallSite();










 }










 });










 } 










 }





















 private void resolveViaDeltaAndPotentiallyDelegateToCallSite() {










 final AccessPath<Field> currAccPath = callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath, true), true);










 if(resolvedAccPath.isPrefixOf(currAccPath) == PrefixTestResult.GUARANTEED_PREFIX) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver));










 ReturnSiteResolver.this.interest(analyzer, ReturnSiteResolver.this);










 } else if(currAccPath.isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 resolveViaCallSiteResolver(currAccPath);










 }










 }





















 protected void resolveViaCallSiteResolver(AccessPath<Field> currAccPath) {










 if(resolverAtCaller == null || resolverAtCaller instanceof CallEdgeResolver) {










 ReturnSiteResolver.this.canBeResolvedEmpty();










 } else {










 resolverAtCaller.resolve(new DeltaConstraint<>(currAccPath.getDeltaTo(resolvedAccPath)), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, null, resolver, Delta.<Field>empty(), incAccessPath.getDeltaTo(resolvedAccPath)));










 ReturnSiteResolver.this.interest(analyzer, ReturnSiteResolver.this);










 }










 










 @Override










 public void canBeResolvedEmpty() {










 ReturnSiteResolver.this.canBeResolvedEmpty();










 }










 });










 }










 }










 }





















 public Stmt getReturnSite() {










 return returnSite;










 }










}














src/heros/alias/Scheduler.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.LinkedList;










import com.google.common.collect.Lists;





















public class Scheduler {





















 private LinkedList<Runnable> worklist = Lists.newLinkedList();










 










 public void schedule(Runnable job) {










 worklist.add(job);










 }





















 public void runAndAwaitCompletion() {










 while(!worklist.isEmpty()) {










 worklist.removeLast().run();










 }










 }





















}














src/heros/alias/TestDebugger.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.io.FileWriter;










import java.io.IOException;










import java.util.Set;





















import com.google.common.collect.Sets;





















import heros.InterproceduralCFG;










import heros.alias.TestHelper.Edge;





















public class TestDebugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 private JsonDocument root = new JsonDocument();










 private I icfg;










 










 public void writeJsonDebugFile(String filename) {










 try {










 FileWriter writer = new FileWriter(filename);










 StringBuilder builder = new StringBuilder();










 builder.append("var root=");










 root.write(builder, 0);










 writer.write(builder.toString());










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }










 










 /* (non-Javadoc)










	 * @see heros.alias.Debugger#setICFG(I)










	 */










 @Override










 public void setICFG(I icfg) {










 this.icfg = icfg;










 }





















 /* (non-Javadoc)










	 * @see heros.alias.Debugger#initialSeed(Stmt)










	 */










 @Override










 public void initialSeed(Stmt stmt) {










 stmt(stmt).keyValue("seed", "true");










 










 includeSuccessors(stmt, Sets.<Stmt> newHashSet());










 }










 










 private void includeSuccessors(Stmt stmt, Set<Stmt> visited) {










 if(!visited.add(stmt))










 return;










 










 JsonDocument doc = stmt(stmt);










 for(Stmt succ : icfg.getSuccsOf(stmt)) {










 doc.array("successors").add(succ.toString());










 stmt(succ);










 includeSuccessors(succ, visited);










 }










 










 if(icfg.isCallStmt(stmt)) {










 for(Method m : icfg.getCalleesOfCallAt(stmt)) {










 doc.doc("calls").doc(m.toString());










 for(Stmt sp : icfg.getStartPointsOf(m)) {










 stmt(sp).keyValue("startPoint", "true");










 includeSuccessors(sp, visited);










 }










 }










 for(Stmt retSite :icfg.getReturnSitesOfCallAt(stmt)) {










 doc.array("successors").add(retSite.toString());










 stmt(retSite);










 includeSuccessors(retSite, visited);










 }










 }










 if(icfg.isExitStmt(stmt)) {










 for(Stmt callSite : icfg.getCallersOf(icfg.getMethodOf(stmt))) {










 for(Stmt retSite : icfg.getReturnSitesOfCallAt(callSite)) {










 doc.doc("returns").doc(retSite.toString());










 includeSuccessors(retSite, visited);










 }










 }










 }










 }





















 protected JsonDocument stmt(Stmt stmt) {










 Method methodOf = icfg.getMethodOf(stmt);










 return root.doc("methods").doc(methodOf.toString()).doc(stmt.toString());










 }










 










 public void expectNormalFlow(Stmt unit, String expectedFlowFunctionsToString) {










 stmt(unit).keyValue("flow", expectedFlowFunctionsToString);










 }





















 public void expectCallFlow(Stmt callSite, Method destinationMethod, String expectedFlowFunctionsToString) {










 stmt(callSite).doc("calls").doc(destinationMethod.toString()).keyValue("flow", expectedFlowFunctionsToString);










 }





















 public void expectReturnFlow(Stmt exitStmt, Stmt returnSite, String expectedFlowFunctionsToString) {










 if(returnSite != null)










 stmt(exitStmt).doc("returns").doc(returnSite.toString()).keyValue("flow", expectedFlowFunctionsToString);










 }





















 static void tabs(int tabs, StringBuilder builder) {










 for(int i=0; i<tabs; i++)










 builder.append("\t");










 }





















}














src/heros/alias/Transition.java








View file @ 3398e46f






......@@ -72,14 +72,16 @@ public interface Transition<FieldRef> {









 } else {










 Set<FieldRef> otherExcludedFields = ((ExclusionPathTransition<FieldRef>) t).excludedFields;










 boolean intersection = false;










 boolean containsAll = true;










 boolean containsAll = excludedFields.containsAll(otherExcludedFields);










 boolean oppositeContainsAll = otherExcludedFields.containsAll(excludedFields);










 for(FieldRef field : excludedFields) {










 if(otherExcludedFields.contains(field))










 if(otherExcludedFields.contains(field)) {










 intersection = true;










 else










  containsAll = false;










  break;










 }










 }










 return new MatchResult<>(containsAll || !intersection, containsAll);










 boolean potentialMatch = oppositeContainsAll || !intersection || (!containsAll && !oppositeContainsAll);










 return new MatchResult<>(potentialMatch, oppositeContainsAll);










 }










 










 return new MatchResult<>(false, false);



......














test/heros/alias/Fact.java

→

src/heros/alias/WrappedFact.java








View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at



......@@ -10,87 +10,58 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;





















import java.util.ArrayList;










import java.util.Arrays;










import java.util.regex.Matcher;










import java.util.regex.Pattern;










public class WrappedFact<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method>{





















import com.google.common.base.Joiner;










import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, TestFieldRef, Fact> {





















 public final String baseValue;










 public final AccessPath<TestFieldRef> accessPath;










 private final Fact fact;










 private final AccessPath<Field> accessPath;










 private final Resolver<Field, Fact, Stmt, Method> resolver;










 










 public Fact(String name) {










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 AccessPath<TestFieldRef> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();










 baseValue = name.substring(0, firstSeparator);










 matcher.reset();










 WrappedFact(Fact fact, AccessPath<Field> accessPath, Resolver<Field, Fact, Stmt, Method> resolver) {










 assert fact != null;










 assert accessPath != null;










 assert resolver != null;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(separator.equals(".")) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(new TestFieldRef(identifier));










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 TestFieldRef[] fExcl = new TestFieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new TestFieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 }










 }










 this.fact = fact;










 this.accessPath = accessPath;










 this.resolver = resolver;










 }










 










 public Fact(String baseValue, AccessPath<TestFieldRef> accessPath) {










 this.baseValue = baseValue;










 this.accessPath = accessPath;










 public Fact getFact() {










 return fact;










 }










 










 @Override










 public String toString() {










 return "[Fact "+baseValue+(accessPath.isEmpty() ? "" : accessPath)+"]";










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta, boolean merge) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath, merge), resolver); //TODO keep resolver?










 }





















 @Override










 public String getBaseValue() {










 return baseValue;










 }





















 @Override










 public AccessPath<TestFieldRef> getAccessPath() {










 public AccessPath<Field> getAccessPath() {










 return accessPath;










 }





















 @Override










 public void addNeighbor(Fact originalAbstraction) {










 










 










 public WrappedFact<Field, Fact, Stmt, Method> applyConstraint(Constraint<Field> constraint, Fact zeroValue, boolean sourceFact) {










 if(fact.equals(zeroValue))










 return this;










 else










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath, sourceFact), resolver);










 }





















 










 @Override










 public void setCallingContext(Fact callingContext) {










 










 public String toString() {










 String result = fact.toString()+accessPath;










 if(resolver != null)










 result+=resolver.toString();










 return result;










 }





















 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((accessPath == null) ? 0 : accessPath.hashCode());










 result = prime * result + ((baseValue == null) ? 0 : baseValue.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -100,25 +71,29 @@ public class Fact implements FieldSensitiveFact<String, TestFieldRef, Fact> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof Fact))










 if (getClass() != obj.getClass())










 return false;










 Fact other = (Fact) obj;










 WrappedFact other = (WrappedFact) obj;










 if (accessPath == null) {










 if (other.accessPath != null)










 return false;










 } else if (!accessPath.equals(other.accessPath))










 return false;










 if (baseValue == null) {










 if (other.baseValue != null)










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!baseValue.equals(other.baseValue))










 } else if (!fact.equals(other.fact))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }





















 @Override










 public Fact cloneWithAccessPath(AccessPath<TestFieldRef> accessPath) {










 return new Fact(baseValue, accessPath);










 public Resolver<Field, Fact, Stmt, Method> getResolver() {










 return resolver;










 }










 










 



......














src/heros/alias/SummaryEdge.java

→

src/heros/alias/WrappedFactAtStatement.java








View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at



......@@ -10,70 +10,66 @@









 ******************************************************************************/










package heros.alias;





















public class SummaryEdge<D, N> {










public class WrappedFactAtStatement<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private D sourceFact;










 private N targetStmt;










 private D targetFact;










 private WrappedFact<Field,Fact, Stmt, Method> fact;










 private Stmt stmt;





















 public WrappedFactAtStatement(Stmt stmt, WrappedFact<Field, Fact, Stmt, Method> fact) {










 this.stmt = stmt;










 this.fact = fact;










 }





















 public WrappedFact<Field,Fact, Stmt, Method> getFact() {










 return fact;










 }





















 public Stmt getStatement() {










 return stmt;










 }










 










 public FactAtStatement<Fact, Stmt> getAsFactAtStatement() {










 return new FactAtStatement<Fact, Stmt>(fact.getFact(), stmt);










 }










 










 public SummaryEdge(D sourceFact, N targetStmt, D targetFact) {










 this.sourceFact = sourceFact;










 this.targetStmt = targetStmt;










 this.targetFact = targetFact;










 public boolean canDeltaBeApplied(AccessPath.Delta<Field> delta) {










 return delta.canBeAppliedTo(fact.getAccessPath());










 }










 










 @Override










 public String toString() {










 return "[SummaryEdge: "+sourceFact+" -> "+targetFact+" @stmt: "+targetStmt+"]";










 return fact+" @ "+stmt;










 }





















 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((sourceFact == null) ? 0 : sourceFact.hashCode());










 result = prime * result + ((targetFact == null) ? 0 : targetFact.hashCode());










 result = prime * result + ((targetStmt == null) ? 0 : targetStmt.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((stmt == null) ? 0 : stmt.hashCode());










 return result;










 }










 





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SummaryEdge))










 if (getClass() != obj.getClass())










 return false;










 SummaryEdge other = (SummaryEdge) obj;










 if (sourceFact == null) {










 if (other.sourceFact != null)










 WrappedFactAtStatement other = (WrappedFactAtStatement) obj;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!sourceFact.equals(other.sourceFact))










 } else if (!fact.equals(other.fact))










 return false;










 if (targetFact == null) {










 if (other.targetFact != null)










 if (stmt == null) {










 if (other.stmt != null)










 return false;










 } else if (!targetFact.equals(other.targetFact))










 return false;










 if (targetStmt == null) {










 if (other.targetStmt != null)










 return false;










 } else if (!targetStmt.equals(other.targetStmt))










 } else if (!stmt.equals(other.stmt))










 return false;










 return true;










 }





















 public D getSourceFact() {










 return sourceFact;










 }










 










 public D getTargetFact() {










 return targetFact;










 }










 










 public N getTargetStmt() {










 return targetStmt;










 }










 










}














src/heros/alias/ZeroCallEdgeResolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class ZeroCallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends CallEdgeResolver<Field, Fact, Stmt, Method> {





















 private ZeroHandler<Field> zeroHandler;





















 public ZeroCallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, ZeroHandler<Field> zeroHandler) {










 super(analyzer);










 this.zeroHandler = zeroHandler;










 }





















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) {










 if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(new AccessPath<Field>(), true)))










 callback.interest(analyzer, this);










 }










 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 }










}














src/heros/alias/FieldSensitiveFact.java

→

src/heros/alias/ZeroHandler.java








View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch, Johannes Späth.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch, Johannes Späth - initial API and implementation










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.solver.LinkedNode;










public interface ZeroHandler<Field extends AccessPath.FieldRef<Field>> {





















public interface FieldSensitiveFact<BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D> extends LinkedNode<D>{





















 BaseValue getBaseValue();










 










 AccessPath<FieldRef> getAccessPath();










 










 D cloneWithAccessPath(AccessPath<FieldRef> accessPath);










 










 boolean shouldGenerateAccessPath(AccessPath<Field> accPath);










}














test/heros/alias/AccessPathTest.java








View file @ 3398e46f






......@@ -19,6 +19,7 @@ import org.junit.Test;




















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.SubAccessPath.*;














......@@ -36,7 +37,7 @@ public class AccessPathTest {









 }










 return result;










 }










 





















 private static SetOfPossibleFieldAccesses<TestFieldRef> anyOf(String...fields) {










 Set<TestFieldRef> set = Sets.newHashSet();










 for(String f : fields)



......@@ -49,7 +50,7 @@ public class AccessPathTest {









 }










 










 private static AccessPath<TestFieldRef> ap(SubAccessPath<TestFieldRef>... path) {










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet(), null);










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet());










 }










 










 @Test



......@@ -64,6 +65,12 @@ public class AccessPathTest {









 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMultipleFieldsAndMerge() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(f("b", "a")));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<TestFieldRef> sut = ap(s("a"));



......@@ -190,6 +197,20 @@ public class AccessPathTest {









 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaFromSetToSet() {










 Delta<TestFieldRef> actual = ap(anyOf("a")).appendExcludedFieldReference(f("f")).getDeltaTo(ap(anyOf("a")).appendExcludedFieldReference(f("g")));










 assertArrayEquals(new SubAccessPath[] { anyOf("a") }, actual.accesses);










 assertEquals(Sets.newHashSet(f("g")), actual.exclusions);










 }










 










 @Test










 public void emptyDeltaOnEqualExclusions() {










 AccessPath<TestFieldRef> actual = ap().appendExcludedFieldReference(f("f"));










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).exclusions.equals(Sets.newHashSet(f("f"))));










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;



......@@ -227,6 +248,12 @@ public class AccessPathTest {









 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void multipleExclPrefixOfMultipleExcl() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference(f("f", "h"))));










 }










 










 @Test










 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));



......














test/heros/alias/AccessPathUtilTest.java








View file @ 3398e46f






......@@ -11,125 +11,109 @@









package heros.alias;





















import static heros.alias.AccessPath.PrefixTestResult.*;










import static heros.alias.AccessPathUtil.applyAbstractedSummary;










import static heros.alias.AccessPathUtil.isPrefixOf;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertTrue;





















import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import heros.alias.AccessPath.PrefixTestResult;





















import org.junit.Test;





















public class AccessPathUtilTest {





















 public static AccessPath<TestFieldRef> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<TestFieldRef> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(new TestFieldRef(identifier));










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 TestFieldRef[] fExcl = new TestFieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new TestFieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 }










 }










 return accessPath;










 }










 










 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a"), new Fact("a.f")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a")));










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("f")));










 assertEquals(NO_PREFIX, ap("f").isPrefixOf(ap("")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a"), new Fact("a")));










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.b"), new Fact("a.b.c")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.b.c"), new Fact("a.b")));










 assertEquals(GUARANTEED_PREFIX, ap("b").isPrefixOf(ap("b.c")));










 assertEquals(NO_PREFIX, ap("b.c").isPrefixOf(ap("b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.g")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.g"), new Fact("a^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g")));










 assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a^f")));










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f,g"), new Fact("a^f,g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertEquals(POTENTIAL_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.g.g")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.f.h")));










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f,g"), new Fact("a^g")));










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f")));










 assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.g.h")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h")));










 }










 










 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a"), new Fact("a^f")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a")));










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));










 










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a.f^g^h")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 }










 










 @Test










 public void testAbstractedSummary() {










 assertEquals(new Fact("z.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h")));










 assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f")));










 }










 










 @Test










 public void testAbstractedFieldAccessSummary() {










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryIntroducesFieldAccess() {










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.c"), new SummaryEdge<>(new Fact("a"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryRemovesFieldAccess() {










 assertEquals(new Fact("z.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testNonAbstractedSummary() {










 assertEquals(new Fact("z"), applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testSummaryWithExcludedField() {










 assertEquals(new Fact("a.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testIdentityForExclusions() {










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a"))).get());










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).get());










 }










 










 @Test










 public void testMergeExclusions() {










 assertEquals(new Fact("a^f,g"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testNullOnImpossibleSubsumption() {










 assertFalse(applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).isPresent());










 }










}














test/heros/alias/ControlFlowJoinResolverTest.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;





















import org.junit.Before;










import org.junit.Test;










import org.mockito.ArgumentMatcher;










import org.mockito.Mockito;










import org.mockito.invocation.InvocationOnMock;










import org.mockito.stubbing.Answer;










import org.mockito.verification.VerificationMode;





















public class ControlFlowJoinResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement joinStmt;










 private ControlFlowJoinResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 joinStmt = new TestStatement("joinStmt");










 sut = new ControlFlowJoinResolver<>(analyzer, joinStmt);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);










 }





















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver));










 verify(analyzer).processFlowFromJoinStmt(eq(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver));










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));










 }










 










 










 private class ResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;





















 public ResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 this.accPath = accPath;










 }





















 @Override










 public boolean matches(Object argument) {










 ControlFlowJoinResolver resolver = (ControlFlowJoinResolver) argument;










 return resolver.isInterestGiven() && resolver.getResolvedAccessPath().equals(accPath) && resolver.getJoinStmt().equals(joinStmt);










 }










 }










}














test/heros/alias/EdgeBuilder.java








View file @ 3398e46f






......@@ -32,43 +32,44 @@ public abstract class EdgeBuilder {




















 public static class CallSiteBuilder extends EdgeBuilder {





















 private Statement callSite;










 private TestStatement callSite;





















 public CallSiteBuilder(Statement callSite) {










 public CallSiteBuilder(TestStatement callSite) {










 this.callSite = callSite;










 }





















 public CallSiteBuilder calls(String method, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.CallEdge(callSite, new Method(method), flows));










 edges.add(new TestHelper.CallEdge(callSite, new TestMethod(method), flows));










 return this;










 }










 










 public CallSiteBuilder retSite(String returnSite, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new Statement(returnSite), flows));










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new TestStatement(returnSite), flows));










 return this;










 }










 }










 










 public static class NormalStmtBuilder extends EdgeBuilder {





















 private Statement stmt;










 private TestStatement stmt;










 private ExpectedFlowFunction[] flowFunctions;





















 public NormalStmtBuilder(Statement stmt) {










 public NormalStmtBuilder(TestStatement stmt, ExpectedFlowFunction[] flowFunctions) {










 this.stmt = stmt;










 this.flowFunctions = flowFunctions;










 }





















 public NormalStmtBuilder succ(String succ, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.NormalEdge(stmt, new Statement(succ), flows));










 public NormalStmtBuilder succ(String succ) {










 edges.add(new TestHelper.NormalEdge(stmt, new TestStatement(succ), flowFunctions));










 return this;










 }










 










 }










 










 public static class ExitStmtBuilder extends EdgeBuilder {





















 private Statement exitStmt;










 private TestStatement exitStmt;





















 public ExitStmtBuilder(Statement exitStmt) {










 public ExitStmtBuilder(TestStatement exitStmt) {










 this.exitStmt = exitStmt;










 }










 



......@@ -77,7 +78,7 @@ public abstract class EdgeBuilder {









 return this;










 }





















 public ExitStmtBuilder returns(Statement callSite, Statement returnSite, ExpectedFlowFunction... flows) {










 public ExitStmtBuilder returns(TestStatement callSite, TestStatement returnSite, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.ReturnEdge(callSite, exitStmt, returnSite, flows));










 return this;










 }



......














test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ 3398e46f





This diff is collapsed.
Click to expand it.













test/heros/alias/ReturnSiteResolverTest.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;





















import org.junit.Before;










import org.junit.Test;










import org.mockito.ArgumentMatcher;










import org.mockito.Mockito;










import org.mockito.invocation.InvocationOnMock;










import org.mockito.stubbing.Answer;










import org.mockito.verification.VerificationMode;





















public class ReturnSiteResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement returnSite;










 private ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 returnSite = new TestStatement("returnSite");










 sut = new ReturnSiteResolver<>(analyzer, returnSite);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);










 }





















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 verify(analyzer).scheduleEdgeTo(eq(new WrappedFactAtStatement<>(returnSite, new WrappedFact<>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver), callEdgeResolver, getDelta());










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }










 










 @Test










 public void resolveViaDelta() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }










 










 @Test










 public void resolveViaDeltaTwice() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a", "b"));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(innerCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));










 }










 










 @Test










 public void resolveViaDeltaAndThenViaCallSite() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(innerCallback).canBeResolvedEmpty();










 }





















 @Test










 public void resolveViaCallEdgeResolverAtCallSite() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).canBeResolvedEmpty();










 }










 










 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 @Test










 public void resolveViaResolverAtCallSiteTwice() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback innerCallback = (InterestCallback) invocation.getArguments()[1];










 innerCallback.interest(analyzer, nestedResolver);










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback innerCallback = (InterestCallback) invocation.getArguments()[1];










 innerCallback.interest(analyzer, nestedResolver);










 return null;










 }










 }).when(nestedResolver).resolve(eq(getDeltaConstraint("b")), any(InterestCallback.class));










 










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), secondCallback);










 return null;










 }










 










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(secondCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));










 }










 










 @Test










 public void resolveAsEmptyViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Delta<TestFieldRef> delta = new AccessPath<TestFieldRef>().getDeltaTo(new AccessPath<TestFieldRef>().appendExcludedFieldReference(new TestFieldRef("a")));










 










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback innerCallback = (InterestCallback) invocation.getArguments()[1];










 innerCallback.canBeResolvedEmpty();










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));





















 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, delta);










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback, never()).canBeResolvedEmpty();










 verify(callback, never()).interest(any(PerAccessPathMethodAnalyzer.class), any(Resolver.class));










 }










 










 @Test










 public void resolveViaCallSiteResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 private class ReturnSiteResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;





















 public ReturnSiteResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 this.accPath = accPath;










 }





















 @Override










 public boolean matches(Object argument) {










 ReturnSiteResolver resolver = (ReturnSiteResolver) argument;










 return resolver.isInterestGiven() && resolver.getResolvedAccessPath().equals(accPath) && resolver.getReturnSite().equals(returnSite);










 }










 }










}









Prev


1


2


3


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment










Commit
3398e46f


authored
Feb 25, 2015
by


Johannes Lerch



Browse files




rewrite of ifds solver







parent
55cdd2d8













Changes
45




Expand all
Hide whitespace changes

Inline
Side-by-side















src/heros/alias/InterestCallback.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public interface InterestCallback<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver);










 










//	void partiallyResolved(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver, AccessPath<Field> resolvedAccPath);










 










 void canBeResolvedEmpty();










}














src/heros/alias/JsonArray.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.List;





















import com.google.common.collect.Lists;





















class JsonArray {










 










 private List<String> items = Lists.newLinkedList();










 










 public void add(String item) {










 items.add(item);










 }





















 public void write(StringBuilder builder, int tabs) {










 builder.append("[\n");










 for(String item: items) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+item+"\",\n");










 }










 TestDebugger.tabs(tabs, builder); builder.append("]");










 }










}




\ No newline at end of file














src/heros/alias/JsonDocument.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Map;










import java.util.Map.Entry;





















import com.google.common.collect.Maps;





















class JsonDocument {










 










 private CacheMap<String, JsonDocument> documents = new CacheMap<String, JsonDocument>() {










 @Override










 protected JsonDocument createItem(String key) {










 return new JsonDocument();










 }










 };










 private CacheMap<String, JsonArray> arrays = new CacheMap<String, JsonArray>() {










 @Override










 protected JsonArray createItem(String key) {










 return new JsonArray();










 }










 };










 private Map<String, String> keyValuePairs = Maps.newHashMap();










 










 public JsonDocument doc(String key) {










 return documents.getOrCreate(key);










 }










 










 public JsonArray array(String key) {










 return arrays.getOrCreate(key);










 }










 










 public void keyValue(String key, String value) {










 keyValuePairs.put(key, value);










 }










 










 public void write(StringBuilder builder, int tabs) {










 builder.append("{\n");










 










 for(Entry<String, String> entry : keyValuePairs.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n");










 }










 










 for(Entry<String, JsonArray> entry : arrays.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");





















 }










 










 for(Entry<String, JsonDocument> entry : documents.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");










 }










 










 TestDebugger.tabs(tabs, builder); builder.append("}");










 }





















}




\ No newline at end of file














src/heros/alias/MethodAnalyzer.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;
































public class MethodAnalyzer<Field extends AccessPath.FieldRef<Field>,










 Fact, 










 Stmt, 










 Method> {





















 private Method method;










 private CacheMap<Fact, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> perSourceAnalyzer = 










 new CacheMap<Fact, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>>() {










 @Override










 protected PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> createItem(Fact key) {










 return new PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>(method, key, context);










 }










 };










 private Context<Field, Fact, Stmt, Method> context;










 










 MethodAnalyzer(Method method, Context<Field, Fact, Stmt, Method> context) {










 this.method = method;










 this.context = context;










 }










 










 public void addIncomingEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact = incEdge.getCalleeSourceFact();










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer = perSourceAnalyzer.getOrCreate(calleeSourceFact.getFact());










 analyzer.bootstrapAtMethodStartPoints();










 analyzer.addIncomingEdge(incEdge);










 }





















 public void addInitialSeed(Stmt startPoint, Fact val) {










 perSourceAnalyzer.getOrCreate(val).addInitialSeed(startPoint);










 }










 










 public void addUnbalancedReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> target) {










 perSourceAnalyzer.getOrCreate(context.zeroValue).scheduleUnbalancedReturnEdgeTo(target);










 }










}














src/heros/alias/PerAccessPathMethodAnalyzer.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.ConstrainedFact;





















import java.io.FileWriter;










import java.io.IOException;










import java.util.Collection;










import java.util.List;










import java.util.Map;










import java.util.Set;





















import org.slf4j.Logger;










import org.slf4j.LoggerFactory;





















import com.google.common.collect.Lists;










import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class PerAccessPathMethodAnalyzer<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 protected static final Logger logger = LoggerFactory.getLogger(PerAccessPathMethodAnalyzer.class);










 private Fact sourceFact;










 private final AccessPath<Field> accessPath;










 private Map<WrappedFactAtStatement<Field,Fact, Stmt, Method>, WrappedFactAtStatement<Field,Fact, Stmt, Method>> reachableStatements = Maps.newHashMap();










 private List<WrappedFactAtStatement<Field, Fact, Stmt, Method>> summaries = Lists.newLinkedList();










 private Context<Field, Fact, Stmt, Method> context;










 private Method method;










 private Set<IncomingEdge<Field, Fact, Stmt, Method>> incomingEdges = Sets.newHashSet();










 private Map<AccessPath<Field>, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> nestedAnalyzers = Maps.newHashMap();










 private boolean bootstrapped = false;










 private CacheMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field, Fact, Stmt, Method>> returnSiteResolvers = new CacheMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ReturnSiteResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ReturnSiteResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private CacheMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> ctrFlowJoinResolvers = new CacheMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ControlFlowJoinResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ControlFlowJoinResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private CallEdgeResolver<Field, Fact, Stmt, Method> callEdgeResolver;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> parent;





















 public PerAccessPathMethodAnalyzer(Method method, Fact sourceFact, Context<Field, Fact, Stmt, Method> context) {










 this(method, sourceFact, context, new AccessPath<Field>(), null);










 }










 










 private PerAccessPathMethodAnalyzer(Method method, Fact sourceFact, Context<Field, Fact, Stmt, Method> context, AccessPath<Field> accPath, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> parent) {










 if(method == null)










 throw new IllegalArgumentException("Method must be not null");










 this.parent = parent;










 this.method = method;










 this.sourceFact = sourceFact;










 this.accessPath = accPath;










 this.context = context;










 this.callEdgeResolver = isZeroSource() ? new ZeroCallEdgeResolver<>(this, context.zeroHandler) : new CallEdgeResolver<>(this);










 log("initialized");










 }










 










 WrappedFact<Field, Fact, Stmt, Method> wrappedSource() {










 return new WrappedFact<>(sourceFact, accessPath, callEdgeResolver);










 }










 










 public AccessPath<Field> getAccessPath() {










 return accessPath;










 }










 










 public void bootstrapAtMethodStartPoints() {










 if(bootstrapped)










 return;










 










 callEdgeResolver.interest(this, callEdgeResolver);










 bootstrapped = true;










 for(Stmt startPoint : context.icfg.getStartPointsOf(method)) {










 WrappedFactAtStatement<Field, Fact, Stmt, Method> target = new WrappedFactAtStatement<>(startPoint, wrappedSource());










 if(!reachableStatements.containsKey(target))










 scheduleEdgeTo(target);










 }










 }










 










 public void addInitialSeed(Stmt stmt) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, wrappedSource()));










 }





















 void scheduleEdgeTo(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 if (reachableStatements.containsKey(factAtStmt)) {










 log("Merging "+factAtStmt);










 context.factHandler.merge(reachableStatements.get(factAtStmt).getFact().getFact(), factAtStmt.getFact().getFact());










 } else {










 log("Edge to "+factAtStmt);










 reachableStatements.put(factAtStmt, factAtStmt);










 context.scheduler.schedule(new Job(factAtStmt));










 }










 }





















 void log(String message) {










 logger.trace("[{}; {}{}: "+message+"]", method, sourceFact, accessPath);










 }










 










 @Override










 public String toString() {










 return method+"; "+sourceFact+accessPath;










 }





















 void processCall(WrappedFactAtStatement<Field,Fact, Stmt, Method> factAtStmt) {










 Collection<Method> calledMethods = context.icfg.getCalleesOfCallAt(factAtStmt.getStatement());










 for (Method calledMethod : calledMethods) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeCallFlow(factAtStmt, calledMethod);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 MethodAnalyzer<Field, Fact, Stmt, Method> analyzer = context.getAnalyzer(calledMethod);










 analyzer.addIncomingEdge(new IncomingEdge<Field, Fact, Stmt, Method>(this,










 factAtStmt, targetFact.getFact()));










 }










 }










 










 processCallToReturnEdge(factAtStmt);










 }





















 void processExit(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 log("New Summary: "+factAtStmt);










 if(!summaries.add(factAtStmt))










 throw new AssertionError();





















 










 for(IncomingEdge<Field, Fact, Stmt, Method> incEdge : incomingEdges) {










 applySummary(incEdge, factAtStmt);










 }





















 if(context.followReturnsPastSeeds && isZeroSource()) {










 Collection<Stmt> callSites = context.icfg.getCallersOf(method);










 for(Stmt callSite : callSites) {










 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(callSite);










 for(Stmt returnSite : returnSites) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeUnbalancedReturnFlow(










 sourceFact, factAtStmt, method, returnSite, callSite);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(new WrappedFactAtStatement<>(returnSite, targetFact.getFact()));










 }










 }










 }










 //in cases where there are no callers, the return statement would normally not be processed at all;










 //this might be undesirable if the flow function has a side effect such as registering a taint;










 //instead we thus call the return flow function will a null caller










 if(callSites.isEmpty()) {










 context.flowProcessor.computeUnbalancedReturnFlow(










 sourceFact, factAtStmt, method, null, null);










 }










 }










 }










 










 private void scheduleEdgeTo(Collection<Stmt> successors, WrappedFact<Field, Fact, Stmt, Method> fact) {










 for (Stmt stmt : successors) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, fact));










 }










 }










 










 private void processCallToReturnEdge(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 Stmt stmt = factAtStmt.getStatement();










 int numberOfPredecessors = context.icfg.getPredsOf(stmt).size(); 










 if(numberOfPredecessors > 1 || (context.icfg.isStartPoint(stmt) && numberOfPredecessors > 0)) {










 ctrFlowJoinResolvers.getOrCreate(factAtStmt.getAsFactAtStatement()).addIncoming(factAtStmt.getFact());










 }










 else {










 processNonJoiningCallToReturnFlow(factAtStmt);










 }










 }





















 private void processNonJoiningCallToReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(factAtStmt.getStatement());










 for(Stmt returnSite : returnSites) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeCallToReturnFlow(factAtStmt, returnSite);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, targetFact.getFact()));










 }










 }










 }





















 private void processNormalFlow(WrappedFactAtStatement<Field,Fact, Stmt, Method> factAtStmt) {










 Stmt stmt = factAtStmt.getStatement();










 int numberOfPredecessors = context.icfg.getPredsOf(stmt).size();










 if((numberOfPredecessors > 1 && !context.icfg.isExitStmt(stmt)) || (context.icfg.isStartPoint(stmt) && numberOfPredecessors > 0)) {










 ctrFlowJoinResolvers.getOrCreate(factAtStmt.getAsFactAtStatement()).addIncoming(factAtStmt.getFact());










 }










 else {










 processNormalNonJoiningFlow(factAtStmt);










 }










 }





















 void processFlowFromJoinStmt(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 if(context.icfg.isCallStmt(factAtStmt.getStatement()))










 processNonJoiningCallToReturnFlow(factAtStmt);










 else










 processNormalNonJoiningFlow(factAtStmt);










 }










 










 private void processNormalNonJoiningFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 final List<Stmt> successors = context.icfg.getSuccsOf(factAtStmt.getStatement());










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeNormalFlow(factAtStmt);










 for (final ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 if(targetFact.getConstraint() == null)










 scheduleEdgeTo(successors, targetFact.getFact());










 else {










 targetFact.getFact().getResolver().resolve(targetFact.getConstraint(), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer,










 Resolver<Field, Fact, Stmt, Method> resolver) {










 analyzer.scheduleEdgeTo(successors, new WrappedFact<>(targetFact.getFact().getFact(), targetFact.getFact().getAccessPath(), resolver));










 }





















 @Override










 public void canBeResolvedEmpty() {










 callEdgeResolver.resolve(targetFact.getConstraint(), this);










 }










 });










 }










 }










 }










 










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> getOrCreateNestedAnalyzer(AccessPath<Field> newAccPath) {










 if(newAccPath.equals(accessPath) || isZeroSource())










 return this;










 










 if(!nestedAnalyzers.containsKey(newAccPath)) {










 










 if(token)










 throw new AssertionError();










 










 assert accessPath.getDeltaTo(newAccPath).accesses.length <= 1;










 










 final PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> nestedAnalyzer = new PerAccessPathMethodAnalyzer<>(method, sourceFact, context, newAccPath, this);










 nestedAnalyzers.put(newAccPath, nestedAnalyzer);










 for(IncomingEdge<Field, Fact, Stmt, Method> incEdge : incomingEdges) {










 if(newAccPath.isPrefixOf(incEdge.getCalleeSourceFact().getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX)










 nestedAnalyzer.addIncomingEdge(incEdge);










 else if(incEdge.getCalleeSourceFact().getAccessPath().isPrefixOf(newAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX))










 incEdge.registerInterestCallback(nestedAnalyzer);










 }










 }










 return nestedAnalyzers.get(newAccPath);










 }










 










 boolean token;










 boolean recursiveLock;










 










 boolean isLocked() {










 if(recursiveLock)










 return true;










 if(parent == null)










 return false;










 return parent.isLocked();










 }










 










 public void addIncomingEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 if(accessPath.isPrefixOf(incEdge.getCalleeSourceFact().getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Edge: "+incEdge);










 if(!incomingEdges.add(incEdge))










 return;










 










 callEdgeResolver.interest(this, callEdgeResolver);










 










 applySummaries(incEdge);










 token=true;










 for(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> nestedAnalyzer : nestedAnalyzers.values())










 nestedAnalyzer.addIncomingEdge(incEdge);










 token=false;










 }










 else if(incEdge.getCalleeSourceFact().getAccessPath().isPrefixOf(accessPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 recursiveLock = true;










 incEdge.registerInterestCallback(this);










 recursiveLock = false;










 }










 }





















 private void applySummary(IncomingEdge<Field, Fact, Stmt, Method> incEdge, WrappedFactAtStatement<Field, Fact, Stmt, Method> exitFact) {










 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(incEdge.getCallSite());










 for(Stmt returnSite : returnSites) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeReturnFlow(context.factHandler, exitFact, method, returnSite, incEdge);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 scheduleReturnEdge(incEdge, targetFact.getFact(), returnSite);










 }










 }










 }





















 void scheduleUnbalancedReturnEdgeTo(WrappedFactAtStatement<Field, Fact, Stmt, Method> fact) {










 ReturnSiteResolver<Field,Fact,Stmt,Method> resolver = returnSiteResolvers.getOrCreate(fact.getAsFactAtStatement());










 resolver.addIncoming(new WrappedFact<>(fact.getFact().getFact(), fact.getFact().getAccessPath(), 










 fact.getFact().getResolver()), null, Delta.<Field>empty());










 }










 










 private void scheduleReturnEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge, WrappedFact<Field, Fact, Stmt, Method> fact, Stmt returnSite) {










 Delta<Field> delta = accessPath.getDeltaTo(incEdge.getCalleeSourceFact().getAccessPath());










 ReturnSiteResolver<Field, Fact, Stmt, Method> returnSiteResolver = incEdge.getCallerAnalyzer().returnSiteResolvers.getOrCreate(










 new FactAtStatement<Fact, Stmt>(fact.getFact(), returnSite));










 returnSiteResolver.addIncoming(fact, incEdge.getCalleeSourceFact().getResolver(), delta);










 }





















 private void applySummaries(IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 for(WrappedFactAtStatement<Field, Fact, Stmt, Method> summary : summaries) {










 applySummary(incEdge, summary);










 }










 }










 










 public boolean isZeroSource() {










 return sourceFact.equals(context.zeroValue);










 }





















 private class Job implements Runnable {





















 private WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt;





















 public Job(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 this.factAtStmt = factAtStmt;










 }





















 @Override










 public void run() {










 if (context.icfg.isCallStmt(factAtStmt.getStatement())) {










 processCall(factAtStmt);










 } else {










 if (context.icfg.isExitStmt(factAtStmt.getStatement())) {










 processExit(factAtStmt);










 }










 if (!context.icfg.getSuccsOf(factAtStmt.getStatement()).isEmpty()) {










 processNormalFlow(factAtStmt);










 }










 }










 }










 }





















 public CallEdgeResolver<Field, Fact, Stmt, Method> getCallEdgeResolver() {










 return callEdgeResolver;










 }










 










 public void debugInterest() {










 JsonDocument root = new JsonDocument();










 










 List<PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> worklist = Lists.newLinkedList();










 worklist.add(this);










 Set<PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> visited = Sets.newHashSet();










 










 while(!worklist.isEmpty()) {










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> current = worklist.remove(0);










 if(!visited.add(current))










 continue;










 










 JsonDocument currentMethodDoc = root.doc(current.method.toString()+ "___"+current.sourceFact);










 JsonDocument currentDoc = currentMethodDoc.doc("accPath").doc("_"+current.accessPath.toString());










 










 for(IncomingEdge<Field, Fact, Stmt, Method> incEdge : current.incomingEdges) {










 currentDoc.doc("incoming").doc(incEdge.getCallerAnalyzer().method+"___"+incEdge.getCallerAnalyzer().sourceFact).doc("_"+incEdge.getCallerAnalyzer().accessPath.toString());










 worklist.add(incEdge.getCallerAnalyzer());










 }










 }










 










 try {










 FileWriter writer = new FileWriter("debug/incoming.json");










 StringBuilder builder = new StringBuilder();










 builder.append("var root=");










 root.write(builder, 0);










 writer.write(builder.toString());










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }










 










 public void debugNestings() {










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> current = this;










 while(current.parent != null)










 current = current.parent;










 










 JsonDocument root = new JsonDocument();










 debugNestings(current, root);










 










 try {










 FileWriter writer = new FileWriter("debug/nestings.json");










 StringBuilder builder = new StringBuilder();










 builder.append("var root=");










 root.write(builder, 0);










 writer.write(builder.toString());










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }





















 private void debugNestings(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> current, JsonDocument parentDoc) {










 JsonDocument currentDoc = parentDoc.doc(current.accessPath.toString());










 for(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> nestedAnalyzer : current.nestedAnalyzers.values()) {










 debugNestings(nestedAnalyzer, currentDoc);










 }










 }










}














src/heros/alias/Resolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.List;










import java.util.Map;





















import com.google.common.collect.HashMultimap;










import com.google.common.collect.Lists;





















import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.Constraint;





















public abstract class Resolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private boolean interest = false;










 private List<InterestCallback<Field, Fact, Stmt, Method>> interestCallbacks = Lists.newLinkedList();










 protected PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer;










 private boolean canBeResolvedEmpty = false;










 










 public Resolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 this.analyzer = analyzer;










 }





















 public abstract void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback);










 










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 if(interest)










 return;










 










 log("Interest given");










 interest = true;










 for(InterestCallback<Field, Fact, Stmt, Method> callback : Lists.newLinkedList(interestCallbacks)) {










 callback.interest(analyzer, resolver);










 }










 










 if(canBeResolvedEmpty)










 interestCallbacks = null;










 }










 










 protected void canBeResolvedEmpty() {










 if(canBeResolvedEmpty)










 return;










 










 canBeResolvedEmpty = true;










 for(InterestCallback<Field, Fact, Stmt, Method> callback : Lists.newLinkedList(interestCallbacks)) {










 callback.canBeResolvedEmpty();










 }










 










 if(interest)










 interestCallbacks = null;










 }





















 public boolean isInterestGiven() {










 return interest;










 }





















 protected void registerCallback(InterestCallback<Field, Fact, Stmt, Method> callback) {










 if(interest) {










 callback.interest(analyzer, this);










 }










 else {










 log("Callback registered");










 interestCallbacks.add(callback);










 }





















 if(canBeResolvedEmpty)










 callback.canBeResolvedEmpty();










 }










 










 protected abstract void log(String message);










 










}














src/heros/alias/ReturnSiteResolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















import java.util.Map;










import java.util.Set;





















import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private Stmt returnSite;










 private AccessPath<Field> resolvedAccPath;










 private boolean propagated = false;










 private Set<ReturnEdge> incomingFacts;










 private Map<AccessPath<Field>, ReturnSiteResolver<Field, Fact, Stmt, Method>> nestedResolvers = Maps.newHashMap();










 private ReturnSiteResolver<Field, Fact, Stmt, Method> parent;





















 public ReturnSiteResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt returnSite) {










 this(analyzer, returnSite, new AccessPath<Field>(), null);










 }





















 private ReturnSiteResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt returnSite, AccessPath<Field> resolvedAccPath, ReturnSiteResolver<Field, Fact, Stmt, Method> parent) {










 super(analyzer);










 this.returnSite = returnSite;










 this.resolvedAccPath = resolvedAccPath;










 this.parent = parent;










 this.incomingFacts = Sets.newHashSet();










 }










 










 @Override










 public String toString() {










 return "<"+resolvedAccPath+":"+returnSite+">";










 }










 










 public AccessPath<Field> getResolvedAccessPath() {










 return resolvedAccPath;










 }










 










 public void addIncoming(final WrappedFact<Field, Fact, Stmt, Method> fact, 










 Resolver<Field, Fact, Stmt, Method> resolverAtCaller, 










 Delta<Field> callDelta) {










 










 addIncoming(new ReturnEdge(fact, resolverAtCaller, callDelta));










 }










 










 private void addIncoming(final ReturnEdge retEdge) {










 if(resolvedAccPath.isPrefixOf(retEdge.incAccessPath) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Edge "+retEdge);










 if(!incomingFacts.add(retEdge))










 return;





















 interest(analyzer, this);










 










 for(ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver : nestedResolvers.values())










 nestedResolver.addIncoming(nestedResolver.new ReturnEdge(retEdge.incFact, retEdge.incAccessPath, retEdge.incResolver, 










 retEdge.resolverAtCaller, retEdge.callDelta, retEdge.usedAccessPathOfIncResolver));





















 if(!propagated) {










 propagated=true;










 analyzer.scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, 










 new WrappedFact<>(retEdge.incFact, new AccessPath<Field>(), this)));










 }










 }










 else if(retEdge.incAccessPath.isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 log("Incoming potential prefix:  "+retEdge);










 retEdge.resolveViaDelta();










 }










 }










 










 protected void log(String message) {










 analyzer.log("Return Site "+toString()+": "+message);










 }





















 @Override










 public void resolve(Constraint<Field> constraint, final InterestCallback<Field, Fact, Stmt, Method> callback) {










 log("Resolve: "+constraint);










 if(!constraint.canBeAppliedTo(resolvedAccPath))










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);










 }










 










 private ReturnSiteResolver<Field, Fact, Stmt, Method> getOrCreateNestedResolver(AccessPath<Field> candidateAccPath) {










 if(resolvedAccPath.equals(candidateAccPath))










 return this;










 










 if(!nestedResolvers.containsKey(candidateAccPath)) {










 assert resolvedAccPath.getDeltaTo(candidateAccPath).accesses.length <= 1;










 final ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver = new ReturnSiteResolver<>(analyzer, returnSite, candidateAccPath, this);










 nestedResolver.propagated = true;










 nestedResolvers.put(candidateAccPath, nestedResolver);





















 for(ReturnSiteResolver<Field, Fact, Stmt, Method>.ReturnEdge retEdge: incomingFacts) {










 nestedResolver.addIncoming(nestedResolver.new ReturnEdge(retEdge.incFact, retEdge.incAccessPath, retEdge.incResolver, 










 retEdge.resolverAtCaller, retEdge.callDelta, retEdge.usedAccessPathOfIncResolver));










 } 










 }










 return nestedResolvers.get(candidateAccPath);










 }










 










 private class ReturnEdge {





















 final Fact incFact;










 final Resolver<Field, Fact, Stmt, Method> resolverAtCaller;










 final Delta<Field> callDelta;










 final AccessPath<Field> incAccessPath;










 final Resolver<Field, Fact, Stmt, Method> incResolver;










 final Delta<Field> usedAccessPathOfIncResolver;





















 public ReturnEdge(WrappedFact<Field, Fact, Stmt, Method> fact, Resolver<Field, Fact, Stmt, Method> resolverAtCaller,










 Delta<Field> callDelta) {










 this(fact.getFact(), fact.getAccessPath(), fact.getResolver(), resolverAtCaller, callDelta, Delta.<Field>empty());










 }










 










 private ReturnEdge(Fact incFact, AccessPath<Field> incAccessPath, Resolver<Field, Fact, Stmt, Method> incResolver, 










 Resolver<Field, Fact, Stmt, Method> resolverAtCaller, Delta<Field> callDelta, Delta<Field> usedAccessPathOfIncResolver) {










 this.incFact = incFact;










 this.incAccessPath = incAccessPath;










 this.incResolver = incResolver;










 this.resolverAtCaller = resolverAtCaller;










 this.callDelta = callDelta;










 this.usedAccessPathOfIncResolver = usedAccessPathOfIncResolver;










 }










 










 @Override










 public String toString() {










 return String.format("IncFact: %s%s, Delta: %s, IncResolver: <%s:%s>, ResolverAtCallSite: %s", incFact, incAccessPath, callDelta, usedAccessPathOfIncResolver, incResolver, resolverAtCaller);










 }










 










 public void resolveViaDelta() {










 if(incResolver == null || incResolver instanceof CallEdgeResolver) {










 resolveViaDeltaAndPotentiallyDelegateToCallSite();










 } else {










 //resolve via incoming facts resolver










 Delta<Field> delta = usedAccessPathOfIncResolver.applyTo(incAccessPath, true).getDeltaTo(resolvedAccPath);










 assert delta.accesses.length <= 1;










 incResolver.resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {





















 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, resolver, resolverAtCaller, callDelta, incAccessPath.getDeltaTo(resolvedAccPath)));










 ReturnSiteResolver.this.interest(analyzer, resolver);










 }










 










 @Override










 public void canBeResolvedEmpty() {










 resolveViaDeltaAndPotentiallyDelegateToCallSite();










 }










 });










 } 










 }





















 private void resolveViaDeltaAndPotentiallyDelegateToCallSite() {










 final AccessPath<Field> currAccPath = callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath, true), true);










 if(resolvedAccPath.isPrefixOf(currAccPath) == PrefixTestResult.GUARANTEED_PREFIX) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver));










 ReturnSiteResolver.this.interest(analyzer, ReturnSiteResolver.this);










 } else if(currAccPath.isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 resolveViaCallSiteResolver(currAccPath);










 }










 }





















 protected void resolveViaCallSiteResolver(AccessPath<Field> currAccPath) {










 if(resolverAtCaller == null || resolverAtCaller instanceof CallEdgeResolver) {










 ReturnSiteResolver.this.canBeResolvedEmpty();










 } else {










 resolverAtCaller.resolve(new DeltaConstraint<>(currAccPath.getDeltaTo(resolvedAccPath)), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, null, resolver, Delta.<Field>empty(), incAccessPath.getDeltaTo(resolvedAccPath)));










 ReturnSiteResolver.this.interest(analyzer, ReturnSiteResolver.this);










 }










 










 @Override










 public void canBeResolvedEmpty() {










 ReturnSiteResolver.this.canBeResolvedEmpty();










 }










 });










 }










 }










 }





















 public Stmt getReturnSite() {










 return returnSite;










 }










}














src/heros/alias/Scheduler.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.LinkedList;










import com.google.common.collect.Lists;





















public class Scheduler {





















 private LinkedList<Runnable> worklist = Lists.newLinkedList();










 










 public void schedule(Runnable job) {










 worklist.add(job);










 }





















 public void runAndAwaitCompletion() {










 while(!worklist.isEmpty()) {










 worklist.removeLast().run();










 }










 }





















}














src/heros/alias/TestDebugger.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.io.FileWriter;










import java.io.IOException;










import java.util.Set;





















import com.google.common.collect.Sets;





















import heros.InterproceduralCFG;










import heros.alias.TestHelper.Edge;





















public class TestDebugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 private JsonDocument root = new JsonDocument();










 private I icfg;










 










 public void writeJsonDebugFile(String filename) {










 try {










 FileWriter writer = new FileWriter(filename);










 StringBuilder builder = new StringBuilder();










 builder.append("var root=");










 root.write(builder, 0);










 writer.write(builder.toString());










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }










 










 /* (non-Javadoc)










	 * @see heros.alias.Debugger#setICFG(I)










	 */










 @Override










 public void setICFG(I icfg) {










 this.icfg = icfg;










 }





















 /* (non-Javadoc)










	 * @see heros.alias.Debugger#initialSeed(Stmt)










	 */










 @Override










 public void initialSeed(Stmt stmt) {










 stmt(stmt).keyValue("seed", "true");










 










 includeSuccessors(stmt, Sets.<Stmt> newHashSet());










 }










 










 private void includeSuccessors(Stmt stmt, Set<Stmt> visited) {










 if(!visited.add(stmt))










 return;










 










 JsonDocument doc = stmt(stmt);










 for(Stmt succ : icfg.getSuccsOf(stmt)) {










 doc.array("successors").add(succ.toString());










 stmt(succ);










 includeSuccessors(succ, visited);










 }










 










 if(icfg.isCallStmt(stmt)) {










 for(Method m : icfg.getCalleesOfCallAt(stmt)) {










 doc.doc("calls").doc(m.toString());










 for(Stmt sp : icfg.getStartPointsOf(m)) {










 stmt(sp).keyValue("startPoint", "true");










 includeSuccessors(sp, visited);










 }










 }










 for(Stmt retSite :icfg.getReturnSitesOfCallAt(stmt)) {










 doc.array("successors").add(retSite.toString());










 stmt(retSite);










 includeSuccessors(retSite, visited);










 }










 }










 if(icfg.isExitStmt(stmt)) {










 for(Stmt callSite : icfg.getCallersOf(icfg.getMethodOf(stmt))) {










 for(Stmt retSite : icfg.getReturnSitesOfCallAt(callSite)) {










 doc.doc("returns").doc(retSite.toString());










 includeSuccessors(retSite, visited);










 }










 }










 }










 }





















 protected JsonDocument stmt(Stmt stmt) {










 Method methodOf = icfg.getMethodOf(stmt);










 return root.doc("methods").doc(methodOf.toString()).doc(stmt.toString());










 }










 










 public void expectNormalFlow(Stmt unit, String expectedFlowFunctionsToString) {










 stmt(unit).keyValue("flow", expectedFlowFunctionsToString);










 }





















 public void expectCallFlow(Stmt callSite, Method destinationMethod, String expectedFlowFunctionsToString) {










 stmt(callSite).doc("calls").doc(destinationMethod.toString()).keyValue("flow", expectedFlowFunctionsToString);










 }





















 public void expectReturnFlow(Stmt exitStmt, Stmt returnSite, String expectedFlowFunctionsToString) {










 if(returnSite != null)










 stmt(exitStmt).doc("returns").doc(returnSite.toString()).keyValue("flow", expectedFlowFunctionsToString);










 }





















 static void tabs(int tabs, StringBuilder builder) {










 for(int i=0; i<tabs; i++)










 builder.append("\t");










 }





















}














src/heros/alias/Transition.java








View file @ 3398e46f






......@@ -72,14 +72,16 @@ public interface Transition<FieldRef> {









 } else {










 Set<FieldRef> otherExcludedFields = ((ExclusionPathTransition<FieldRef>) t).excludedFields;










 boolean intersection = false;










 boolean containsAll = true;










 boolean containsAll = excludedFields.containsAll(otherExcludedFields);










 boolean oppositeContainsAll = otherExcludedFields.containsAll(excludedFields);










 for(FieldRef field : excludedFields) {










 if(otherExcludedFields.contains(field))










 if(otherExcludedFields.contains(field)) {










 intersection = true;










 else










  containsAll = false;










  break;










 }










 }










 return new MatchResult<>(containsAll || !intersection, containsAll);










 boolean potentialMatch = oppositeContainsAll || !intersection || (!containsAll && !oppositeContainsAll);










 return new MatchResult<>(potentialMatch, oppositeContainsAll);










 }










 










 return new MatchResult<>(false, false);



......














test/heros/alias/Fact.java

→

src/heros/alias/WrappedFact.java








View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at



......@@ -10,87 +10,58 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;





















import java.util.ArrayList;










import java.util.Arrays;










import java.util.regex.Matcher;










import java.util.regex.Pattern;










public class WrappedFact<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method>{





















import com.google.common.base.Joiner;










import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, TestFieldRef, Fact> {





















 public final String baseValue;










 public final AccessPath<TestFieldRef> accessPath;










 private final Fact fact;










 private final AccessPath<Field> accessPath;










 private final Resolver<Field, Fact, Stmt, Method> resolver;










 










 public Fact(String name) {










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 AccessPath<TestFieldRef> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();










 baseValue = name.substring(0, firstSeparator);










 matcher.reset();










 WrappedFact(Fact fact, AccessPath<Field> accessPath, Resolver<Field, Fact, Stmt, Method> resolver) {










 assert fact != null;










 assert accessPath != null;










 assert resolver != null;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(separator.equals(".")) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(new TestFieldRef(identifier));










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 TestFieldRef[] fExcl = new TestFieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new TestFieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 }










 }










 this.fact = fact;










 this.accessPath = accessPath;










 this.resolver = resolver;










 }










 










 public Fact(String baseValue, AccessPath<TestFieldRef> accessPath) {










 this.baseValue = baseValue;










 this.accessPath = accessPath;










 public Fact getFact() {










 return fact;










 }










 










 @Override










 public String toString() {










 return "[Fact "+baseValue+(accessPath.isEmpty() ? "" : accessPath)+"]";










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta, boolean merge) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath, merge), resolver); //TODO keep resolver?










 }





















 @Override










 public String getBaseValue() {










 return baseValue;










 }





















 @Override










 public AccessPath<TestFieldRef> getAccessPath() {










 public AccessPath<Field> getAccessPath() {










 return accessPath;










 }





















 @Override










 public void addNeighbor(Fact originalAbstraction) {










 










 










 public WrappedFact<Field, Fact, Stmt, Method> applyConstraint(Constraint<Field> constraint, Fact zeroValue, boolean sourceFact) {










 if(fact.equals(zeroValue))










 return this;










 else










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath, sourceFact), resolver);










 }





















 










 @Override










 public void setCallingContext(Fact callingContext) {










 










 public String toString() {










 String result = fact.toString()+accessPath;










 if(resolver != null)










 result+=resolver.toString();










 return result;










 }





















 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((accessPath == null) ? 0 : accessPath.hashCode());










 result = prime * result + ((baseValue == null) ? 0 : baseValue.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -100,25 +71,29 @@ public class Fact implements FieldSensitiveFact<String, TestFieldRef, Fact> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof Fact))










 if (getClass() != obj.getClass())










 return false;










 Fact other = (Fact) obj;










 WrappedFact other = (WrappedFact) obj;










 if (accessPath == null) {










 if (other.accessPath != null)










 return false;










 } else if (!accessPath.equals(other.accessPath))










 return false;










 if (baseValue == null) {










 if (other.baseValue != null)










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!baseValue.equals(other.baseValue))










 } else if (!fact.equals(other.fact))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }





















 @Override










 public Fact cloneWithAccessPath(AccessPath<TestFieldRef> accessPath) {










 return new Fact(baseValue, accessPath);










 public Resolver<Field, Fact, Stmt, Method> getResolver() {










 return resolver;










 }










 










 



......














src/heros/alias/SummaryEdge.java

→

src/heros/alias/WrappedFactAtStatement.java








View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at



......@@ -10,70 +10,66 @@









 ******************************************************************************/










package heros.alias;





















public class SummaryEdge<D, N> {










public class WrappedFactAtStatement<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private D sourceFact;










 private N targetStmt;










 private D targetFact;










 private WrappedFact<Field,Fact, Stmt, Method> fact;










 private Stmt stmt;





















 public WrappedFactAtStatement(Stmt stmt, WrappedFact<Field, Fact, Stmt, Method> fact) {










 this.stmt = stmt;










 this.fact = fact;










 }





















 public WrappedFact<Field,Fact, Stmt, Method> getFact() {










 return fact;










 }





















 public Stmt getStatement() {










 return stmt;










 }










 










 public FactAtStatement<Fact, Stmt> getAsFactAtStatement() {










 return new FactAtStatement<Fact, Stmt>(fact.getFact(), stmt);










 }










 










 public SummaryEdge(D sourceFact, N targetStmt, D targetFact) {










 this.sourceFact = sourceFact;










 this.targetStmt = targetStmt;










 this.targetFact = targetFact;










 public boolean canDeltaBeApplied(AccessPath.Delta<Field> delta) {










 return delta.canBeAppliedTo(fact.getAccessPath());










 }










 










 @Override










 public String toString() {










 return "[SummaryEdge: "+sourceFact+" -> "+targetFact+" @stmt: "+targetStmt+"]";










 return fact+" @ "+stmt;










 }





















 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((sourceFact == null) ? 0 : sourceFact.hashCode());










 result = prime * result + ((targetFact == null) ? 0 : targetFact.hashCode());










 result = prime * result + ((targetStmt == null) ? 0 : targetStmt.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((stmt == null) ? 0 : stmt.hashCode());










 return result;










 }










 





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SummaryEdge))










 if (getClass() != obj.getClass())










 return false;










 SummaryEdge other = (SummaryEdge) obj;










 if (sourceFact == null) {










 if (other.sourceFact != null)










 WrappedFactAtStatement other = (WrappedFactAtStatement) obj;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!sourceFact.equals(other.sourceFact))










 } else if (!fact.equals(other.fact))










 return false;










 if (targetFact == null) {










 if (other.targetFact != null)










 if (stmt == null) {










 if (other.stmt != null)










 return false;










 } else if (!targetFact.equals(other.targetFact))










 return false;










 if (targetStmt == null) {










 if (other.targetStmt != null)










 return false;










 } else if (!targetStmt.equals(other.targetStmt))










 } else if (!stmt.equals(other.stmt))










 return false;










 return true;










 }





















 public D getSourceFact() {










 return sourceFact;










 }










 










 public D getTargetFact() {










 return targetFact;










 }










 










 public N getTargetStmt() {










 return targetStmt;










 }










 










}














src/heros/alias/ZeroCallEdgeResolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class ZeroCallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends CallEdgeResolver<Field, Fact, Stmt, Method> {





















 private ZeroHandler<Field> zeroHandler;





















 public ZeroCallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, ZeroHandler<Field> zeroHandler) {










 super(analyzer);










 this.zeroHandler = zeroHandler;










 }





















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) {










 if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(new AccessPath<Field>(), true)))










 callback.interest(analyzer, this);










 }










 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 }










}














src/heros/alias/FieldSensitiveFact.java

→

src/heros/alias/ZeroHandler.java








View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch, Johannes Späth.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch, Johannes Späth - initial API and implementation










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.solver.LinkedNode;










public interface ZeroHandler<Field extends AccessPath.FieldRef<Field>> {





















public interface FieldSensitiveFact<BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D> extends LinkedNode<D>{





















 BaseValue getBaseValue();










 










 AccessPath<FieldRef> getAccessPath();










 










 D cloneWithAccessPath(AccessPath<FieldRef> accessPath);










 










 boolean shouldGenerateAccessPath(AccessPath<Field> accPath);










}














test/heros/alias/AccessPathTest.java








View file @ 3398e46f






......@@ -19,6 +19,7 @@ import org.junit.Test;




















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.SubAccessPath.*;














......@@ -36,7 +37,7 @@ public class AccessPathTest {









 }










 return result;










 }










 





















 private static SetOfPossibleFieldAccesses<TestFieldRef> anyOf(String...fields) {










 Set<TestFieldRef> set = Sets.newHashSet();










 for(String f : fields)



......@@ -49,7 +50,7 @@ public class AccessPathTest {









 }










 










 private static AccessPath<TestFieldRef> ap(SubAccessPath<TestFieldRef>... path) {










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet(), null);










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet());










 }










 










 @Test



......@@ -64,6 +65,12 @@ public class AccessPathTest {









 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMultipleFieldsAndMerge() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(f("b", "a")));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<TestFieldRef> sut = ap(s("a"));



......@@ -190,6 +197,20 @@ public class AccessPathTest {









 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaFromSetToSet() {










 Delta<TestFieldRef> actual = ap(anyOf("a")).appendExcludedFieldReference(f("f")).getDeltaTo(ap(anyOf("a")).appendExcludedFieldReference(f("g")));










 assertArrayEquals(new SubAccessPath[] { anyOf("a") }, actual.accesses);










 assertEquals(Sets.newHashSet(f("g")), actual.exclusions);










 }










 










 @Test










 public void emptyDeltaOnEqualExclusions() {










 AccessPath<TestFieldRef> actual = ap().appendExcludedFieldReference(f("f"));










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).exclusions.equals(Sets.newHashSet(f("f"))));










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;



......@@ -227,6 +248,12 @@ public class AccessPathTest {









 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void multipleExclPrefixOfMultipleExcl() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference(f("f", "h"))));










 }










 










 @Test










 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));



......














test/heros/alias/AccessPathUtilTest.java








View file @ 3398e46f






......@@ -11,125 +11,109 @@









package heros.alias;





















import static heros.alias.AccessPath.PrefixTestResult.*;










import static heros.alias.AccessPathUtil.applyAbstractedSummary;










import static heros.alias.AccessPathUtil.isPrefixOf;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertTrue;





















import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import heros.alias.AccessPath.PrefixTestResult;





















import org.junit.Test;





















public class AccessPathUtilTest {





















 public static AccessPath<TestFieldRef> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<TestFieldRef> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(new TestFieldRef(identifier));










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 TestFieldRef[] fExcl = new TestFieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new TestFieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 }










 }










 return accessPath;










 }










 










 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a"), new Fact("a.f")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a")));










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("f")));










 assertEquals(NO_PREFIX, ap("f").isPrefixOf(ap("")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a"), new Fact("a")));










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.b"), new Fact("a.b.c")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.b.c"), new Fact("a.b")));










 assertEquals(GUARANTEED_PREFIX, ap("b").isPrefixOf(ap("b.c")));










 assertEquals(NO_PREFIX, ap("b.c").isPrefixOf(ap("b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.g")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.g"), new Fact("a^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g")));










 assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a^f")));










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f,g"), new Fact("a^f,g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertEquals(POTENTIAL_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.g.g")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.f.h")));










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f,g"), new Fact("a^g")));










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f")));










 assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.g.h")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h")));










 }










 










 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a"), new Fact("a^f")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a")));










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));










 










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a.f^g^h")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 }










 










 @Test










 public void testAbstractedSummary() {










 assertEquals(new Fact("z.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h")));










 assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f")));










 }










 










 @Test










 public void testAbstractedFieldAccessSummary() {










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryIntroducesFieldAccess() {










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.c"), new SummaryEdge<>(new Fact("a"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryRemovesFieldAccess() {










 assertEquals(new Fact("z.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testNonAbstractedSummary() {










 assertEquals(new Fact("z"), applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testSummaryWithExcludedField() {










 assertEquals(new Fact("a.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testIdentityForExclusions() {










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a"))).get());










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).get());










 }










 










 @Test










 public void testMergeExclusions() {










 assertEquals(new Fact("a^f,g"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testNullOnImpossibleSubsumption() {










 assertFalse(applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).isPresent());










 }










}














test/heros/alias/ControlFlowJoinResolverTest.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;





















import org.junit.Before;










import org.junit.Test;










import org.mockito.ArgumentMatcher;










import org.mockito.Mockito;










import org.mockito.invocation.InvocationOnMock;










import org.mockito.stubbing.Answer;










import org.mockito.verification.VerificationMode;





















public class ControlFlowJoinResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement joinStmt;










 private ControlFlowJoinResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 joinStmt = new TestStatement("joinStmt");










 sut = new ControlFlowJoinResolver<>(analyzer, joinStmt);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);










 }





















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver));










 verify(analyzer).processFlowFromJoinStmt(eq(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver));










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));










 }










 










 










 private class ResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;





















 public ResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 this.accPath = accPath;










 }





















 @Override










 public boolean matches(Object argument) {










 ControlFlowJoinResolver resolver = (ControlFlowJoinResolver) argument;










 return resolver.isInterestGiven() && resolver.getResolvedAccessPath().equals(accPath) && resolver.getJoinStmt().equals(joinStmt);










 }










 }










}














test/heros/alias/EdgeBuilder.java








View file @ 3398e46f






......@@ -32,43 +32,44 @@ public abstract class EdgeBuilder {




















 public static class CallSiteBuilder extends EdgeBuilder {





















 private Statement callSite;










 private TestStatement callSite;





















 public CallSiteBuilder(Statement callSite) {










 public CallSiteBuilder(TestStatement callSite) {










 this.callSite = callSite;










 }





















 public CallSiteBuilder calls(String method, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.CallEdge(callSite, new Method(method), flows));










 edges.add(new TestHelper.CallEdge(callSite, new TestMethod(method), flows));










 return this;










 }










 










 public CallSiteBuilder retSite(String returnSite, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new Statement(returnSite), flows));










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new TestStatement(returnSite), flows));










 return this;










 }










 }










 










 public static class NormalStmtBuilder extends EdgeBuilder {





















 private Statement stmt;










 private TestStatement stmt;










 private ExpectedFlowFunction[] flowFunctions;





















 public NormalStmtBuilder(Statement stmt) {










 public NormalStmtBuilder(TestStatement stmt, ExpectedFlowFunction[] flowFunctions) {










 this.stmt = stmt;










 this.flowFunctions = flowFunctions;










 }





















 public NormalStmtBuilder succ(String succ, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.NormalEdge(stmt, new Statement(succ), flows));










 public NormalStmtBuilder succ(String succ) {










 edges.add(new TestHelper.NormalEdge(stmt, new TestStatement(succ), flowFunctions));










 return this;










 }










 










 }










 










 public static class ExitStmtBuilder extends EdgeBuilder {





















 private Statement exitStmt;










 private TestStatement exitStmt;





















 public ExitStmtBuilder(Statement exitStmt) {










 public ExitStmtBuilder(TestStatement exitStmt) {










 this.exitStmt = exitStmt;










 }










 



......@@ -77,7 +78,7 @@ public abstract class EdgeBuilder {









 return this;










 }





















 public ExitStmtBuilder returns(Statement callSite, Statement returnSite, ExpectedFlowFunction... flows) {










 public ExitStmtBuilder returns(TestStatement callSite, TestStatement returnSite, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.ReturnEdge(callSite, exitStmt, returnSite, flows));










 return this;










 }



......














test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ 3398e46f





This diff is collapsed.
Click to expand it.













test/heros/alias/ReturnSiteResolverTest.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;





















import org.junit.Before;










import org.junit.Test;










import org.mockito.ArgumentMatcher;










import org.mockito.Mockito;










import org.mockito.invocation.InvocationOnMock;










import org.mockito.stubbing.Answer;










import org.mockito.verification.VerificationMode;





















public class ReturnSiteResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement returnSite;










 private ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 returnSite = new TestStatement("returnSite");










 sut = new ReturnSiteResolver<>(analyzer, returnSite);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);










 }





















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 verify(analyzer).scheduleEdgeTo(eq(new WrappedFactAtStatement<>(returnSite, new WrappedFact<>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver), callEdgeResolver, getDelta());










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }










 










 @Test










 public void resolveViaDelta() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }










 










 @Test










 public void resolveViaDeltaTwice() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a", "b"));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(innerCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));










 }










 










 @Test










 public void resolveViaDeltaAndThenViaCallSite() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(innerCallback).canBeResolvedEmpty();










 }





















 @Test










 public void resolveViaCallEdgeResolverAtCallSite() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).canBeResolvedEmpty();










 }










 










 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 @Test










 public void resolveViaResolverAtCallSiteTwice() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback innerCallback = (InterestCallback) invocation.getArguments()[1];










 innerCallback.interest(analyzer, nestedResolver);










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback innerCallback = (InterestCallback) invocation.getArguments()[1];










 innerCallback.interest(analyzer, nestedResolver);










 return null;










 }










 }).when(nestedResolver).resolve(eq(getDeltaConstraint("b")), any(InterestCallback.class));










 










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), secondCallback);










 return null;










 }










 










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(secondCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));










 }










 










 @Test










 public void resolveAsEmptyViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Delta<TestFieldRef> delta = new AccessPath<TestFieldRef>().getDeltaTo(new AccessPath<TestFieldRef>().appendExcludedFieldReference(new TestFieldRef("a")));










 










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback innerCallback = (InterestCallback) invocation.getArguments()[1];










 innerCallback.canBeResolvedEmpty();










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));





















 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, delta);










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback, never()).canBeResolvedEmpty();










 verify(callback, never()).interest(any(PerAccessPathMethodAnalyzer.class), any(Resolver.class));










 }










 










 @Test










 public void resolveViaCallSiteResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 private class ReturnSiteResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;





















 public ReturnSiteResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 this.accPath = accPath;










 }





















 @Override










 public boolean matches(Object argument) {










 ReturnSiteResolver resolver = (ReturnSiteResolver) argument;










 return resolver.isInterestGiven() && resolver.getResolvedAccessPath().equals(accPath) && resolver.getReturnSite().equals(returnSite);










 }










 }










}









Prev


1


2


3


Next















Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment






Commit
3398e46f


authored
Feb 25, 2015
by


Johannes Lerch



Browse files



Commit
3398e46f


authored
Feb 25, 2015
by


Johannes Lerch

3398e46fauthoredbyJohannes Lerch

rewrite of ifds solver






parent
55cdd2d8
















parent
55cdd2d8





parent












Changes
45
45


Expand all
Hide whitespace changes

Inline
Side-by-side






Expand all
Hide whitespace changes

Inline
Side-by-side




Expand all
Hide whitespace changes

Inline
Side-by-side


Inline
Side-by-side










src/heros/alias/InterestCallback.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public interface InterestCallback<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver);










 










//	void partiallyResolved(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver, AccessPath<Field> resolvedAccPath);










 










 void canBeResolvedEmpty();










}














src/heros/alias/JsonArray.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.List;





















import com.google.common.collect.Lists;





















class JsonArray {










 










 private List<String> items = Lists.newLinkedList();










 










 public void add(String item) {










 items.add(item);










 }





















 public void write(StringBuilder builder, int tabs) {










 builder.append("[\n");










 for(String item: items) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+item+"\",\n");










 }










 TestDebugger.tabs(tabs, builder); builder.append("]");










 }










}




\ No newline at end of file














src/heros/alias/JsonDocument.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Map;










import java.util.Map.Entry;





















import com.google.common.collect.Maps;





















class JsonDocument {










 










 private CacheMap<String, JsonDocument> documents = new CacheMap<String, JsonDocument>() {










 @Override










 protected JsonDocument createItem(String key) {










 return new JsonDocument();










 }










 };










 private CacheMap<String, JsonArray> arrays = new CacheMap<String, JsonArray>() {










 @Override










 protected JsonArray createItem(String key) {










 return new JsonArray();










 }










 };










 private Map<String, String> keyValuePairs = Maps.newHashMap();










 










 public JsonDocument doc(String key) {










 return documents.getOrCreate(key);










 }










 










 public JsonArray array(String key) {










 return arrays.getOrCreate(key);










 }










 










 public void keyValue(String key, String value) {










 keyValuePairs.put(key, value);










 }










 










 public void write(StringBuilder builder, int tabs) {










 builder.append("{\n");










 










 for(Entry<String, String> entry : keyValuePairs.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n");










 }










 










 for(Entry<String, JsonArray> entry : arrays.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");





















 }










 










 for(Entry<String, JsonDocument> entry : documents.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");










 }










 










 TestDebugger.tabs(tabs, builder); builder.append("}");










 }





















}




\ No newline at end of file














src/heros/alias/MethodAnalyzer.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;
































public class MethodAnalyzer<Field extends AccessPath.FieldRef<Field>,










 Fact, 










 Stmt, 










 Method> {





















 private Method method;










 private CacheMap<Fact, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> perSourceAnalyzer = 










 new CacheMap<Fact, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>>() {










 @Override










 protected PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> createItem(Fact key) {










 return new PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>(method, key, context);










 }










 };










 private Context<Field, Fact, Stmt, Method> context;










 










 MethodAnalyzer(Method method, Context<Field, Fact, Stmt, Method> context) {










 this.method = method;










 this.context = context;










 }










 










 public void addIncomingEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact = incEdge.getCalleeSourceFact();










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer = perSourceAnalyzer.getOrCreate(calleeSourceFact.getFact());










 analyzer.bootstrapAtMethodStartPoints();










 analyzer.addIncomingEdge(incEdge);










 }





















 public void addInitialSeed(Stmt startPoint, Fact val) {










 perSourceAnalyzer.getOrCreate(val).addInitialSeed(startPoint);










 }










 










 public void addUnbalancedReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> target) {










 perSourceAnalyzer.getOrCreate(context.zeroValue).scheduleUnbalancedReturnEdgeTo(target);










 }










}














src/heros/alias/PerAccessPathMethodAnalyzer.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.ConstrainedFact;





















import java.io.FileWriter;










import java.io.IOException;










import java.util.Collection;










import java.util.List;










import java.util.Map;










import java.util.Set;





















import org.slf4j.Logger;










import org.slf4j.LoggerFactory;





















import com.google.common.collect.Lists;










import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class PerAccessPathMethodAnalyzer<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 protected static final Logger logger = LoggerFactory.getLogger(PerAccessPathMethodAnalyzer.class);










 private Fact sourceFact;










 private final AccessPath<Field> accessPath;










 private Map<WrappedFactAtStatement<Field,Fact, Stmt, Method>, WrappedFactAtStatement<Field,Fact, Stmt, Method>> reachableStatements = Maps.newHashMap();










 private List<WrappedFactAtStatement<Field, Fact, Stmt, Method>> summaries = Lists.newLinkedList();










 private Context<Field, Fact, Stmt, Method> context;










 private Method method;










 private Set<IncomingEdge<Field, Fact, Stmt, Method>> incomingEdges = Sets.newHashSet();










 private Map<AccessPath<Field>, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> nestedAnalyzers = Maps.newHashMap();










 private boolean bootstrapped = false;










 private CacheMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field, Fact, Stmt, Method>> returnSiteResolvers = new CacheMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ReturnSiteResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ReturnSiteResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private CacheMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> ctrFlowJoinResolvers = new CacheMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ControlFlowJoinResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ControlFlowJoinResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private CallEdgeResolver<Field, Fact, Stmt, Method> callEdgeResolver;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> parent;





















 public PerAccessPathMethodAnalyzer(Method method, Fact sourceFact, Context<Field, Fact, Stmt, Method> context) {










 this(method, sourceFact, context, new AccessPath<Field>(), null);










 }










 










 private PerAccessPathMethodAnalyzer(Method method, Fact sourceFact, Context<Field, Fact, Stmt, Method> context, AccessPath<Field> accPath, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> parent) {










 if(method == null)










 throw new IllegalArgumentException("Method must be not null");










 this.parent = parent;










 this.method = method;










 this.sourceFact = sourceFact;










 this.accessPath = accPath;










 this.context = context;










 this.callEdgeResolver = isZeroSource() ? new ZeroCallEdgeResolver<>(this, context.zeroHandler) : new CallEdgeResolver<>(this);










 log("initialized");










 }










 










 WrappedFact<Field, Fact, Stmt, Method> wrappedSource() {










 return new WrappedFact<>(sourceFact, accessPath, callEdgeResolver);










 }










 










 public AccessPath<Field> getAccessPath() {










 return accessPath;










 }










 










 public void bootstrapAtMethodStartPoints() {










 if(bootstrapped)










 return;










 










 callEdgeResolver.interest(this, callEdgeResolver);










 bootstrapped = true;










 for(Stmt startPoint : context.icfg.getStartPointsOf(method)) {










 WrappedFactAtStatement<Field, Fact, Stmt, Method> target = new WrappedFactAtStatement<>(startPoint, wrappedSource());










 if(!reachableStatements.containsKey(target))










 scheduleEdgeTo(target);










 }










 }










 










 public void addInitialSeed(Stmt stmt) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, wrappedSource()));










 }





















 void scheduleEdgeTo(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 if (reachableStatements.containsKey(factAtStmt)) {










 log("Merging "+factAtStmt);










 context.factHandler.merge(reachableStatements.get(factAtStmt).getFact().getFact(), factAtStmt.getFact().getFact());










 } else {










 log("Edge to "+factAtStmt);










 reachableStatements.put(factAtStmt, factAtStmt);










 context.scheduler.schedule(new Job(factAtStmt));










 }










 }





















 void log(String message) {










 logger.trace("[{}; {}{}: "+message+"]", method, sourceFact, accessPath);










 }










 










 @Override










 public String toString() {










 return method+"; "+sourceFact+accessPath;










 }





















 void processCall(WrappedFactAtStatement<Field,Fact, Stmt, Method> factAtStmt) {










 Collection<Method> calledMethods = context.icfg.getCalleesOfCallAt(factAtStmt.getStatement());










 for (Method calledMethod : calledMethods) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeCallFlow(factAtStmt, calledMethod);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 MethodAnalyzer<Field, Fact, Stmt, Method> analyzer = context.getAnalyzer(calledMethod);










 analyzer.addIncomingEdge(new IncomingEdge<Field, Fact, Stmt, Method>(this,










 factAtStmt, targetFact.getFact()));










 }










 }










 










 processCallToReturnEdge(factAtStmt);










 }





















 void processExit(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 log("New Summary: "+factAtStmt);










 if(!summaries.add(factAtStmt))










 throw new AssertionError();





















 










 for(IncomingEdge<Field, Fact, Stmt, Method> incEdge : incomingEdges) {










 applySummary(incEdge, factAtStmt);










 }





















 if(context.followReturnsPastSeeds && isZeroSource()) {










 Collection<Stmt> callSites = context.icfg.getCallersOf(method);










 for(Stmt callSite : callSites) {










 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(callSite);










 for(Stmt returnSite : returnSites) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeUnbalancedReturnFlow(










 sourceFact, factAtStmt, method, returnSite, callSite);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(new WrappedFactAtStatement<>(returnSite, targetFact.getFact()));










 }










 }










 }










 //in cases where there are no callers, the return statement would normally not be processed at all;










 //this might be undesirable if the flow function has a side effect such as registering a taint;










 //instead we thus call the return flow function will a null caller










 if(callSites.isEmpty()) {










 context.flowProcessor.computeUnbalancedReturnFlow(










 sourceFact, factAtStmt, method, null, null);










 }










 }










 }










 










 private void scheduleEdgeTo(Collection<Stmt> successors, WrappedFact<Field, Fact, Stmt, Method> fact) {










 for (Stmt stmt : successors) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, fact));










 }










 }










 










 private void processCallToReturnEdge(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 Stmt stmt = factAtStmt.getStatement();










 int numberOfPredecessors = context.icfg.getPredsOf(stmt).size(); 










 if(numberOfPredecessors > 1 || (context.icfg.isStartPoint(stmt) && numberOfPredecessors > 0)) {










 ctrFlowJoinResolvers.getOrCreate(factAtStmt.getAsFactAtStatement()).addIncoming(factAtStmt.getFact());










 }










 else {










 processNonJoiningCallToReturnFlow(factAtStmt);










 }










 }





















 private void processNonJoiningCallToReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(factAtStmt.getStatement());










 for(Stmt returnSite : returnSites) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeCallToReturnFlow(factAtStmt, returnSite);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, targetFact.getFact()));










 }










 }










 }





















 private void processNormalFlow(WrappedFactAtStatement<Field,Fact, Stmt, Method> factAtStmt) {










 Stmt stmt = factAtStmt.getStatement();










 int numberOfPredecessors = context.icfg.getPredsOf(stmt).size();










 if((numberOfPredecessors > 1 && !context.icfg.isExitStmt(stmt)) || (context.icfg.isStartPoint(stmt) && numberOfPredecessors > 0)) {










 ctrFlowJoinResolvers.getOrCreate(factAtStmt.getAsFactAtStatement()).addIncoming(factAtStmt.getFact());










 }










 else {










 processNormalNonJoiningFlow(factAtStmt);










 }










 }





















 void processFlowFromJoinStmt(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 if(context.icfg.isCallStmt(factAtStmt.getStatement()))










 processNonJoiningCallToReturnFlow(factAtStmt);










 else










 processNormalNonJoiningFlow(factAtStmt);










 }










 










 private void processNormalNonJoiningFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 final List<Stmt> successors = context.icfg.getSuccsOf(factAtStmt.getStatement());










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeNormalFlow(factAtStmt);










 for (final ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 if(targetFact.getConstraint() == null)










 scheduleEdgeTo(successors, targetFact.getFact());










 else {










 targetFact.getFact().getResolver().resolve(targetFact.getConstraint(), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer,










 Resolver<Field, Fact, Stmt, Method> resolver) {










 analyzer.scheduleEdgeTo(successors, new WrappedFact<>(targetFact.getFact().getFact(), targetFact.getFact().getAccessPath(), resolver));










 }





















 @Override










 public void canBeResolvedEmpty() {










 callEdgeResolver.resolve(targetFact.getConstraint(), this);










 }










 });










 }










 }










 }










 










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> getOrCreateNestedAnalyzer(AccessPath<Field> newAccPath) {










 if(newAccPath.equals(accessPath) || isZeroSource())










 return this;










 










 if(!nestedAnalyzers.containsKey(newAccPath)) {










 










 if(token)










 throw new AssertionError();










 










 assert accessPath.getDeltaTo(newAccPath).accesses.length <= 1;










 










 final PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> nestedAnalyzer = new PerAccessPathMethodAnalyzer<>(method, sourceFact, context, newAccPath, this);










 nestedAnalyzers.put(newAccPath, nestedAnalyzer);










 for(IncomingEdge<Field, Fact, Stmt, Method> incEdge : incomingEdges) {










 if(newAccPath.isPrefixOf(incEdge.getCalleeSourceFact().getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX)










 nestedAnalyzer.addIncomingEdge(incEdge);










 else if(incEdge.getCalleeSourceFact().getAccessPath().isPrefixOf(newAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX))










 incEdge.registerInterestCallback(nestedAnalyzer);










 }










 }










 return nestedAnalyzers.get(newAccPath);










 }










 










 boolean token;










 boolean recursiveLock;










 










 boolean isLocked() {










 if(recursiveLock)










 return true;










 if(parent == null)










 return false;










 return parent.isLocked();










 }










 










 public void addIncomingEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 if(accessPath.isPrefixOf(incEdge.getCalleeSourceFact().getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Edge: "+incEdge);










 if(!incomingEdges.add(incEdge))










 return;










 










 callEdgeResolver.interest(this, callEdgeResolver);










 










 applySummaries(incEdge);










 token=true;










 for(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> nestedAnalyzer : nestedAnalyzers.values())










 nestedAnalyzer.addIncomingEdge(incEdge);










 token=false;










 }










 else if(incEdge.getCalleeSourceFact().getAccessPath().isPrefixOf(accessPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 recursiveLock = true;










 incEdge.registerInterestCallback(this);










 recursiveLock = false;










 }










 }





















 private void applySummary(IncomingEdge<Field, Fact, Stmt, Method> incEdge, WrappedFactAtStatement<Field, Fact, Stmt, Method> exitFact) {










 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(incEdge.getCallSite());










 for(Stmt returnSite : returnSites) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeReturnFlow(context.factHandler, exitFact, method, returnSite, incEdge);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 scheduleReturnEdge(incEdge, targetFact.getFact(), returnSite);










 }










 }










 }





















 void scheduleUnbalancedReturnEdgeTo(WrappedFactAtStatement<Field, Fact, Stmt, Method> fact) {










 ReturnSiteResolver<Field,Fact,Stmt,Method> resolver = returnSiteResolvers.getOrCreate(fact.getAsFactAtStatement());










 resolver.addIncoming(new WrappedFact<>(fact.getFact().getFact(), fact.getFact().getAccessPath(), 










 fact.getFact().getResolver()), null, Delta.<Field>empty());










 }










 










 private void scheduleReturnEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge, WrappedFact<Field, Fact, Stmt, Method> fact, Stmt returnSite) {










 Delta<Field> delta = accessPath.getDeltaTo(incEdge.getCalleeSourceFact().getAccessPath());










 ReturnSiteResolver<Field, Fact, Stmt, Method> returnSiteResolver = incEdge.getCallerAnalyzer().returnSiteResolvers.getOrCreate(










 new FactAtStatement<Fact, Stmt>(fact.getFact(), returnSite));










 returnSiteResolver.addIncoming(fact, incEdge.getCalleeSourceFact().getResolver(), delta);










 }





















 private void applySummaries(IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 for(WrappedFactAtStatement<Field, Fact, Stmt, Method> summary : summaries) {










 applySummary(incEdge, summary);










 }










 }










 










 public boolean isZeroSource() {










 return sourceFact.equals(context.zeroValue);










 }





















 private class Job implements Runnable {





















 private WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt;





















 public Job(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 this.factAtStmt = factAtStmt;










 }





















 @Override










 public void run() {










 if (context.icfg.isCallStmt(factAtStmt.getStatement())) {










 processCall(factAtStmt);










 } else {










 if (context.icfg.isExitStmt(factAtStmt.getStatement())) {










 processExit(factAtStmt);










 }










 if (!context.icfg.getSuccsOf(factAtStmt.getStatement()).isEmpty()) {










 processNormalFlow(factAtStmt);










 }










 }










 }










 }





















 public CallEdgeResolver<Field, Fact, Stmt, Method> getCallEdgeResolver() {










 return callEdgeResolver;










 }










 










 public void debugInterest() {










 JsonDocument root = new JsonDocument();










 










 List<PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> worklist = Lists.newLinkedList();










 worklist.add(this);










 Set<PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> visited = Sets.newHashSet();










 










 while(!worklist.isEmpty()) {










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> current = worklist.remove(0);










 if(!visited.add(current))










 continue;










 










 JsonDocument currentMethodDoc = root.doc(current.method.toString()+ "___"+current.sourceFact);










 JsonDocument currentDoc = currentMethodDoc.doc("accPath").doc("_"+current.accessPath.toString());










 










 for(IncomingEdge<Field, Fact, Stmt, Method> incEdge : current.incomingEdges) {










 currentDoc.doc("incoming").doc(incEdge.getCallerAnalyzer().method+"___"+incEdge.getCallerAnalyzer().sourceFact).doc("_"+incEdge.getCallerAnalyzer().accessPath.toString());










 worklist.add(incEdge.getCallerAnalyzer());










 }










 }










 










 try {










 FileWriter writer = new FileWriter("debug/incoming.json");










 StringBuilder builder = new StringBuilder();










 builder.append("var root=");










 root.write(builder, 0);










 writer.write(builder.toString());










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }










 










 public void debugNestings() {










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> current = this;










 while(current.parent != null)










 current = current.parent;










 










 JsonDocument root = new JsonDocument();










 debugNestings(current, root);










 










 try {










 FileWriter writer = new FileWriter("debug/nestings.json");










 StringBuilder builder = new StringBuilder();










 builder.append("var root=");










 root.write(builder, 0);










 writer.write(builder.toString());










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }





















 private void debugNestings(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> current, JsonDocument parentDoc) {










 JsonDocument currentDoc = parentDoc.doc(current.accessPath.toString());










 for(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> nestedAnalyzer : current.nestedAnalyzers.values()) {










 debugNestings(nestedAnalyzer, currentDoc);










 }










 }










}














src/heros/alias/Resolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.List;










import java.util.Map;





















import com.google.common.collect.HashMultimap;










import com.google.common.collect.Lists;





















import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.Constraint;





















public abstract class Resolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private boolean interest = false;










 private List<InterestCallback<Field, Fact, Stmt, Method>> interestCallbacks = Lists.newLinkedList();










 protected PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer;










 private boolean canBeResolvedEmpty = false;










 










 public Resolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 this.analyzer = analyzer;










 }





















 public abstract void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback);










 










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 if(interest)










 return;










 










 log("Interest given");










 interest = true;










 for(InterestCallback<Field, Fact, Stmt, Method> callback : Lists.newLinkedList(interestCallbacks)) {










 callback.interest(analyzer, resolver);










 }










 










 if(canBeResolvedEmpty)










 interestCallbacks = null;










 }










 










 protected void canBeResolvedEmpty() {










 if(canBeResolvedEmpty)










 return;










 










 canBeResolvedEmpty = true;










 for(InterestCallback<Field, Fact, Stmt, Method> callback : Lists.newLinkedList(interestCallbacks)) {










 callback.canBeResolvedEmpty();










 }










 










 if(interest)










 interestCallbacks = null;










 }





















 public boolean isInterestGiven() {










 return interest;










 }





















 protected void registerCallback(InterestCallback<Field, Fact, Stmt, Method> callback) {










 if(interest) {










 callback.interest(analyzer, this);










 }










 else {










 log("Callback registered");










 interestCallbacks.add(callback);










 }





















 if(canBeResolvedEmpty)










 callback.canBeResolvedEmpty();










 }










 










 protected abstract void log(String message);










 










}














src/heros/alias/ReturnSiteResolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















import java.util.Map;










import java.util.Set;





















import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private Stmt returnSite;










 private AccessPath<Field> resolvedAccPath;










 private boolean propagated = false;










 private Set<ReturnEdge> incomingFacts;










 private Map<AccessPath<Field>, ReturnSiteResolver<Field, Fact, Stmt, Method>> nestedResolvers = Maps.newHashMap();










 private ReturnSiteResolver<Field, Fact, Stmt, Method> parent;





















 public ReturnSiteResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt returnSite) {










 this(analyzer, returnSite, new AccessPath<Field>(), null);










 }





















 private ReturnSiteResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt returnSite, AccessPath<Field> resolvedAccPath, ReturnSiteResolver<Field, Fact, Stmt, Method> parent) {










 super(analyzer);










 this.returnSite = returnSite;










 this.resolvedAccPath = resolvedAccPath;










 this.parent = parent;










 this.incomingFacts = Sets.newHashSet();










 }










 










 @Override










 public String toString() {










 return "<"+resolvedAccPath+":"+returnSite+">";










 }










 










 public AccessPath<Field> getResolvedAccessPath() {










 return resolvedAccPath;










 }










 










 public void addIncoming(final WrappedFact<Field, Fact, Stmt, Method> fact, 










 Resolver<Field, Fact, Stmt, Method> resolverAtCaller, 










 Delta<Field> callDelta) {










 










 addIncoming(new ReturnEdge(fact, resolverAtCaller, callDelta));










 }










 










 private void addIncoming(final ReturnEdge retEdge) {










 if(resolvedAccPath.isPrefixOf(retEdge.incAccessPath) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Edge "+retEdge);










 if(!incomingFacts.add(retEdge))










 return;





















 interest(analyzer, this);










 










 for(ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver : nestedResolvers.values())










 nestedResolver.addIncoming(nestedResolver.new ReturnEdge(retEdge.incFact, retEdge.incAccessPath, retEdge.incResolver, 










 retEdge.resolverAtCaller, retEdge.callDelta, retEdge.usedAccessPathOfIncResolver));





















 if(!propagated) {










 propagated=true;










 analyzer.scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, 










 new WrappedFact<>(retEdge.incFact, new AccessPath<Field>(), this)));










 }










 }










 else if(retEdge.incAccessPath.isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 log("Incoming potential prefix:  "+retEdge);










 retEdge.resolveViaDelta();










 }










 }










 










 protected void log(String message) {










 analyzer.log("Return Site "+toString()+": "+message);










 }





















 @Override










 public void resolve(Constraint<Field> constraint, final InterestCallback<Field, Fact, Stmt, Method> callback) {










 log("Resolve: "+constraint);










 if(!constraint.canBeAppliedTo(resolvedAccPath))










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);










 }










 










 private ReturnSiteResolver<Field, Fact, Stmt, Method> getOrCreateNestedResolver(AccessPath<Field> candidateAccPath) {










 if(resolvedAccPath.equals(candidateAccPath))










 return this;










 










 if(!nestedResolvers.containsKey(candidateAccPath)) {










 assert resolvedAccPath.getDeltaTo(candidateAccPath).accesses.length <= 1;










 final ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver = new ReturnSiteResolver<>(analyzer, returnSite, candidateAccPath, this);










 nestedResolver.propagated = true;










 nestedResolvers.put(candidateAccPath, nestedResolver);





















 for(ReturnSiteResolver<Field, Fact, Stmt, Method>.ReturnEdge retEdge: incomingFacts) {










 nestedResolver.addIncoming(nestedResolver.new ReturnEdge(retEdge.incFact, retEdge.incAccessPath, retEdge.incResolver, 










 retEdge.resolverAtCaller, retEdge.callDelta, retEdge.usedAccessPathOfIncResolver));










 } 










 }










 return nestedResolvers.get(candidateAccPath);










 }










 










 private class ReturnEdge {





















 final Fact incFact;










 final Resolver<Field, Fact, Stmt, Method> resolverAtCaller;










 final Delta<Field> callDelta;










 final AccessPath<Field> incAccessPath;










 final Resolver<Field, Fact, Stmt, Method> incResolver;










 final Delta<Field> usedAccessPathOfIncResolver;





















 public ReturnEdge(WrappedFact<Field, Fact, Stmt, Method> fact, Resolver<Field, Fact, Stmt, Method> resolverAtCaller,










 Delta<Field> callDelta) {










 this(fact.getFact(), fact.getAccessPath(), fact.getResolver(), resolverAtCaller, callDelta, Delta.<Field>empty());










 }










 










 private ReturnEdge(Fact incFact, AccessPath<Field> incAccessPath, Resolver<Field, Fact, Stmt, Method> incResolver, 










 Resolver<Field, Fact, Stmt, Method> resolverAtCaller, Delta<Field> callDelta, Delta<Field> usedAccessPathOfIncResolver) {










 this.incFact = incFact;










 this.incAccessPath = incAccessPath;










 this.incResolver = incResolver;










 this.resolverAtCaller = resolverAtCaller;










 this.callDelta = callDelta;










 this.usedAccessPathOfIncResolver = usedAccessPathOfIncResolver;










 }










 










 @Override










 public String toString() {










 return String.format("IncFact: %s%s, Delta: %s, IncResolver: <%s:%s>, ResolverAtCallSite: %s", incFact, incAccessPath, callDelta, usedAccessPathOfIncResolver, incResolver, resolverAtCaller);










 }










 










 public void resolveViaDelta() {










 if(incResolver == null || incResolver instanceof CallEdgeResolver) {










 resolveViaDeltaAndPotentiallyDelegateToCallSite();










 } else {










 //resolve via incoming facts resolver










 Delta<Field> delta = usedAccessPathOfIncResolver.applyTo(incAccessPath, true).getDeltaTo(resolvedAccPath);










 assert delta.accesses.length <= 1;










 incResolver.resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {





















 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, resolver, resolverAtCaller, callDelta, incAccessPath.getDeltaTo(resolvedAccPath)));










 ReturnSiteResolver.this.interest(analyzer, resolver);










 }










 










 @Override










 public void canBeResolvedEmpty() {










 resolveViaDeltaAndPotentiallyDelegateToCallSite();










 }










 });










 } 










 }





















 private void resolveViaDeltaAndPotentiallyDelegateToCallSite() {










 final AccessPath<Field> currAccPath = callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath, true), true);










 if(resolvedAccPath.isPrefixOf(currAccPath) == PrefixTestResult.GUARANTEED_PREFIX) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver));










 ReturnSiteResolver.this.interest(analyzer, ReturnSiteResolver.this);










 } else if(currAccPath.isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 resolveViaCallSiteResolver(currAccPath);










 }










 }





















 protected void resolveViaCallSiteResolver(AccessPath<Field> currAccPath) {










 if(resolverAtCaller == null || resolverAtCaller instanceof CallEdgeResolver) {










 ReturnSiteResolver.this.canBeResolvedEmpty();










 } else {










 resolverAtCaller.resolve(new DeltaConstraint<>(currAccPath.getDeltaTo(resolvedAccPath)), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, null, resolver, Delta.<Field>empty(), incAccessPath.getDeltaTo(resolvedAccPath)));










 ReturnSiteResolver.this.interest(analyzer, ReturnSiteResolver.this);










 }










 










 @Override










 public void canBeResolvedEmpty() {










 ReturnSiteResolver.this.canBeResolvedEmpty();










 }










 });










 }










 }










 }





















 public Stmt getReturnSite() {










 return returnSite;










 }










}














src/heros/alias/Scheduler.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.LinkedList;










import com.google.common.collect.Lists;





















public class Scheduler {





















 private LinkedList<Runnable> worklist = Lists.newLinkedList();










 










 public void schedule(Runnable job) {










 worklist.add(job);










 }





















 public void runAndAwaitCompletion() {










 while(!worklist.isEmpty()) {










 worklist.removeLast().run();










 }










 }





















}














src/heros/alias/TestDebugger.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.io.FileWriter;










import java.io.IOException;










import java.util.Set;





















import com.google.common.collect.Sets;





















import heros.InterproceduralCFG;










import heros.alias.TestHelper.Edge;





















public class TestDebugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 private JsonDocument root = new JsonDocument();










 private I icfg;










 










 public void writeJsonDebugFile(String filename) {










 try {










 FileWriter writer = new FileWriter(filename);










 StringBuilder builder = new StringBuilder();










 builder.append("var root=");










 root.write(builder, 0);










 writer.write(builder.toString());










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }










 










 /* (non-Javadoc)










	 * @see heros.alias.Debugger#setICFG(I)










	 */










 @Override










 public void setICFG(I icfg) {










 this.icfg = icfg;










 }





















 /* (non-Javadoc)










	 * @see heros.alias.Debugger#initialSeed(Stmt)










	 */










 @Override










 public void initialSeed(Stmt stmt) {










 stmt(stmt).keyValue("seed", "true");










 










 includeSuccessors(stmt, Sets.<Stmt> newHashSet());










 }










 










 private void includeSuccessors(Stmt stmt, Set<Stmt> visited) {










 if(!visited.add(stmt))










 return;










 










 JsonDocument doc = stmt(stmt);










 for(Stmt succ : icfg.getSuccsOf(stmt)) {










 doc.array("successors").add(succ.toString());










 stmt(succ);










 includeSuccessors(succ, visited);










 }










 










 if(icfg.isCallStmt(stmt)) {










 for(Method m : icfg.getCalleesOfCallAt(stmt)) {










 doc.doc("calls").doc(m.toString());










 for(Stmt sp : icfg.getStartPointsOf(m)) {










 stmt(sp).keyValue("startPoint", "true");










 includeSuccessors(sp, visited);










 }










 }










 for(Stmt retSite :icfg.getReturnSitesOfCallAt(stmt)) {










 doc.array("successors").add(retSite.toString());










 stmt(retSite);










 includeSuccessors(retSite, visited);










 }










 }










 if(icfg.isExitStmt(stmt)) {










 for(Stmt callSite : icfg.getCallersOf(icfg.getMethodOf(stmt))) {










 for(Stmt retSite : icfg.getReturnSitesOfCallAt(callSite)) {










 doc.doc("returns").doc(retSite.toString());










 includeSuccessors(retSite, visited);










 }










 }










 }










 }





















 protected JsonDocument stmt(Stmt stmt) {










 Method methodOf = icfg.getMethodOf(stmt);










 return root.doc("methods").doc(methodOf.toString()).doc(stmt.toString());










 }










 










 public void expectNormalFlow(Stmt unit, String expectedFlowFunctionsToString) {










 stmt(unit).keyValue("flow", expectedFlowFunctionsToString);










 }





















 public void expectCallFlow(Stmt callSite, Method destinationMethod, String expectedFlowFunctionsToString) {










 stmt(callSite).doc("calls").doc(destinationMethod.toString()).keyValue("flow", expectedFlowFunctionsToString);










 }





















 public void expectReturnFlow(Stmt exitStmt, Stmt returnSite, String expectedFlowFunctionsToString) {










 if(returnSite != null)










 stmt(exitStmt).doc("returns").doc(returnSite.toString()).keyValue("flow", expectedFlowFunctionsToString);










 }





















 static void tabs(int tabs, StringBuilder builder) {










 for(int i=0; i<tabs; i++)










 builder.append("\t");










 }





















}














src/heros/alias/Transition.java








View file @ 3398e46f






......@@ -72,14 +72,16 @@ public interface Transition<FieldRef> {









 } else {










 Set<FieldRef> otherExcludedFields = ((ExclusionPathTransition<FieldRef>) t).excludedFields;










 boolean intersection = false;










 boolean containsAll = true;










 boolean containsAll = excludedFields.containsAll(otherExcludedFields);










 boolean oppositeContainsAll = otherExcludedFields.containsAll(excludedFields);










 for(FieldRef field : excludedFields) {










 if(otherExcludedFields.contains(field))










 if(otherExcludedFields.contains(field)) {










 intersection = true;










 else










  containsAll = false;










  break;










 }










 }










 return new MatchResult<>(containsAll || !intersection, containsAll);










 boolean potentialMatch = oppositeContainsAll || !intersection || (!containsAll && !oppositeContainsAll);










 return new MatchResult<>(potentialMatch, oppositeContainsAll);










 }










 










 return new MatchResult<>(false, false);



......














test/heros/alias/Fact.java

→

src/heros/alias/WrappedFact.java








View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at



......@@ -10,87 +10,58 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;





















import java.util.ArrayList;










import java.util.Arrays;










import java.util.regex.Matcher;










import java.util.regex.Pattern;










public class WrappedFact<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method>{





















import com.google.common.base.Joiner;










import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, TestFieldRef, Fact> {





















 public final String baseValue;










 public final AccessPath<TestFieldRef> accessPath;










 private final Fact fact;










 private final AccessPath<Field> accessPath;










 private final Resolver<Field, Fact, Stmt, Method> resolver;










 










 public Fact(String name) {










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 AccessPath<TestFieldRef> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();










 baseValue = name.substring(0, firstSeparator);










 matcher.reset();










 WrappedFact(Fact fact, AccessPath<Field> accessPath, Resolver<Field, Fact, Stmt, Method> resolver) {










 assert fact != null;










 assert accessPath != null;










 assert resolver != null;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(separator.equals(".")) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(new TestFieldRef(identifier));










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 TestFieldRef[] fExcl = new TestFieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new TestFieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 }










 }










 this.fact = fact;










 this.accessPath = accessPath;










 this.resolver = resolver;










 }










 










 public Fact(String baseValue, AccessPath<TestFieldRef> accessPath) {










 this.baseValue = baseValue;










 this.accessPath = accessPath;










 public Fact getFact() {










 return fact;










 }










 










 @Override










 public String toString() {










 return "[Fact "+baseValue+(accessPath.isEmpty() ? "" : accessPath)+"]";










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta, boolean merge) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath, merge), resolver); //TODO keep resolver?










 }





















 @Override










 public String getBaseValue() {










 return baseValue;










 }





















 @Override










 public AccessPath<TestFieldRef> getAccessPath() {










 public AccessPath<Field> getAccessPath() {










 return accessPath;










 }





















 @Override










 public void addNeighbor(Fact originalAbstraction) {










 










 










 public WrappedFact<Field, Fact, Stmt, Method> applyConstraint(Constraint<Field> constraint, Fact zeroValue, boolean sourceFact) {










 if(fact.equals(zeroValue))










 return this;










 else










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath, sourceFact), resolver);










 }





















 










 @Override










 public void setCallingContext(Fact callingContext) {










 










 public String toString() {










 String result = fact.toString()+accessPath;










 if(resolver != null)










 result+=resolver.toString();










 return result;










 }





















 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((accessPath == null) ? 0 : accessPath.hashCode());










 result = prime * result + ((baseValue == null) ? 0 : baseValue.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -100,25 +71,29 @@ public class Fact implements FieldSensitiveFact<String, TestFieldRef, Fact> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof Fact))










 if (getClass() != obj.getClass())










 return false;










 Fact other = (Fact) obj;










 WrappedFact other = (WrappedFact) obj;










 if (accessPath == null) {










 if (other.accessPath != null)










 return false;










 } else if (!accessPath.equals(other.accessPath))










 return false;










 if (baseValue == null) {










 if (other.baseValue != null)










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!baseValue.equals(other.baseValue))










 } else if (!fact.equals(other.fact))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }





















 @Override










 public Fact cloneWithAccessPath(AccessPath<TestFieldRef> accessPath) {










 return new Fact(baseValue, accessPath);










 public Resolver<Field, Fact, Stmt, Method> getResolver() {










 return resolver;










 }










 










 



......














src/heros/alias/SummaryEdge.java

→

src/heros/alias/WrappedFactAtStatement.java








View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at



......@@ -10,70 +10,66 @@









 ******************************************************************************/










package heros.alias;





















public class SummaryEdge<D, N> {










public class WrappedFactAtStatement<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private D sourceFact;










 private N targetStmt;










 private D targetFact;










 private WrappedFact<Field,Fact, Stmt, Method> fact;










 private Stmt stmt;





















 public WrappedFactAtStatement(Stmt stmt, WrappedFact<Field, Fact, Stmt, Method> fact) {










 this.stmt = stmt;










 this.fact = fact;










 }





















 public WrappedFact<Field,Fact, Stmt, Method> getFact() {










 return fact;










 }





















 public Stmt getStatement() {










 return stmt;










 }










 










 public FactAtStatement<Fact, Stmt> getAsFactAtStatement() {










 return new FactAtStatement<Fact, Stmt>(fact.getFact(), stmt);










 }










 










 public SummaryEdge(D sourceFact, N targetStmt, D targetFact) {










 this.sourceFact = sourceFact;










 this.targetStmt = targetStmt;










 this.targetFact = targetFact;










 public boolean canDeltaBeApplied(AccessPath.Delta<Field> delta) {










 return delta.canBeAppliedTo(fact.getAccessPath());










 }










 










 @Override










 public String toString() {










 return "[SummaryEdge: "+sourceFact+" -> "+targetFact+" @stmt: "+targetStmt+"]";










 return fact+" @ "+stmt;










 }





















 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((sourceFact == null) ? 0 : sourceFact.hashCode());










 result = prime * result + ((targetFact == null) ? 0 : targetFact.hashCode());










 result = prime * result + ((targetStmt == null) ? 0 : targetStmt.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((stmt == null) ? 0 : stmt.hashCode());










 return result;










 }










 





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SummaryEdge))










 if (getClass() != obj.getClass())










 return false;










 SummaryEdge other = (SummaryEdge) obj;










 if (sourceFact == null) {










 if (other.sourceFact != null)










 WrappedFactAtStatement other = (WrappedFactAtStatement) obj;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!sourceFact.equals(other.sourceFact))










 } else if (!fact.equals(other.fact))










 return false;










 if (targetFact == null) {










 if (other.targetFact != null)










 if (stmt == null) {










 if (other.stmt != null)










 return false;










 } else if (!targetFact.equals(other.targetFact))










 return false;










 if (targetStmt == null) {










 if (other.targetStmt != null)










 return false;










 } else if (!targetStmt.equals(other.targetStmt))










 } else if (!stmt.equals(other.stmt))










 return false;










 return true;










 }





















 public D getSourceFact() {










 return sourceFact;










 }










 










 public D getTargetFact() {










 return targetFact;










 }










 










 public N getTargetStmt() {










 return targetStmt;










 }










 










}














src/heros/alias/ZeroCallEdgeResolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class ZeroCallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends CallEdgeResolver<Field, Fact, Stmt, Method> {





















 private ZeroHandler<Field> zeroHandler;





















 public ZeroCallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, ZeroHandler<Field> zeroHandler) {










 super(analyzer);










 this.zeroHandler = zeroHandler;










 }





















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) {










 if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(new AccessPath<Field>(), true)))










 callback.interest(analyzer, this);










 }










 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 }










}














src/heros/alias/FieldSensitiveFact.java

→

src/heros/alias/ZeroHandler.java








View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch, Johannes Späth.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch, Johannes Späth - initial API and implementation










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.solver.LinkedNode;










public interface ZeroHandler<Field extends AccessPath.FieldRef<Field>> {





















public interface FieldSensitiveFact<BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D> extends LinkedNode<D>{





















 BaseValue getBaseValue();










 










 AccessPath<FieldRef> getAccessPath();










 










 D cloneWithAccessPath(AccessPath<FieldRef> accessPath);










 










 boolean shouldGenerateAccessPath(AccessPath<Field> accPath);










}














test/heros/alias/AccessPathTest.java








View file @ 3398e46f






......@@ -19,6 +19,7 @@ import org.junit.Test;




















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.SubAccessPath.*;














......@@ -36,7 +37,7 @@ public class AccessPathTest {









 }










 return result;










 }










 





















 private static SetOfPossibleFieldAccesses<TestFieldRef> anyOf(String...fields) {










 Set<TestFieldRef> set = Sets.newHashSet();










 for(String f : fields)



......@@ -49,7 +50,7 @@ public class AccessPathTest {









 }










 










 private static AccessPath<TestFieldRef> ap(SubAccessPath<TestFieldRef>... path) {










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet(), null);










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet());










 }










 










 @Test



......@@ -64,6 +65,12 @@ public class AccessPathTest {









 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMultipleFieldsAndMerge() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(f("b", "a")));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<TestFieldRef> sut = ap(s("a"));



......@@ -190,6 +197,20 @@ public class AccessPathTest {









 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaFromSetToSet() {










 Delta<TestFieldRef> actual = ap(anyOf("a")).appendExcludedFieldReference(f("f")).getDeltaTo(ap(anyOf("a")).appendExcludedFieldReference(f("g")));










 assertArrayEquals(new SubAccessPath[] { anyOf("a") }, actual.accesses);










 assertEquals(Sets.newHashSet(f("g")), actual.exclusions);










 }










 










 @Test










 public void emptyDeltaOnEqualExclusions() {










 AccessPath<TestFieldRef> actual = ap().appendExcludedFieldReference(f("f"));










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).exclusions.equals(Sets.newHashSet(f("f"))));










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;



......@@ -227,6 +248,12 @@ public class AccessPathTest {









 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void multipleExclPrefixOfMultipleExcl() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference(f("f", "h"))));










 }










 










 @Test










 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));



......














test/heros/alias/AccessPathUtilTest.java








View file @ 3398e46f






......@@ -11,125 +11,109 @@









package heros.alias;





















import static heros.alias.AccessPath.PrefixTestResult.*;










import static heros.alias.AccessPathUtil.applyAbstractedSummary;










import static heros.alias.AccessPathUtil.isPrefixOf;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertTrue;





















import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import heros.alias.AccessPath.PrefixTestResult;





















import org.junit.Test;





















public class AccessPathUtilTest {





















 public static AccessPath<TestFieldRef> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<TestFieldRef> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(new TestFieldRef(identifier));










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 TestFieldRef[] fExcl = new TestFieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new TestFieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 }










 }










 return accessPath;










 }










 










 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a"), new Fact("a.f")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a")));










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("f")));










 assertEquals(NO_PREFIX, ap("f").isPrefixOf(ap("")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a"), new Fact("a")));










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.b"), new Fact("a.b.c")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.b.c"), new Fact("a.b")));










 assertEquals(GUARANTEED_PREFIX, ap("b").isPrefixOf(ap("b.c")));










 assertEquals(NO_PREFIX, ap("b.c").isPrefixOf(ap("b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.g")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.g"), new Fact("a^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g")));










 assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a^f")));










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f,g"), new Fact("a^f,g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertEquals(POTENTIAL_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.g.g")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.f.h")));










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f,g"), new Fact("a^g")));










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f")));










 assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.g.h")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h")));










 }










 










 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a"), new Fact("a^f")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a")));










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));










 










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a.f^g^h")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 }










 










 @Test










 public void testAbstractedSummary() {










 assertEquals(new Fact("z.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h")));










 assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f")));










 }










 










 @Test










 public void testAbstractedFieldAccessSummary() {










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryIntroducesFieldAccess() {










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.c"), new SummaryEdge<>(new Fact("a"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryRemovesFieldAccess() {










 assertEquals(new Fact("z.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testNonAbstractedSummary() {










 assertEquals(new Fact("z"), applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testSummaryWithExcludedField() {










 assertEquals(new Fact("a.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testIdentityForExclusions() {










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a"))).get());










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).get());










 }










 










 @Test










 public void testMergeExclusions() {










 assertEquals(new Fact("a^f,g"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testNullOnImpossibleSubsumption() {










 assertFalse(applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).isPresent());










 }










}














test/heros/alias/ControlFlowJoinResolverTest.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;





















import org.junit.Before;










import org.junit.Test;










import org.mockito.ArgumentMatcher;










import org.mockito.Mockito;










import org.mockito.invocation.InvocationOnMock;










import org.mockito.stubbing.Answer;










import org.mockito.verification.VerificationMode;





















public class ControlFlowJoinResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement joinStmt;










 private ControlFlowJoinResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 joinStmt = new TestStatement("joinStmt");










 sut = new ControlFlowJoinResolver<>(analyzer, joinStmt);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);










 }





















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver));










 verify(analyzer).processFlowFromJoinStmt(eq(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver));










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));










 }










 










 










 private class ResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;





















 public ResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 this.accPath = accPath;










 }





















 @Override










 public boolean matches(Object argument) {










 ControlFlowJoinResolver resolver = (ControlFlowJoinResolver) argument;










 return resolver.isInterestGiven() && resolver.getResolvedAccessPath().equals(accPath) && resolver.getJoinStmt().equals(joinStmt);










 }










 }










}














test/heros/alias/EdgeBuilder.java








View file @ 3398e46f






......@@ -32,43 +32,44 @@ public abstract class EdgeBuilder {




















 public static class CallSiteBuilder extends EdgeBuilder {





















 private Statement callSite;










 private TestStatement callSite;





















 public CallSiteBuilder(Statement callSite) {










 public CallSiteBuilder(TestStatement callSite) {










 this.callSite = callSite;










 }





















 public CallSiteBuilder calls(String method, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.CallEdge(callSite, new Method(method), flows));










 edges.add(new TestHelper.CallEdge(callSite, new TestMethod(method), flows));










 return this;










 }










 










 public CallSiteBuilder retSite(String returnSite, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new Statement(returnSite), flows));










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new TestStatement(returnSite), flows));










 return this;










 }










 }










 










 public static class NormalStmtBuilder extends EdgeBuilder {





















 private Statement stmt;










 private TestStatement stmt;










 private ExpectedFlowFunction[] flowFunctions;





















 public NormalStmtBuilder(Statement stmt) {










 public NormalStmtBuilder(TestStatement stmt, ExpectedFlowFunction[] flowFunctions) {










 this.stmt = stmt;










 this.flowFunctions = flowFunctions;










 }





















 public NormalStmtBuilder succ(String succ, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.NormalEdge(stmt, new Statement(succ), flows));










 public NormalStmtBuilder succ(String succ) {










 edges.add(new TestHelper.NormalEdge(stmt, new TestStatement(succ), flowFunctions));










 return this;










 }










 










 }










 










 public static class ExitStmtBuilder extends EdgeBuilder {





















 private Statement exitStmt;










 private TestStatement exitStmt;





















 public ExitStmtBuilder(Statement exitStmt) {










 public ExitStmtBuilder(TestStatement exitStmt) {










 this.exitStmt = exitStmt;










 }










 



......@@ -77,7 +78,7 @@ public abstract class EdgeBuilder {









 return this;










 }





















 public ExitStmtBuilder returns(Statement callSite, Statement returnSite, ExpectedFlowFunction... flows) {










 public ExitStmtBuilder returns(TestStatement callSite, TestStatement returnSite, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.ReturnEdge(callSite, exitStmt, returnSite, flows));










 return this;










 }



......














test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ 3398e46f





This diff is collapsed.
Click to expand it.













test/heros/alias/ReturnSiteResolverTest.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;





















import org.junit.Before;










import org.junit.Test;










import org.mockito.ArgumentMatcher;










import org.mockito.Mockito;










import org.mockito.invocation.InvocationOnMock;










import org.mockito.stubbing.Answer;










import org.mockito.verification.VerificationMode;





















public class ReturnSiteResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement returnSite;










 private ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 returnSite = new TestStatement("returnSite");










 sut = new ReturnSiteResolver<>(analyzer, returnSite);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);










 }





















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 verify(analyzer).scheduleEdgeTo(eq(new WrappedFactAtStatement<>(returnSite, new WrappedFact<>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver), callEdgeResolver, getDelta());










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }










 










 @Test










 public void resolveViaDelta() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }










 










 @Test










 public void resolveViaDeltaTwice() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a", "b"));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(innerCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));










 }










 










 @Test










 public void resolveViaDeltaAndThenViaCallSite() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(innerCallback).canBeResolvedEmpty();










 }





















 @Test










 public void resolveViaCallEdgeResolverAtCallSite() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).canBeResolvedEmpty();










 }










 










 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 @Test










 public void resolveViaResolverAtCallSiteTwice() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback innerCallback = (InterestCallback) invocation.getArguments()[1];










 innerCallback.interest(analyzer, nestedResolver);










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback innerCallback = (InterestCallback) invocation.getArguments()[1];










 innerCallback.interest(analyzer, nestedResolver);










 return null;










 }










 }).when(nestedResolver).resolve(eq(getDeltaConstraint("b")), any(InterestCallback.class));










 










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), secondCallback);










 return null;










 }










 










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(secondCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));










 }










 










 @Test










 public void resolveAsEmptyViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Delta<TestFieldRef> delta = new AccessPath<TestFieldRef>().getDeltaTo(new AccessPath<TestFieldRef>().appendExcludedFieldReference(new TestFieldRef("a")));










 










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback innerCallback = (InterestCallback) invocation.getArguments()[1];










 innerCallback.canBeResolvedEmpty();










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));





















 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, delta);










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback, never()).canBeResolvedEmpty();










 verify(callback, never()).interest(any(PerAccessPathMethodAnalyzer.class), any(Resolver.class));










 }










 










 @Test










 public void resolveViaCallSiteResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 private class ReturnSiteResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;





















 public ReturnSiteResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 this.accPath = accPath;










 }





















 @Override










 public boolean matches(Object argument) {










 ReturnSiteResolver resolver = (ReturnSiteResolver) argument;










 return resolver.isInterestGiven() && resolver.getResolvedAccessPath().equals(accPath) && resolver.getReturnSite().equals(returnSite);










 }










 }










}









Prev


1


2


3


Next













src/heros/alias/InterestCallback.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public interface InterestCallback<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver);










 










//	void partiallyResolved(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver, AccessPath<Field> resolvedAccPath);










 










 void canBeResolvedEmpty();










}












src/heros/alias/InterestCallback.java



0 → 100644







View file @ 3398e46f








src/heros/alias/InterestCallback.java



0 → 100644









View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public interface InterestCallback<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver);










 










//	void partiallyResolved(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver, AccessPath<Field> resolvedAccPath);










 










 void canBeResolvedEmpty();










}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public interface InterestCallback<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver);










 










//	void partiallyResolved(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver, AccessPath<Field> resolvedAccPath);










 










 void canBeResolvedEmpty();










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.alias.AccessPath.Delta;importheros.alias.AccessPath.Delta;import heros.alias.FlowFunction.Constraint;importheros.alias.FlowFunction.Constraint;public interface InterestCallback<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {publicinterfaceInterestCallback<FieldextendsAccessPath.FieldRef<Field>,Fact,Stmt,Method>{ void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver);voidinterest(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer,Resolver<Field,Fact,Stmt,Method>resolver); //	void partiallyResolved(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver, AccessPath<Field> resolvedAccPath);//	void partiallyResolved(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver, AccessPath<Field> resolvedAccPath);  void canBeResolvedEmpty();voidcanBeResolvedEmpty();}}








src/heros/alias/JsonArray.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.List;





















import com.google.common.collect.Lists;





















class JsonArray {










 










 private List<String> items = Lists.newLinkedList();










 










 public void add(String item) {










 items.add(item);










 }





















 public void write(StringBuilder builder, int tabs) {










 builder.append("[\n");










 for(String item: items) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+item+"\",\n");










 }










 TestDebugger.tabs(tabs, builder); builder.append("]");










 }










}




\ No newline at end of file












src/heros/alias/JsonArray.java



0 → 100644







View file @ 3398e46f








src/heros/alias/JsonArray.java



0 → 100644









View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.List;





















import com.google.common.collect.Lists;





















class JsonArray {










 










 private List<String> items = Lists.newLinkedList();










 










 public void add(String item) {










 items.add(item);










 }





















 public void write(StringBuilder builder, int tabs) {










 builder.append("[\n");










 for(String item: items) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+item+"\",\n");










 }










 TestDebugger.tabs(tabs, builder); builder.append("]");










 }










}




\ No newline at end of file













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.List;





















import com.google.common.collect.Lists;





















class JsonArray {










 










 private List<String> items = Lists.newLinkedList();










 










 public void add(String item) {










 items.add(item);










 }





















 public void write(StringBuilder builder, int tabs) {










 builder.append("[\n");










 for(String item: items) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+item+"\",\n");










 }










 TestDebugger.tabs(tabs, builder); builder.append("]");










 }










}




\ No newline at end of file


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import java.util.List;importjava.util.List;import com.google.common.collect.Lists;importcom.google.common.collect.Lists;class JsonArray {classJsonArray{  private List<String> items = Lists.newLinkedList();privateList<String>items=Lists.newLinkedList();  public void add(String item) {publicvoidadd(Stringitem){ items.add(item);items.add(item); }} public void write(StringBuilder builder, int tabs) {publicvoidwrite(StringBuilderbuilder,inttabs){ builder.append("[\n");builder.append("[\n"); for(String item: items) {for(Stringitem:items){ TestDebugger.tabs(tabs+1, builder); builder.append("\""+item+"\",\n");TestDebugger.tabs(tabs+1,builder);builder.append("\""+item+"\",\n"); }} TestDebugger.tabs(tabs, builder); builder.append("]");TestDebugger.tabs(tabs,builder);builder.append("]"); }}}}








src/heros/alias/JsonDocument.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Map;










import java.util.Map.Entry;





















import com.google.common.collect.Maps;





















class JsonDocument {










 










 private CacheMap<String, JsonDocument> documents = new CacheMap<String, JsonDocument>() {










 @Override










 protected JsonDocument createItem(String key) {










 return new JsonDocument();










 }










 };










 private CacheMap<String, JsonArray> arrays = new CacheMap<String, JsonArray>() {










 @Override










 protected JsonArray createItem(String key) {










 return new JsonArray();










 }










 };










 private Map<String, String> keyValuePairs = Maps.newHashMap();










 










 public JsonDocument doc(String key) {










 return documents.getOrCreate(key);










 }










 










 public JsonArray array(String key) {










 return arrays.getOrCreate(key);










 }










 










 public void keyValue(String key, String value) {










 keyValuePairs.put(key, value);










 }










 










 public void write(StringBuilder builder, int tabs) {










 builder.append("{\n");










 










 for(Entry<String, String> entry : keyValuePairs.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n");










 }










 










 for(Entry<String, JsonArray> entry : arrays.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");





















 }










 










 for(Entry<String, JsonDocument> entry : documents.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");










 }










 










 TestDebugger.tabs(tabs, builder); builder.append("}");










 }





















}




\ No newline at end of file












src/heros/alias/JsonDocument.java



0 → 100644







View file @ 3398e46f








src/heros/alias/JsonDocument.java



0 → 100644









View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Map;










import java.util.Map.Entry;





















import com.google.common.collect.Maps;





















class JsonDocument {










 










 private CacheMap<String, JsonDocument> documents = new CacheMap<String, JsonDocument>() {










 @Override










 protected JsonDocument createItem(String key) {










 return new JsonDocument();










 }










 };










 private CacheMap<String, JsonArray> arrays = new CacheMap<String, JsonArray>() {










 @Override










 protected JsonArray createItem(String key) {










 return new JsonArray();










 }










 };










 private Map<String, String> keyValuePairs = Maps.newHashMap();










 










 public JsonDocument doc(String key) {










 return documents.getOrCreate(key);










 }










 










 public JsonArray array(String key) {










 return arrays.getOrCreate(key);










 }










 










 public void keyValue(String key, String value) {










 keyValuePairs.put(key, value);










 }










 










 public void write(StringBuilder builder, int tabs) {










 builder.append("{\n");










 










 for(Entry<String, String> entry : keyValuePairs.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n");










 }










 










 for(Entry<String, JsonArray> entry : arrays.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");





















 }










 










 for(Entry<String, JsonDocument> entry : documents.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");










 }










 










 TestDebugger.tabs(tabs, builder); builder.append("}");










 }





















}




\ No newline at end of file













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.Map;










import java.util.Map.Entry;





















import com.google.common.collect.Maps;





















class JsonDocument {










 










 private CacheMap<String, JsonDocument> documents = new CacheMap<String, JsonDocument>() {










 @Override










 protected JsonDocument createItem(String key) {










 return new JsonDocument();










 }










 };










 private CacheMap<String, JsonArray> arrays = new CacheMap<String, JsonArray>() {










 @Override










 protected JsonArray createItem(String key) {










 return new JsonArray();










 }










 };










 private Map<String, String> keyValuePairs = Maps.newHashMap();










 










 public JsonDocument doc(String key) {










 return documents.getOrCreate(key);










 }










 










 public JsonArray array(String key) {










 return arrays.getOrCreate(key);










 }










 










 public void keyValue(String key, String value) {










 keyValuePairs.put(key, value);










 }










 










 public void write(StringBuilder builder, int tabs) {










 builder.append("{\n");










 










 for(Entry<String, String> entry : keyValuePairs.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n");










 }










 










 for(Entry<String, JsonArray> entry : arrays.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");





















 }










 










 for(Entry<String, JsonDocument> entry : documents.entrySet()) {










 TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");










 entry.getValue().write(builder, tabs+1);










 builder.append(",\n");










 }










 










 TestDebugger.tabs(tabs, builder); builder.append("}");










 }





















}




\ No newline at end of file


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import java.util.Map;importjava.util.Map;import java.util.Map.Entry;importjava.util.Map.Entry;import com.google.common.collect.Maps;importcom.google.common.collect.Maps;class JsonDocument {classJsonDocument{  private CacheMap<String, JsonDocument> documents = new CacheMap<String, JsonDocument>() {privateCacheMap<String,JsonDocument>documents=newCacheMap<String,JsonDocument>(){ @Override@Override protected JsonDocument createItem(String key) {protectedJsonDocumentcreateItem(Stringkey){ return new JsonDocument();returnnewJsonDocument(); }} };}; private CacheMap<String, JsonArray> arrays = new CacheMap<String, JsonArray>() {privateCacheMap<String,JsonArray>arrays=newCacheMap<String,JsonArray>(){ @Override@Override protected JsonArray createItem(String key) {protectedJsonArraycreateItem(Stringkey){ return new JsonArray();returnnewJsonArray(); }} };}; private Map<String, String> keyValuePairs = Maps.newHashMap();privateMap<String,String>keyValuePairs=Maps.newHashMap();  public JsonDocument doc(String key) {publicJsonDocumentdoc(Stringkey){ return documents.getOrCreate(key);returndocuments.getOrCreate(key); }}  public JsonArray array(String key) {publicJsonArrayarray(Stringkey){ return arrays.getOrCreate(key);returnarrays.getOrCreate(key); }}  public void keyValue(String key, String value) {publicvoidkeyValue(Stringkey,Stringvalue){ keyValuePairs.put(key, value);keyValuePairs.put(key,value); }}  public void write(StringBuilder builder, int tabs) {publicvoidwrite(StringBuilderbuilder,inttabs){ builder.append("{\n");builder.append("{\n");  for(Entry<String, String> entry : keyValuePairs.entrySet()) {for(Entry<String,String>entry:keyValuePairs.entrySet()){ TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n");TestDebugger.tabs(tabs+1,builder);builder.append("\""+entry.getKey()+"\": \""+entry.getValue()+"\",\n"); }}  for(Entry<String, JsonArray> entry : arrays.entrySet()) {for(Entry<String,JsonArray>entry:arrays.entrySet()){ TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");TestDebugger.tabs(tabs+1,builder);builder.append("\""+entry.getKey()+"\": "); entry.getValue().write(builder, tabs+1);entry.getValue().write(builder,tabs+1); builder.append(",\n");builder.append(",\n"); }}  for(Entry<String, JsonDocument> entry : documents.entrySet()) {for(Entry<String,JsonDocument>entry:documents.entrySet()){ TestDebugger.tabs(tabs+1, builder); builder.append("\""+entry.getKey()+"\": ");TestDebugger.tabs(tabs+1,builder);builder.append("\""+entry.getKey()+"\": "); entry.getValue().write(builder, tabs+1);entry.getValue().write(builder,tabs+1); builder.append(",\n");builder.append(",\n"); }}  TestDebugger.tabs(tabs, builder); builder.append("}");TestDebugger.tabs(tabs,builder);builder.append("}"); }}}}








src/heros/alias/MethodAnalyzer.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;
































public class MethodAnalyzer<Field extends AccessPath.FieldRef<Field>,










 Fact, 










 Stmt, 










 Method> {





















 private Method method;










 private CacheMap<Fact, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> perSourceAnalyzer = 










 new CacheMap<Fact, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>>() {










 @Override










 protected PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> createItem(Fact key) {










 return new PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>(method, key, context);










 }










 };










 private Context<Field, Fact, Stmt, Method> context;










 










 MethodAnalyzer(Method method, Context<Field, Fact, Stmt, Method> context) {










 this.method = method;










 this.context = context;










 }










 










 public void addIncomingEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact = incEdge.getCalleeSourceFact();










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer = perSourceAnalyzer.getOrCreate(calleeSourceFact.getFact());










 analyzer.bootstrapAtMethodStartPoints();










 analyzer.addIncomingEdge(incEdge);










 }





















 public void addInitialSeed(Stmt startPoint, Fact val) {










 perSourceAnalyzer.getOrCreate(val).addInitialSeed(startPoint);










 }










 










 public void addUnbalancedReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> target) {










 perSourceAnalyzer.getOrCreate(context.zeroValue).scheduleUnbalancedReturnEdgeTo(target);










 }










}












src/heros/alias/MethodAnalyzer.java



0 → 100644







View file @ 3398e46f








src/heros/alias/MethodAnalyzer.java



0 → 100644









View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;
































public class MethodAnalyzer<Field extends AccessPath.FieldRef<Field>,










 Fact, 










 Stmt, 










 Method> {





















 private Method method;










 private CacheMap<Fact, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> perSourceAnalyzer = 










 new CacheMap<Fact, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>>() {










 @Override










 protected PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> createItem(Fact key) {










 return new PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>(method, key, context);










 }










 };










 private Context<Field, Fact, Stmt, Method> context;










 










 MethodAnalyzer(Method method, Context<Field, Fact, Stmt, Method> context) {










 this.method = method;










 this.context = context;










 }










 










 public void addIncomingEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact = incEdge.getCalleeSourceFact();










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer = perSourceAnalyzer.getOrCreate(calleeSourceFact.getFact());










 analyzer.bootstrapAtMethodStartPoints();










 analyzer.addIncomingEdge(incEdge);










 }





















 public void addInitialSeed(Stmt startPoint, Fact val) {










 perSourceAnalyzer.getOrCreate(val).addInitialSeed(startPoint);










 }










 










 public void addUnbalancedReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> target) {










 perSourceAnalyzer.getOrCreate(context.zeroValue).scheduleUnbalancedReturnEdgeTo(target);










 }










}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;
































public class MethodAnalyzer<Field extends AccessPath.FieldRef<Field>,










 Fact, 










 Stmt, 










 Method> {





















 private Method method;










 private CacheMap<Fact, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> perSourceAnalyzer = 










 new CacheMap<Fact, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>>() {










 @Override










 protected PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> createItem(Fact key) {










 return new PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>(method, key, context);










 }










 };










 private Context<Field, Fact, Stmt, Method> context;










 










 MethodAnalyzer(Method method, Context<Field, Fact, Stmt, Method> context) {










 this.method = method;










 this.context = context;










 }










 










 public void addIncomingEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact = incEdge.getCalleeSourceFact();










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer = perSourceAnalyzer.getOrCreate(calleeSourceFact.getFact());










 analyzer.bootstrapAtMethodStartPoints();










 analyzer.addIncomingEdge(incEdge);










 }





















 public void addInitialSeed(Stmt startPoint, Fact val) {










 perSourceAnalyzer.getOrCreate(val).addInitialSeed(startPoint);










 }










 










 public void addUnbalancedReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> target) {










 perSourceAnalyzer.getOrCreate(context.zeroValue).scheduleUnbalancedReturnEdgeTo(target);










 }










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;public class MethodAnalyzer<Field extends AccessPath.FieldRef<Field>,publicclassMethodAnalyzer<FieldextendsAccessPath.FieldRef<Field>, Fact, Fact, Stmt, Stmt, Method> {Method>{ private Method method;privateMethodmethod; private CacheMap<Fact, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> perSourceAnalyzer = privateCacheMap<Fact,PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>>perSourceAnalyzer= new CacheMap<Fact, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>>() {newCacheMap<Fact,PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>>(){ @Override@Override protected PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> createItem(Fact key) {protectedPerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>createItem(Factkey){ return new PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>(method, key, context);returnnewPerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>(method,key,context); }} };}; private Context<Field, Fact, Stmt, Method> context;privateContext<Field,Fact,Stmt,Method>context;  MethodAnalyzer(Method method, Context<Field, Fact, Stmt, Method> context) {MethodAnalyzer(Methodmethod,Context<Field,Fact,Stmt,Method>context){ this.method = method;this.method=method; this.context = context;this.context=context; }}  public void addIncomingEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge) {publicvoidaddIncomingEdge(IncomingEdge<Field,Fact,Stmt,Method>incEdge){ WrappedFact<Field, Fact, Stmt, Method> calleeSourceFact = incEdge.getCalleeSourceFact();WrappedFact<Field,Fact,Stmt,Method>calleeSourceFact=incEdge.getCalleeSourceFact(); PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer = perSourceAnalyzer.getOrCreate(calleeSourceFact.getFact());PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer=perSourceAnalyzer.getOrCreate(calleeSourceFact.getFact()); analyzer.bootstrapAtMethodStartPoints();analyzer.bootstrapAtMethodStartPoints(); analyzer.addIncomingEdge(incEdge);analyzer.addIncomingEdge(incEdge); }} public void addInitialSeed(Stmt startPoint, Fact val) {publicvoidaddInitialSeed(StmtstartPoint,Factval){ perSourceAnalyzer.getOrCreate(val).addInitialSeed(startPoint);perSourceAnalyzer.getOrCreate(val).addInitialSeed(startPoint); }}  public void addUnbalancedReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> target) {publicvoidaddUnbalancedReturnFlow(WrappedFactAtStatement<Field,Fact,Stmt,Method>target){ perSourceAnalyzer.getOrCreate(context.zeroValue).scheduleUnbalancedReturnEdgeTo(target);perSourceAnalyzer.getOrCreate(context.zeroValue).scheduleUnbalancedReturnEdgeTo(target); }}}}








src/heros/alias/PerAccessPathMethodAnalyzer.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.ConstrainedFact;





















import java.io.FileWriter;










import java.io.IOException;










import java.util.Collection;










import java.util.List;










import java.util.Map;










import java.util.Set;





















import org.slf4j.Logger;










import org.slf4j.LoggerFactory;





















import com.google.common.collect.Lists;










import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class PerAccessPathMethodAnalyzer<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 protected static final Logger logger = LoggerFactory.getLogger(PerAccessPathMethodAnalyzer.class);










 private Fact sourceFact;










 private final AccessPath<Field> accessPath;










 private Map<WrappedFactAtStatement<Field,Fact, Stmt, Method>, WrappedFactAtStatement<Field,Fact, Stmt, Method>> reachableStatements = Maps.newHashMap();










 private List<WrappedFactAtStatement<Field, Fact, Stmt, Method>> summaries = Lists.newLinkedList();










 private Context<Field, Fact, Stmt, Method> context;










 private Method method;










 private Set<IncomingEdge<Field, Fact, Stmt, Method>> incomingEdges = Sets.newHashSet();










 private Map<AccessPath<Field>, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> nestedAnalyzers = Maps.newHashMap();










 private boolean bootstrapped = false;










 private CacheMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field, Fact, Stmt, Method>> returnSiteResolvers = new CacheMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ReturnSiteResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ReturnSiteResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private CacheMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> ctrFlowJoinResolvers = new CacheMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ControlFlowJoinResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ControlFlowJoinResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private CallEdgeResolver<Field, Fact, Stmt, Method> callEdgeResolver;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> parent;





















 public PerAccessPathMethodAnalyzer(Method method, Fact sourceFact, Context<Field, Fact, Stmt, Method> context) {










 this(method, sourceFact, context, new AccessPath<Field>(), null);










 }










 










 private PerAccessPathMethodAnalyzer(Method method, Fact sourceFact, Context<Field, Fact, Stmt, Method> context, AccessPath<Field> accPath, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> parent) {










 if(method == null)










 throw new IllegalArgumentException("Method must be not null");










 this.parent = parent;










 this.method = method;










 this.sourceFact = sourceFact;










 this.accessPath = accPath;










 this.context = context;










 this.callEdgeResolver = isZeroSource() ? new ZeroCallEdgeResolver<>(this, context.zeroHandler) : new CallEdgeResolver<>(this);










 log("initialized");










 }










 










 WrappedFact<Field, Fact, Stmt, Method> wrappedSource() {










 return new WrappedFact<>(sourceFact, accessPath, callEdgeResolver);










 }










 










 public AccessPath<Field> getAccessPath() {










 return accessPath;










 }










 










 public void bootstrapAtMethodStartPoints() {










 if(bootstrapped)










 return;










 










 callEdgeResolver.interest(this, callEdgeResolver);










 bootstrapped = true;










 for(Stmt startPoint : context.icfg.getStartPointsOf(method)) {










 WrappedFactAtStatement<Field, Fact, Stmt, Method> target = new WrappedFactAtStatement<>(startPoint, wrappedSource());










 if(!reachableStatements.containsKey(target))










 scheduleEdgeTo(target);










 }










 }










 










 public void addInitialSeed(Stmt stmt) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, wrappedSource()));










 }





















 void scheduleEdgeTo(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 if (reachableStatements.containsKey(factAtStmt)) {










 log("Merging "+factAtStmt);










 context.factHandler.merge(reachableStatements.get(factAtStmt).getFact().getFact(), factAtStmt.getFact().getFact());










 } else {










 log("Edge to "+factAtStmt);










 reachableStatements.put(factAtStmt, factAtStmt);










 context.scheduler.schedule(new Job(factAtStmt));










 }










 }





















 void log(String message) {










 logger.trace("[{}; {}{}: "+message+"]", method, sourceFact, accessPath);










 }










 










 @Override










 public String toString() {










 return method+"; "+sourceFact+accessPath;










 }





















 void processCall(WrappedFactAtStatement<Field,Fact, Stmt, Method> factAtStmt) {










 Collection<Method> calledMethods = context.icfg.getCalleesOfCallAt(factAtStmt.getStatement());










 for (Method calledMethod : calledMethods) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeCallFlow(factAtStmt, calledMethod);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 MethodAnalyzer<Field, Fact, Stmt, Method> analyzer = context.getAnalyzer(calledMethod);










 analyzer.addIncomingEdge(new IncomingEdge<Field, Fact, Stmt, Method>(this,










 factAtStmt, targetFact.getFact()));










 }










 }










 










 processCallToReturnEdge(factAtStmt);










 }





















 void processExit(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 log("New Summary: "+factAtStmt);










 if(!summaries.add(factAtStmt))










 throw new AssertionError();





















 










 for(IncomingEdge<Field, Fact, Stmt, Method> incEdge : incomingEdges) {










 applySummary(incEdge, factAtStmt);










 }





















 if(context.followReturnsPastSeeds && isZeroSource()) {










 Collection<Stmt> callSites = context.icfg.getCallersOf(method);










 for(Stmt callSite : callSites) {










 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(callSite);










 for(Stmt returnSite : returnSites) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeUnbalancedReturnFlow(










 sourceFact, factAtStmt, method, returnSite, callSite);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(new WrappedFactAtStatement<>(returnSite, targetFact.getFact()));










 }










 }










 }










 //in cases where there are no callers, the return statement would normally not be processed at all;










 //this might be undesirable if the flow function has a side effect such as registering a taint;










 //instead we thus call the return flow function will a null caller










 if(callSites.isEmpty()) {










 context.flowProcessor.computeUnbalancedReturnFlow(










 sourceFact, factAtStmt, method, null, null);










 }










 }










 }










 










 private void scheduleEdgeTo(Collection<Stmt> successors, WrappedFact<Field, Fact, Stmt, Method> fact) {










 for (Stmt stmt : successors) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, fact));










 }










 }










 










 private void processCallToReturnEdge(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 Stmt stmt = factAtStmt.getStatement();










 int numberOfPredecessors = context.icfg.getPredsOf(stmt).size(); 










 if(numberOfPredecessors > 1 || (context.icfg.isStartPoint(stmt) && numberOfPredecessors > 0)) {










 ctrFlowJoinResolvers.getOrCreate(factAtStmt.getAsFactAtStatement()).addIncoming(factAtStmt.getFact());










 }










 else {










 processNonJoiningCallToReturnFlow(factAtStmt);










 }










 }





















 private void processNonJoiningCallToReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(factAtStmt.getStatement());










 for(Stmt returnSite : returnSites) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeCallToReturnFlow(factAtStmt, returnSite);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, targetFact.getFact()));










 }










 }










 }





















 private void processNormalFlow(WrappedFactAtStatement<Field,Fact, Stmt, Method> factAtStmt) {










 Stmt stmt = factAtStmt.getStatement();










 int numberOfPredecessors = context.icfg.getPredsOf(stmt).size();










 if((numberOfPredecessors > 1 && !context.icfg.isExitStmt(stmt)) || (context.icfg.isStartPoint(stmt) && numberOfPredecessors > 0)) {










 ctrFlowJoinResolvers.getOrCreate(factAtStmt.getAsFactAtStatement()).addIncoming(factAtStmt.getFact());










 }










 else {










 processNormalNonJoiningFlow(factAtStmt);










 }










 }





















 void processFlowFromJoinStmt(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 if(context.icfg.isCallStmt(factAtStmt.getStatement()))










 processNonJoiningCallToReturnFlow(factAtStmt);










 else










 processNormalNonJoiningFlow(factAtStmt);










 }










 










 private void processNormalNonJoiningFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 final List<Stmt> successors = context.icfg.getSuccsOf(factAtStmt.getStatement());










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeNormalFlow(factAtStmt);










 for (final ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 if(targetFact.getConstraint() == null)










 scheduleEdgeTo(successors, targetFact.getFact());










 else {










 targetFact.getFact().getResolver().resolve(targetFact.getConstraint(), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer,










 Resolver<Field, Fact, Stmt, Method> resolver) {










 analyzer.scheduleEdgeTo(successors, new WrappedFact<>(targetFact.getFact().getFact(), targetFact.getFact().getAccessPath(), resolver));










 }





















 @Override










 public void canBeResolvedEmpty() {










 callEdgeResolver.resolve(targetFact.getConstraint(), this);










 }










 });










 }










 }










 }










 










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> getOrCreateNestedAnalyzer(AccessPath<Field> newAccPath) {










 if(newAccPath.equals(accessPath) || isZeroSource())










 return this;










 










 if(!nestedAnalyzers.containsKey(newAccPath)) {










 










 if(token)










 throw new AssertionError();










 










 assert accessPath.getDeltaTo(newAccPath).accesses.length <= 1;










 










 final PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> nestedAnalyzer = new PerAccessPathMethodAnalyzer<>(method, sourceFact, context, newAccPath, this);










 nestedAnalyzers.put(newAccPath, nestedAnalyzer);










 for(IncomingEdge<Field, Fact, Stmt, Method> incEdge : incomingEdges) {










 if(newAccPath.isPrefixOf(incEdge.getCalleeSourceFact().getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX)










 nestedAnalyzer.addIncomingEdge(incEdge);










 else if(incEdge.getCalleeSourceFact().getAccessPath().isPrefixOf(newAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX))










 incEdge.registerInterestCallback(nestedAnalyzer);










 }










 }










 return nestedAnalyzers.get(newAccPath);










 }










 










 boolean token;










 boolean recursiveLock;










 










 boolean isLocked() {










 if(recursiveLock)










 return true;










 if(parent == null)










 return false;










 return parent.isLocked();










 }










 










 public void addIncomingEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 if(accessPath.isPrefixOf(incEdge.getCalleeSourceFact().getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Edge: "+incEdge);










 if(!incomingEdges.add(incEdge))










 return;










 










 callEdgeResolver.interest(this, callEdgeResolver);










 










 applySummaries(incEdge);










 token=true;










 for(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> nestedAnalyzer : nestedAnalyzers.values())










 nestedAnalyzer.addIncomingEdge(incEdge);










 token=false;










 }










 else if(incEdge.getCalleeSourceFact().getAccessPath().isPrefixOf(accessPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 recursiveLock = true;










 incEdge.registerInterestCallback(this);










 recursiveLock = false;










 }










 }





















 private void applySummary(IncomingEdge<Field, Fact, Stmt, Method> incEdge, WrappedFactAtStatement<Field, Fact, Stmt, Method> exitFact) {










 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(incEdge.getCallSite());










 for(Stmt returnSite : returnSites) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeReturnFlow(context.factHandler, exitFact, method, returnSite, incEdge);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 scheduleReturnEdge(incEdge, targetFact.getFact(), returnSite);










 }










 }










 }





















 void scheduleUnbalancedReturnEdgeTo(WrappedFactAtStatement<Field, Fact, Stmt, Method> fact) {










 ReturnSiteResolver<Field,Fact,Stmt,Method> resolver = returnSiteResolvers.getOrCreate(fact.getAsFactAtStatement());










 resolver.addIncoming(new WrappedFact<>(fact.getFact().getFact(), fact.getFact().getAccessPath(), 










 fact.getFact().getResolver()), null, Delta.<Field>empty());










 }










 










 private void scheduleReturnEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge, WrappedFact<Field, Fact, Stmt, Method> fact, Stmt returnSite) {










 Delta<Field> delta = accessPath.getDeltaTo(incEdge.getCalleeSourceFact().getAccessPath());










 ReturnSiteResolver<Field, Fact, Stmt, Method> returnSiteResolver = incEdge.getCallerAnalyzer().returnSiteResolvers.getOrCreate(










 new FactAtStatement<Fact, Stmt>(fact.getFact(), returnSite));










 returnSiteResolver.addIncoming(fact, incEdge.getCalleeSourceFact().getResolver(), delta);










 }





















 private void applySummaries(IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 for(WrappedFactAtStatement<Field, Fact, Stmt, Method> summary : summaries) {










 applySummary(incEdge, summary);










 }










 }










 










 public boolean isZeroSource() {










 return sourceFact.equals(context.zeroValue);










 }





















 private class Job implements Runnable {





















 private WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt;





















 public Job(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 this.factAtStmt = factAtStmt;










 }





















 @Override










 public void run() {










 if (context.icfg.isCallStmt(factAtStmt.getStatement())) {










 processCall(factAtStmt);










 } else {










 if (context.icfg.isExitStmt(factAtStmt.getStatement())) {










 processExit(factAtStmt);










 }










 if (!context.icfg.getSuccsOf(factAtStmt.getStatement()).isEmpty()) {










 processNormalFlow(factAtStmt);










 }










 }










 }










 }





















 public CallEdgeResolver<Field, Fact, Stmt, Method> getCallEdgeResolver() {










 return callEdgeResolver;










 }










 










 public void debugInterest() {










 JsonDocument root = new JsonDocument();










 










 List<PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> worklist = Lists.newLinkedList();










 worklist.add(this);










 Set<PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> visited = Sets.newHashSet();










 










 while(!worklist.isEmpty()) {










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> current = worklist.remove(0);










 if(!visited.add(current))










 continue;










 










 JsonDocument currentMethodDoc = root.doc(current.method.toString()+ "___"+current.sourceFact);










 JsonDocument currentDoc = currentMethodDoc.doc("accPath").doc("_"+current.accessPath.toString());










 










 for(IncomingEdge<Field, Fact, Stmt, Method> incEdge : current.incomingEdges) {










 currentDoc.doc("incoming").doc(incEdge.getCallerAnalyzer().method+"___"+incEdge.getCallerAnalyzer().sourceFact).doc("_"+incEdge.getCallerAnalyzer().accessPath.toString());










 worklist.add(incEdge.getCallerAnalyzer());










 }










 }










 










 try {










 FileWriter writer = new FileWriter("debug/incoming.json");










 StringBuilder builder = new StringBuilder();










 builder.append("var root=");










 root.write(builder, 0);










 writer.write(builder.toString());










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }










 










 public void debugNestings() {










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> current = this;










 while(current.parent != null)










 current = current.parent;










 










 JsonDocument root = new JsonDocument();










 debugNestings(current, root);










 










 try {










 FileWriter writer = new FileWriter("debug/nestings.json");










 StringBuilder builder = new StringBuilder();










 builder.append("var root=");










 root.write(builder, 0);










 writer.write(builder.toString());










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }





















 private void debugNestings(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> current, JsonDocument parentDoc) {










 JsonDocument currentDoc = parentDoc.doc(current.accessPath.toString());










 for(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> nestedAnalyzer : current.nestedAnalyzers.values()) {










 debugNestings(nestedAnalyzer, currentDoc);










 }










 }










}












src/heros/alias/PerAccessPathMethodAnalyzer.java



0 → 100644







View file @ 3398e46f








src/heros/alias/PerAccessPathMethodAnalyzer.java



0 → 100644









View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.ConstrainedFact;





















import java.io.FileWriter;










import java.io.IOException;










import java.util.Collection;










import java.util.List;










import java.util.Map;










import java.util.Set;





















import org.slf4j.Logger;










import org.slf4j.LoggerFactory;





















import com.google.common.collect.Lists;










import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class PerAccessPathMethodAnalyzer<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 protected static final Logger logger = LoggerFactory.getLogger(PerAccessPathMethodAnalyzer.class);










 private Fact sourceFact;










 private final AccessPath<Field> accessPath;










 private Map<WrappedFactAtStatement<Field,Fact, Stmt, Method>, WrappedFactAtStatement<Field,Fact, Stmt, Method>> reachableStatements = Maps.newHashMap();










 private List<WrappedFactAtStatement<Field, Fact, Stmt, Method>> summaries = Lists.newLinkedList();










 private Context<Field, Fact, Stmt, Method> context;










 private Method method;










 private Set<IncomingEdge<Field, Fact, Stmt, Method>> incomingEdges = Sets.newHashSet();










 private Map<AccessPath<Field>, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> nestedAnalyzers = Maps.newHashMap();










 private boolean bootstrapped = false;










 private CacheMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field, Fact, Stmt, Method>> returnSiteResolvers = new CacheMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ReturnSiteResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ReturnSiteResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private CacheMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> ctrFlowJoinResolvers = new CacheMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ControlFlowJoinResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ControlFlowJoinResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private CallEdgeResolver<Field, Fact, Stmt, Method> callEdgeResolver;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> parent;





















 public PerAccessPathMethodAnalyzer(Method method, Fact sourceFact, Context<Field, Fact, Stmt, Method> context) {










 this(method, sourceFact, context, new AccessPath<Field>(), null);










 }










 










 private PerAccessPathMethodAnalyzer(Method method, Fact sourceFact, Context<Field, Fact, Stmt, Method> context, AccessPath<Field> accPath, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> parent) {










 if(method == null)










 throw new IllegalArgumentException("Method must be not null");










 this.parent = parent;










 this.method = method;










 this.sourceFact = sourceFact;










 this.accessPath = accPath;










 this.context = context;










 this.callEdgeResolver = isZeroSource() ? new ZeroCallEdgeResolver<>(this, context.zeroHandler) : new CallEdgeResolver<>(this);










 log("initialized");










 }










 










 WrappedFact<Field, Fact, Stmt, Method> wrappedSource() {










 return new WrappedFact<>(sourceFact, accessPath, callEdgeResolver);










 }










 










 public AccessPath<Field> getAccessPath() {










 return accessPath;










 }










 










 public void bootstrapAtMethodStartPoints() {










 if(bootstrapped)










 return;










 










 callEdgeResolver.interest(this, callEdgeResolver);










 bootstrapped = true;










 for(Stmt startPoint : context.icfg.getStartPointsOf(method)) {










 WrappedFactAtStatement<Field, Fact, Stmt, Method> target = new WrappedFactAtStatement<>(startPoint, wrappedSource());










 if(!reachableStatements.containsKey(target))










 scheduleEdgeTo(target);










 }










 }










 










 public void addInitialSeed(Stmt stmt) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, wrappedSource()));










 }





















 void scheduleEdgeTo(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 if (reachableStatements.containsKey(factAtStmt)) {










 log("Merging "+factAtStmt);










 context.factHandler.merge(reachableStatements.get(factAtStmt).getFact().getFact(), factAtStmt.getFact().getFact());










 } else {










 log("Edge to "+factAtStmt);










 reachableStatements.put(factAtStmt, factAtStmt);










 context.scheduler.schedule(new Job(factAtStmt));










 }










 }





















 void log(String message) {










 logger.trace("[{}; {}{}: "+message+"]", method, sourceFact, accessPath);










 }










 










 @Override










 public String toString() {










 return method+"; "+sourceFact+accessPath;










 }





















 void processCall(WrappedFactAtStatement<Field,Fact, Stmt, Method> factAtStmt) {










 Collection<Method> calledMethods = context.icfg.getCalleesOfCallAt(factAtStmt.getStatement());










 for (Method calledMethod : calledMethods) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeCallFlow(factAtStmt, calledMethod);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 MethodAnalyzer<Field, Fact, Stmt, Method> analyzer = context.getAnalyzer(calledMethod);










 analyzer.addIncomingEdge(new IncomingEdge<Field, Fact, Stmt, Method>(this,










 factAtStmt, targetFact.getFact()));










 }










 }










 










 processCallToReturnEdge(factAtStmt);










 }





















 void processExit(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 log("New Summary: "+factAtStmt);










 if(!summaries.add(factAtStmt))










 throw new AssertionError();





















 










 for(IncomingEdge<Field, Fact, Stmt, Method> incEdge : incomingEdges) {










 applySummary(incEdge, factAtStmt);










 }





















 if(context.followReturnsPastSeeds && isZeroSource()) {










 Collection<Stmt> callSites = context.icfg.getCallersOf(method);










 for(Stmt callSite : callSites) {










 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(callSite);










 for(Stmt returnSite : returnSites) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeUnbalancedReturnFlow(










 sourceFact, factAtStmt, method, returnSite, callSite);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(new WrappedFactAtStatement<>(returnSite, targetFact.getFact()));










 }










 }










 }










 //in cases where there are no callers, the return statement would normally not be processed at all;










 //this might be undesirable if the flow function has a side effect such as registering a taint;










 //instead we thus call the return flow function will a null caller










 if(callSites.isEmpty()) {










 context.flowProcessor.computeUnbalancedReturnFlow(










 sourceFact, factAtStmt, method, null, null);










 }










 }










 }










 










 private void scheduleEdgeTo(Collection<Stmt> successors, WrappedFact<Field, Fact, Stmt, Method> fact) {










 for (Stmt stmt : successors) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, fact));










 }










 }










 










 private void processCallToReturnEdge(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 Stmt stmt = factAtStmt.getStatement();










 int numberOfPredecessors = context.icfg.getPredsOf(stmt).size(); 










 if(numberOfPredecessors > 1 || (context.icfg.isStartPoint(stmt) && numberOfPredecessors > 0)) {










 ctrFlowJoinResolvers.getOrCreate(factAtStmt.getAsFactAtStatement()).addIncoming(factAtStmt.getFact());










 }










 else {










 processNonJoiningCallToReturnFlow(factAtStmt);










 }










 }





















 private void processNonJoiningCallToReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(factAtStmt.getStatement());










 for(Stmt returnSite : returnSites) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeCallToReturnFlow(factAtStmt, returnSite);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, targetFact.getFact()));










 }










 }










 }





















 private void processNormalFlow(WrappedFactAtStatement<Field,Fact, Stmt, Method> factAtStmt) {










 Stmt stmt = factAtStmt.getStatement();










 int numberOfPredecessors = context.icfg.getPredsOf(stmt).size();










 if((numberOfPredecessors > 1 && !context.icfg.isExitStmt(stmt)) || (context.icfg.isStartPoint(stmt) && numberOfPredecessors > 0)) {










 ctrFlowJoinResolvers.getOrCreate(factAtStmt.getAsFactAtStatement()).addIncoming(factAtStmt.getFact());










 }










 else {










 processNormalNonJoiningFlow(factAtStmt);










 }










 }





















 void processFlowFromJoinStmt(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 if(context.icfg.isCallStmt(factAtStmt.getStatement()))










 processNonJoiningCallToReturnFlow(factAtStmt);










 else










 processNormalNonJoiningFlow(factAtStmt);










 }










 










 private void processNormalNonJoiningFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 final List<Stmt> successors = context.icfg.getSuccsOf(factAtStmt.getStatement());










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeNormalFlow(factAtStmt);










 for (final ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 if(targetFact.getConstraint() == null)










 scheduleEdgeTo(successors, targetFact.getFact());










 else {










 targetFact.getFact().getResolver().resolve(targetFact.getConstraint(), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer,










 Resolver<Field, Fact, Stmt, Method> resolver) {










 analyzer.scheduleEdgeTo(successors, new WrappedFact<>(targetFact.getFact().getFact(), targetFact.getFact().getAccessPath(), resolver));










 }





















 @Override










 public void canBeResolvedEmpty() {










 callEdgeResolver.resolve(targetFact.getConstraint(), this);










 }










 });










 }










 }










 }










 










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> getOrCreateNestedAnalyzer(AccessPath<Field> newAccPath) {










 if(newAccPath.equals(accessPath) || isZeroSource())










 return this;










 










 if(!nestedAnalyzers.containsKey(newAccPath)) {










 










 if(token)










 throw new AssertionError();










 










 assert accessPath.getDeltaTo(newAccPath).accesses.length <= 1;










 










 final PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> nestedAnalyzer = new PerAccessPathMethodAnalyzer<>(method, sourceFact, context, newAccPath, this);










 nestedAnalyzers.put(newAccPath, nestedAnalyzer);










 for(IncomingEdge<Field, Fact, Stmt, Method> incEdge : incomingEdges) {










 if(newAccPath.isPrefixOf(incEdge.getCalleeSourceFact().getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX)










 nestedAnalyzer.addIncomingEdge(incEdge);










 else if(incEdge.getCalleeSourceFact().getAccessPath().isPrefixOf(newAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX))










 incEdge.registerInterestCallback(nestedAnalyzer);










 }










 }










 return nestedAnalyzers.get(newAccPath);










 }










 










 boolean token;










 boolean recursiveLock;










 










 boolean isLocked() {










 if(recursiveLock)










 return true;










 if(parent == null)










 return false;










 return parent.isLocked();










 }










 










 public void addIncomingEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 if(accessPath.isPrefixOf(incEdge.getCalleeSourceFact().getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Edge: "+incEdge);










 if(!incomingEdges.add(incEdge))










 return;










 










 callEdgeResolver.interest(this, callEdgeResolver);










 










 applySummaries(incEdge);










 token=true;










 for(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> nestedAnalyzer : nestedAnalyzers.values())










 nestedAnalyzer.addIncomingEdge(incEdge);










 token=false;










 }










 else if(incEdge.getCalleeSourceFact().getAccessPath().isPrefixOf(accessPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 recursiveLock = true;










 incEdge.registerInterestCallback(this);










 recursiveLock = false;










 }










 }





















 private void applySummary(IncomingEdge<Field, Fact, Stmt, Method> incEdge, WrappedFactAtStatement<Field, Fact, Stmt, Method> exitFact) {










 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(incEdge.getCallSite());










 for(Stmt returnSite : returnSites) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeReturnFlow(context.factHandler, exitFact, method, returnSite, incEdge);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 scheduleReturnEdge(incEdge, targetFact.getFact(), returnSite);










 }










 }










 }





















 void scheduleUnbalancedReturnEdgeTo(WrappedFactAtStatement<Field, Fact, Stmt, Method> fact) {










 ReturnSiteResolver<Field,Fact,Stmt,Method> resolver = returnSiteResolvers.getOrCreate(fact.getAsFactAtStatement());










 resolver.addIncoming(new WrappedFact<>(fact.getFact().getFact(), fact.getFact().getAccessPath(), 










 fact.getFact().getResolver()), null, Delta.<Field>empty());










 }










 










 private void scheduleReturnEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge, WrappedFact<Field, Fact, Stmt, Method> fact, Stmt returnSite) {










 Delta<Field> delta = accessPath.getDeltaTo(incEdge.getCalleeSourceFact().getAccessPath());










 ReturnSiteResolver<Field, Fact, Stmt, Method> returnSiteResolver = incEdge.getCallerAnalyzer().returnSiteResolvers.getOrCreate(










 new FactAtStatement<Fact, Stmt>(fact.getFact(), returnSite));










 returnSiteResolver.addIncoming(fact, incEdge.getCalleeSourceFact().getResolver(), delta);










 }





















 private void applySummaries(IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 for(WrappedFactAtStatement<Field, Fact, Stmt, Method> summary : summaries) {










 applySummary(incEdge, summary);










 }










 }










 










 public boolean isZeroSource() {










 return sourceFact.equals(context.zeroValue);










 }





















 private class Job implements Runnable {





















 private WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt;





















 public Job(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 this.factAtStmt = factAtStmt;










 }





















 @Override










 public void run() {










 if (context.icfg.isCallStmt(factAtStmt.getStatement())) {










 processCall(factAtStmt);










 } else {










 if (context.icfg.isExitStmt(factAtStmt.getStatement())) {










 processExit(factAtStmt);










 }










 if (!context.icfg.getSuccsOf(factAtStmt.getStatement()).isEmpty()) {










 processNormalFlow(factAtStmt);










 }










 }










 }










 }





















 public CallEdgeResolver<Field, Fact, Stmt, Method> getCallEdgeResolver() {










 return callEdgeResolver;










 }










 










 public void debugInterest() {










 JsonDocument root = new JsonDocument();










 










 List<PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> worklist = Lists.newLinkedList();










 worklist.add(this);










 Set<PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> visited = Sets.newHashSet();










 










 while(!worklist.isEmpty()) {










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> current = worklist.remove(0);










 if(!visited.add(current))










 continue;










 










 JsonDocument currentMethodDoc = root.doc(current.method.toString()+ "___"+current.sourceFact);










 JsonDocument currentDoc = currentMethodDoc.doc("accPath").doc("_"+current.accessPath.toString());










 










 for(IncomingEdge<Field, Fact, Stmt, Method> incEdge : current.incomingEdges) {










 currentDoc.doc("incoming").doc(incEdge.getCallerAnalyzer().method+"___"+incEdge.getCallerAnalyzer().sourceFact).doc("_"+incEdge.getCallerAnalyzer().accessPath.toString());










 worklist.add(incEdge.getCallerAnalyzer());










 }










 }










 










 try {










 FileWriter writer = new FileWriter("debug/incoming.json");










 StringBuilder builder = new StringBuilder();










 builder.append("var root=");










 root.write(builder, 0);










 writer.write(builder.toString());










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }










 










 public void debugNestings() {










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> current = this;










 while(current.parent != null)










 current = current.parent;










 










 JsonDocument root = new JsonDocument();










 debugNestings(current, root);










 










 try {










 FileWriter writer = new FileWriter("debug/nestings.json");










 StringBuilder builder = new StringBuilder();










 builder.append("var root=");










 root.write(builder, 0);










 writer.write(builder.toString());










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }





















 private void debugNestings(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> current, JsonDocument parentDoc) {










 JsonDocument currentDoc = parentDoc.doc(current.accessPath.toString());










 for(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> nestedAnalyzer : current.nestedAnalyzers.values()) {










 debugNestings(nestedAnalyzer, currentDoc);










 }










 }










}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.ConstrainedFact;





















import java.io.FileWriter;










import java.io.IOException;










import java.util.Collection;










import java.util.List;










import java.util.Map;










import java.util.Set;





















import org.slf4j.Logger;










import org.slf4j.LoggerFactory;





















import com.google.common.collect.Lists;










import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class PerAccessPathMethodAnalyzer<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 protected static final Logger logger = LoggerFactory.getLogger(PerAccessPathMethodAnalyzer.class);










 private Fact sourceFact;










 private final AccessPath<Field> accessPath;










 private Map<WrappedFactAtStatement<Field,Fact, Stmt, Method>, WrappedFactAtStatement<Field,Fact, Stmt, Method>> reachableStatements = Maps.newHashMap();










 private List<WrappedFactAtStatement<Field, Fact, Stmt, Method>> summaries = Lists.newLinkedList();










 private Context<Field, Fact, Stmt, Method> context;










 private Method method;










 private Set<IncomingEdge<Field, Fact, Stmt, Method>> incomingEdges = Sets.newHashSet();










 private Map<AccessPath<Field>, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> nestedAnalyzers = Maps.newHashMap();










 private boolean bootstrapped = false;










 private CacheMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field, Fact, Stmt, Method>> returnSiteResolvers = new CacheMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ReturnSiteResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ReturnSiteResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private CacheMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> ctrFlowJoinResolvers = new CacheMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field,Fact,Stmt,Method>>() {










 @Override










 protected ControlFlowJoinResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {










 return new ControlFlowJoinResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);










 }










 };










 private CallEdgeResolver<Field, Fact, Stmt, Method> callEdgeResolver;










 private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> parent;





















 public PerAccessPathMethodAnalyzer(Method method, Fact sourceFact, Context<Field, Fact, Stmt, Method> context) {










 this(method, sourceFact, context, new AccessPath<Field>(), null);










 }










 










 private PerAccessPathMethodAnalyzer(Method method, Fact sourceFact, Context<Field, Fact, Stmt, Method> context, AccessPath<Field> accPath, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> parent) {










 if(method == null)










 throw new IllegalArgumentException("Method must be not null");










 this.parent = parent;










 this.method = method;










 this.sourceFact = sourceFact;










 this.accessPath = accPath;










 this.context = context;










 this.callEdgeResolver = isZeroSource() ? new ZeroCallEdgeResolver<>(this, context.zeroHandler) : new CallEdgeResolver<>(this);










 log("initialized");










 }










 










 WrappedFact<Field, Fact, Stmt, Method> wrappedSource() {










 return new WrappedFact<>(sourceFact, accessPath, callEdgeResolver);










 }










 










 public AccessPath<Field> getAccessPath() {










 return accessPath;










 }










 










 public void bootstrapAtMethodStartPoints() {










 if(bootstrapped)










 return;










 










 callEdgeResolver.interest(this, callEdgeResolver);










 bootstrapped = true;










 for(Stmt startPoint : context.icfg.getStartPointsOf(method)) {










 WrappedFactAtStatement<Field, Fact, Stmt, Method> target = new WrappedFactAtStatement<>(startPoint, wrappedSource());










 if(!reachableStatements.containsKey(target))










 scheduleEdgeTo(target);










 }










 }










 










 public void addInitialSeed(Stmt stmt) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, wrappedSource()));










 }





















 void scheduleEdgeTo(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 if (reachableStatements.containsKey(factAtStmt)) {










 log("Merging "+factAtStmt);










 context.factHandler.merge(reachableStatements.get(factAtStmt).getFact().getFact(), factAtStmt.getFact().getFact());










 } else {










 log("Edge to "+factAtStmt);










 reachableStatements.put(factAtStmt, factAtStmt);










 context.scheduler.schedule(new Job(factAtStmt));










 }










 }





















 void log(String message) {










 logger.trace("[{}; {}{}: "+message+"]", method, sourceFact, accessPath);










 }










 










 @Override










 public String toString() {










 return method+"; "+sourceFact+accessPath;










 }





















 void processCall(WrappedFactAtStatement<Field,Fact, Stmt, Method> factAtStmt) {










 Collection<Method> calledMethods = context.icfg.getCalleesOfCallAt(factAtStmt.getStatement());










 for (Method calledMethod : calledMethods) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeCallFlow(factAtStmt, calledMethod);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 MethodAnalyzer<Field, Fact, Stmt, Method> analyzer = context.getAnalyzer(calledMethod);










 analyzer.addIncomingEdge(new IncomingEdge<Field, Fact, Stmt, Method>(this,










 factAtStmt, targetFact.getFact()));










 }










 }










 










 processCallToReturnEdge(factAtStmt);










 }





















 void processExit(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 log("New Summary: "+factAtStmt);










 if(!summaries.add(factAtStmt))










 throw new AssertionError();





















 










 for(IncomingEdge<Field, Fact, Stmt, Method> incEdge : incomingEdges) {










 applySummary(incEdge, factAtStmt);










 }





















 if(context.followReturnsPastSeeds && isZeroSource()) {










 Collection<Stmt> callSites = context.icfg.getCallersOf(method);










 for(Stmt callSite : callSites) {










 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(callSite);










 for(Stmt returnSite : returnSites) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeUnbalancedReturnFlow(










 sourceFact, factAtStmt, method, returnSite, callSite);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(new WrappedFactAtStatement<>(returnSite, targetFact.getFact()));










 }










 }










 }










 //in cases where there are no callers, the return statement would normally not be processed at all;










 //this might be undesirable if the flow function has a side effect such as registering a taint;










 //instead we thus call the return flow function will a null caller










 if(callSites.isEmpty()) {










 context.flowProcessor.computeUnbalancedReturnFlow(










 sourceFact, factAtStmt, method, null, null);










 }










 }










 }










 










 private void scheduleEdgeTo(Collection<Stmt> successors, WrappedFact<Field, Fact, Stmt, Method> fact) {










 for (Stmt stmt : successors) {










 scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, fact));










 }










 }










 










 private void processCallToReturnEdge(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 Stmt stmt = factAtStmt.getStatement();










 int numberOfPredecessors = context.icfg.getPredsOf(stmt).size(); 










 if(numberOfPredecessors > 1 || (context.icfg.isStartPoint(stmt) && numberOfPredecessors > 0)) {










 ctrFlowJoinResolvers.getOrCreate(factAtStmt.getAsFactAtStatement()).addIncoming(factAtStmt.getFact());










 }










 else {










 processNonJoiningCallToReturnFlow(factAtStmt);










 }










 }





















 private void processNonJoiningCallToReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(factAtStmt.getStatement());










 for(Stmt returnSite : returnSites) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeCallToReturnFlow(factAtStmt, returnSite);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, targetFact.getFact()));










 }










 }










 }





















 private void processNormalFlow(WrappedFactAtStatement<Field,Fact, Stmt, Method> factAtStmt) {










 Stmt stmt = factAtStmt.getStatement();










 int numberOfPredecessors = context.icfg.getPredsOf(stmt).size();










 if((numberOfPredecessors > 1 && !context.icfg.isExitStmt(stmt)) || (context.icfg.isStartPoint(stmt) && numberOfPredecessors > 0)) {










 ctrFlowJoinResolvers.getOrCreate(factAtStmt.getAsFactAtStatement()).addIncoming(factAtStmt.getFact());










 }










 else {










 processNormalNonJoiningFlow(factAtStmt);










 }










 }





















 void processFlowFromJoinStmt(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 if(context.icfg.isCallStmt(factAtStmt.getStatement()))










 processNonJoiningCallToReturnFlow(factAtStmt);










 else










 processNormalNonJoiningFlow(factAtStmt);










 }










 










 private void processNormalNonJoiningFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 final List<Stmt> successors = context.icfg.getSuccsOf(factAtStmt.getStatement());










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeNormalFlow(factAtStmt);










 for (final ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 if(targetFact.getConstraint() == null)










 scheduleEdgeTo(successors, targetFact.getFact());










 else {










 targetFact.getFact().getResolver().resolve(targetFact.getConstraint(), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer,










 Resolver<Field, Fact, Stmt, Method> resolver) {










 analyzer.scheduleEdgeTo(successors, new WrappedFact<>(targetFact.getFact().getFact(), targetFact.getFact().getAccessPath(), resolver));










 }





















 @Override










 public void canBeResolvedEmpty() {










 callEdgeResolver.resolve(targetFact.getConstraint(), this);










 }










 });










 }










 }










 }










 










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> getOrCreateNestedAnalyzer(AccessPath<Field> newAccPath) {










 if(newAccPath.equals(accessPath) || isZeroSource())










 return this;










 










 if(!nestedAnalyzers.containsKey(newAccPath)) {










 










 if(token)










 throw new AssertionError();










 










 assert accessPath.getDeltaTo(newAccPath).accesses.length <= 1;










 










 final PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> nestedAnalyzer = new PerAccessPathMethodAnalyzer<>(method, sourceFact, context, newAccPath, this);










 nestedAnalyzers.put(newAccPath, nestedAnalyzer);










 for(IncomingEdge<Field, Fact, Stmt, Method> incEdge : incomingEdges) {










 if(newAccPath.isPrefixOf(incEdge.getCalleeSourceFact().getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX)










 nestedAnalyzer.addIncomingEdge(incEdge);










 else if(incEdge.getCalleeSourceFact().getAccessPath().isPrefixOf(newAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX))










 incEdge.registerInterestCallback(nestedAnalyzer);










 }










 }










 return nestedAnalyzers.get(newAccPath);










 }










 










 boolean token;










 boolean recursiveLock;










 










 boolean isLocked() {










 if(recursiveLock)










 return true;










 if(parent == null)










 return false;










 return parent.isLocked();










 }










 










 public void addIncomingEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 if(accessPath.isPrefixOf(incEdge.getCalleeSourceFact().getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Edge: "+incEdge);










 if(!incomingEdges.add(incEdge))










 return;










 










 callEdgeResolver.interest(this, callEdgeResolver);










 










 applySummaries(incEdge);










 token=true;










 for(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> nestedAnalyzer : nestedAnalyzers.values())










 nestedAnalyzer.addIncomingEdge(incEdge);










 token=false;










 }










 else if(incEdge.getCalleeSourceFact().getAccessPath().isPrefixOf(accessPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 recursiveLock = true;










 incEdge.registerInterestCallback(this);










 recursiveLock = false;










 }










 }





















 private void applySummary(IncomingEdge<Field, Fact, Stmt, Method> incEdge, WrappedFactAtStatement<Field, Fact, Stmt, Method> exitFact) {










 Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(incEdge.getCallSite());










 for(Stmt returnSite : returnSites) {










 Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeReturnFlow(context.factHandler, exitFact, method, returnSite, incEdge);










 for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {










 //TODO handle constraint










 scheduleReturnEdge(incEdge, targetFact.getFact(), returnSite);










 }










 }










 }





















 void scheduleUnbalancedReturnEdgeTo(WrappedFactAtStatement<Field, Fact, Stmt, Method> fact) {










 ReturnSiteResolver<Field,Fact,Stmt,Method> resolver = returnSiteResolvers.getOrCreate(fact.getAsFactAtStatement());










 resolver.addIncoming(new WrappedFact<>(fact.getFact().getFact(), fact.getFact().getAccessPath(), 










 fact.getFact().getResolver()), null, Delta.<Field>empty());










 }










 










 private void scheduleReturnEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge, WrappedFact<Field, Fact, Stmt, Method> fact, Stmt returnSite) {










 Delta<Field> delta = accessPath.getDeltaTo(incEdge.getCalleeSourceFact().getAccessPath());










 ReturnSiteResolver<Field, Fact, Stmt, Method> returnSiteResolver = incEdge.getCallerAnalyzer().returnSiteResolvers.getOrCreate(










 new FactAtStatement<Fact, Stmt>(fact.getFact(), returnSite));










 returnSiteResolver.addIncoming(fact, incEdge.getCalleeSourceFact().getResolver(), delta);










 }





















 private void applySummaries(IncomingEdge<Field, Fact, Stmt, Method> incEdge) {










 for(WrappedFactAtStatement<Field, Fact, Stmt, Method> summary : summaries) {










 applySummary(incEdge, summary);










 }










 }










 










 public boolean isZeroSource() {










 return sourceFact.equals(context.zeroValue);










 }





















 private class Job implements Runnable {





















 private WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt;





















 public Job(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {










 this.factAtStmt = factAtStmt;










 }





















 @Override










 public void run() {










 if (context.icfg.isCallStmt(factAtStmt.getStatement())) {










 processCall(factAtStmt);










 } else {










 if (context.icfg.isExitStmt(factAtStmt.getStatement())) {










 processExit(factAtStmt);










 }










 if (!context.icfg.getSuccsOf(factAtStmt.getStatement()).isEmpty()) {










 processNormalFlow(factAtStmt);










 }










 }










 }










 }





















 public CallEdgeResolver<Field, Fact, Stmt, Method> getCallEdgeResolver() {










 return callEdgeResolver;










 }










 










 public void debugInterest() {










 JsonDocument root = new JsonDocument();










 










 List<PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> worklist = Lists.newLinkedList();










 worklist.add(this);










 Set<PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> visited = Sets.newHashSet();










 










 while(!worklist.isEmpty()) {










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> current = worklist.remove(0);










 if(!visited.add(current))










 continue;










 










 JsonDocument currentMethodDoc = root.doc(current.method.toString()+ "___"+current.sourceFact);










 JsonDocument currentDoc = currentMethodDoc.doc("accPath").doc("_"+current.accessPath.toString());










 










 for(IncomingEdge<Field, Fact, Stmt, Method> incEdge : current.incomingEdges) {










 currentDoc.doc("incoming").doc(incEdge.getCallerAnalyzer().method+"___"+incEdge.getCallerAnalyzer().sourceFact).doc("_"+incEdge.getCallerAnalyzer().accessPath.toString());










 worklist.add(incEdge.getCallerAnalyzer());










 }










 }










 










 try {










 FileWriter writer = new FileWriter("debug/incoming.json");










 StringBuilder builder = new StringBuilder();










 builder.append("var root=");










 root.write(builder, 0);










 writer.write(builder.toString());










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }










 










 public void debugNestings() {










 PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> current = this;










 while(current.parent != null)










 current = current.parent;










 










 JsonDocument root = new JsonDocument();










 debugNestings(current, root);










 










 try {










 FileWriter writer = new FileWriter("debug/nestings.json");










 StringBuilder builder = new StringBuilder();










 builder.append("var root=");










 root.write(builder, 0);










 writer.write(builder.toString());










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }





















 private void debugNestings(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> current, JsonDocument parentDoc) {










 JsonDocument currentDoc = parentDoc.doc(current.accessPath.toString());










 for(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> nestedAnalyzer : current.nestedAnalyzers.values()) {










 debugNestings(nestedAnalyzer, currentDoc);










 }










 }










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.alias.AccessPath.Delta;importheros.alias.AccessPath.Delta;import heros.alias.AccessPath.PrefixTestResult;importheros.alias.AccessPath.PrefixTestResult;import heros.alias.FlowFunction.ConstrainedFact;importheros.alias.FlowFunction.ConstrainedFact;import java.io.FileWriter;importjava.io.FileWriter;import java.io.IOException;importjava.io.IOException;import java.util.Collection;importjava.util.Collection;import java.util.List;importjava.util.List;import java.util.Map;importjava.util.Map;import java.util.Set;importjava.util.Set;import org.slf4j.Logger;importorg.slf4j.Logger;import org.slf4j.LoggerFactory;importorg.slf4j.LoggerFactory;import com.google.common.collect.Lists;importcom.google.common.collect.Lists;import com.google.common.collect.Maps;importcom.google.common.collect.Maps;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;public class PerAccessPathMethodAnalyzer<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {publicclassPerAccessPathMethodAnalyzer<FieldextendsAccessPath.FieldRef<Field>,Fact,Stmt,Method>{ protected static final Logger logger = LoggerFactory.getLogger(PerAccessPathMethodAnalyzer.class);protectedstaticfinalLoggerlogger=LoggerFactory.getLogger(PerAccessPathMethodAnalyzer.class); private Fact sourceFact;privateFactsourceFact; private final AccessPath<Field> accessPath;privatefinalAccessPath<Field>accessPath; private Map<WrappedFactAtStatement<Field,Fact, Stmt, Method>, WrappedFactAtStatement<Field,Fact, Stmt, Method>> reachableStatements = Maps.newHashMap();privateMap<WrappedFactAtStatement<Field,Fact,Stmt,Method>,WrappedFactAtStatement<Field,Fact,Stmt,Method>>reachableStatements=Maps.newHashMap(); private List<WrappedFactAtStatement<Field, Fact, Stmt, Method>> summaries = Lists.newLinkedList();privateList<WrappedFactAtStatement<Field,Fact,Stmt,Method>>summaries=Lists.newLinkedList(); private Context<Field, Fact, Stmt, Method> context;privateContext<Field,Fact,Stmt,Method>context; private Method method;privateMethodmethod; private Set<IncomingEdge<Field, Fact, Stmt, Method>> incomingEdges = Sets.newHashSet();privateSet<IncomingEdge<Field,Fact,Stmt,Method>>incomingEdges=Sets.newHashSet(); private Map<AccessPath<Field>, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> nestedAnalyzers = Maps.newHashMap();privateMap<AccessPath<Field>,PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>>nestedAnalyzers=Maps.newHashMap(); private boolean bootstrapped = false;privatebooleanbootstrapped=false; private CacheMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field, Fact, Stmt, Method>> returnSiteResolvers = new CacheMap<FactAtStatement<Fact, Stmt>, ReturnSiteResolver<Field,Fact,Stmt,Method>>() {privateCacheMap<FactAtStatement<Fact,Stmt>,ReturnSiteResolver<Field,Fact,Stmt,Method>>returnSiteResolvers=newCacheMap<FactAtStatement<Fact,Stmt>,ReturnSiteResolver<Field,Fact,Stmt,Method>>(){ @Override@Override protected ReturnSiteResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {protectedReturnSiteResolver<Field,Fact,Stmt,Method>createItem(FactAtStatement<Fact,Stmt>key){ return new ReturnSiteResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);returnnewReturnSiteResolver<>(PerAccessPathMethodAnalyzer.this,key.stmt); }} };}; private CacheMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field, Fact, Stmt, Method>> ctrFlowJoinResolvers = new CacheMap<FactAtStatement<Fact, Stmt>, ControlFlowJoinResolver<Field,Fact,Stmt,Method>>() {privateCacheMap<FactAtStatement<Fact,Stmt>,ControlFlowJoinResolver<Field,Fact,Stmt,Method>>ctrFlowJoinResolvers=newCacheMap<FactAtStatement<Fact,Stmt>,ControlFlowJoinResolver<Field,Fact,Stmt,Method>>(){ @Override@Override protected ControlFlowJoinResolver<Field, Fact, Stmt, Method> createItem(FactAtStatement<Fact, Stmt> key) {protectedControlFlowJoinResolver<Field,Fact,Stmt,Method>createItem(FactAtStatement<Fact,Stmt>key){ return new ControlFlowJoinResolver<>(PerAccessPathMethodAnalyzer.this, key.stmt);returnnewControlFlowJoinResolver<>(PerAccessPathMethodAnalyzer.this,key.stmt); }} };}; private CallEdgeResolver<Field, Fact, Stmt, Method> callEdgeResolver;privateCallEdgeResolver<Field,Fact,Stmt,Method>callEdgeResolver; private PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> parent;privatePerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>parent; public PerAccessPathMethodAnalyzer(Method method, Fact sourceFact, Context<Field, Fact, Stmt, Method> context) {publicPerAccessPathMethodAnalyzer(Methodmethod,FactsourceFact,Context<Field,Fact,Stmt,Method>context){ this(method, sourceFact, context, new AccessPath<Field>(), null);this(method,sourceFact,context,newAccessPath<Field>(),null); }}  private PerAccessPathMethodAnalyzer(Method method, Fact sourceFact, Context<Field, Fact, Stmt, Method> context, AccessPath<Field> accPath, PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> parent) {privatePerAccessPathMethodAnalyzer(Methodmethod,FactsourceFact,Context<Field,Fact,Stmt,Method>context,AccessPath<Field>accPath,PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>parent){ if(method == null)if(method==null) throw new IllegalArgumentException("Method must be not null");thrownewIllegalArgumentException("Method must be not null"); this.parent = parent;this.parent=parent; this.method = method;this.method=method; this.sourceFact = sourceFact;this.sourceFact=sourceFact; this.accessPath = accPath;this.accessPath=accPath; this.context = context;this.context=context; this.callEdgeResolver = isZeroSource() ? new ZeroCallEdgeResolver<>(this, context.zeroHandler) : new CallEdgeResolver<>(this);this.callEdgeResolver=isZeroSource()?newZeroCallEdgeResolver<>(this,context.zeroHandler):newCallEdgeResolver<>(this); log("initialized");log("initialized"); }}  WrappedFact<Field, Fact, Stmt, Method> wrappedSource() {WrappedFact<Field,Fact,Stmt,Method>wrappedSource(){ return new WrappedFact<>(sourceFact, accessPath, callEdgeResolver);returnnewWrappedFact<>(sourceFact,accessPath,callEdgeResolver); }}  public AccessPath<Field> getAccessPath() {publicAccessPath<Field>getAccessPath(){ return accessPath;returnaccessPath; }}  public void bootstrapAtMethodStartPoints() {publicvoidbootstrapAtMethodStartPoints(){ if(bootstrapped)if(bootstrapped) return;return;  callEdgeResolver.interest(this, callEdgeResolver);callEdgeResolver.interest(this,callEdgeResolver); bootstrapped = true;bootstrapped=true; for(Stmt startPoint : context.icfg.getStartPointsOf(method)) {for(StmtstartPoint:context.icfg.getStartPointsOf(method)){ WrappedFactAtStatement<Field, Fact, Stmt, Method> target = new WrappedFactAtStatement<>(startPoint, wrappedSource());WrappedFactAtStatement<Field,Fact,Stmt,Method>target=newWrappedFactAtStatement<>(startPoint,wrappedSource()); if(!reachableStatements.containsKey(target))if(!reachableStatements.containsKey(target)) scheduleEdgeTo(target);scheduleEdgeTo(target); }} }}  public void addInitialSeed(Stmt stmt) {publicvoidaddInitialSeed(Stmtstmt){ scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, wrappedSource()));scheduleEdgeTo(newWrappedFactAtStatement<>(stmt,wrappedSource())); }} void scheduleEdgeTo(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {voidscheduleEdgeTo(WrappedFactAtStatement<Field,Fact,Stmt,Method>factAtStmt){ if (reachableStatements.containsKey(factAtStmt)) {if(reachableStatements.containsKey(factAtStmt)){ log("Merging "+factAtStmt);log("Merging "+factAtStmt); context.factHandler.merge(reachableStatements.get(factAtStmt).getFact().getFact(), factAtStmt.getFact().getFact());context.factHandler.merge(reachableStatements.get(factAtStmt).getFact().getFact(),factAtStmt.getFact().getFact()); } else {}else{ log("Edge to "+factAtStmt);log("Edge to "+factAtStmt); reachableStatements.put(factAtStmt, factAtStmt);reachableStatements.put(factAtStmt,factAtStmt); context.scheduler.schedule(new Job(factAtStmt));context.scheduler.schedule(newJob(factAtStmt)); }} }} void log(String message) {voidlog(Stringmessage){ logger.trace("[{}; {}{}: "+message+"]", method, sourceFact, accessPath);logger.trace("[{}; {}{}: "+message+"]",method,sourceFact,accessPath); }}  @Override@Override public String toString() {publicStringtoString(){ return method+"; "+sourceFact+accessPath;returnmethod+"; "+sourceFact+accessPath; }} void processCall(WrappedFactAtStatement<Field,Fact, Stmt, Method> factAtStmt) {voidprocessCall(WrappedFactAtStatement<Field,Fact,Stmt,Method>factAtStmt){ Collection<Method> calledMethods = context.icfg.getCalleesOfCallAt(factAtStmt.getStatement());Collection<Method>calledMethods=context.icfg.getCalleesOfCallAt(factAtStmt.getStatement()); for (Method calledMethod : calledMethods) {for(MethodcalledMethod:calledMethods){ Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeCallFlow(factAtStmt, calledMethod);Collection<ConstrainedFact<Field,Fact,Stmt,Method>>targetFacts=context.flowProcessor.computeCallFlow(factAtStmt,calledMethod); for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {for(ConstrainedFact<Field,Fact,Stmt,Method>targetFact:targetFacts){ //TODO handle constraint//TODO handle constraint MethodAnalyzer<Field, Fact, Stmt, Method> analyzer = context.getAnalyzer(calledMethod);MethodAnalyzer<Field,Fact,Stmt,Method>analyzer=context.getAnalyzer(calledMethod); analyzer.addIncomingEdge(new IncomingEdge<Field, Fact, Stmt, Method>(this,analyzer.addIncomingEdge(newIncomingEdge<Field,Fact,Stmt,Method>(this, factAtStmt, targetFact.getFact()));factAtStmt,targetFact.getFact())); }} }}  processCallToReturnEdge(factAtStmt);processCallToReturnEdge(factAtStmt); }} void processExit(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {voidprocessExit(WrappedFactAtStatement<Field,Fact,Stmt,Method>factAtStmt){ log("New Summary: "+factAtStmt);log("New Summary: "+factAtStmt); if(!summaries.add(factAtStmt))if(!summaries.add(factAtStmt)) throw new AssertionError();thrownewAssertionError();  for(IncomingEdge<Field, Fact, Stmt, Method> incEdge : incomingEdges) {for(IncomingEdge<Field,Fact,Stmt,Method>incEdge:incomingEdges){ applySummary(incEdge, factAtStmt);applySummary(incEdge,factAtStmt); }} if(context.followReturnsPastSeeds && isZeroSource()) {if(context.followReturnsPastSeeds&&isZeroSource()){ Collection<Stmt> callSites = context.icfg.getCallersOf(method);Collection<Stmt>callSites=context.icfg.getCallersOf(method); for(Stmt callSite : callSites) {for(StmtcallSite:callSites){ Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(callSite);Collection<Stmt>returnSites=context.icfg.getReturnSitesOfCallAt(callSite); for(Stmt returnSite : returnSites) {for(StmtreturnSite:returnSites){ Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeUnbalancedReturnFlow(Collection<ConstrainedFact<Field,Fact,Stmt,Method>>targetFacts=context.flowProcessor.computeUnbalancedReturnFlow( sourceFact, factAtStmt, method, returnSite, callSite);sourceFact,factAtStmt,method,returnSite,callSite); for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {for(ConstrainedFact<Field,Fact,Stmt,Method>targetFact:targetFacts){ //TODO handle constraint//TODO handle constraint context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(new WrappedFactAtStatement<>(returnSite, targetFact.getFact()));context.getAnalyzer(context.icfg.getMethodOf(callSite)).addUnbalancedReturnFlow(newWrappedFactAtStatement<>(returnSite,targetFact.getFact())); }} }} }} //in cases where there are no callers, the return statement would normally not be processed at all;//in cases where there are no callers, the return statement would normally not be processed at all; //this might be undesirable if the flow function has a side effect such as registering a taint;//this might be undesirable if the flow function has a side effect such as registering a taint; //instead we thus call the return flow function will a null caller//instead we thus call the return flow function will a null caller if(callSites.isEmpty()) {if(callSites.isEmpty()){ context.flowProcessor.computeUnbalancedReturnFlow(context.flowProcessor.computeUnbalancedReturnFlow( sourceFact, factAtStmt, method, null, null);sourceFact,factAtStmt,method,null,null); }} }} }}  private void scheduleEdgeTo(Collection<Stmt> successors, WrappedFact<Field, Fact, Stmt, Method> fact) {privatevoidscheduleEdgeTo(Collection<Stmt>successors,WrappedFact<Field,Fact,Stmt,Method>fact){ for (Stmt stmt : successors) {for(Stmtstmt:successors){ scheduleEdgeTo(new WrappedFactAtStatement<>(stmt, fact));scheduleEdgeTo(newWrappedFactAtStatement<>(stmt,fact)); }} }}  private void processCallToReturnEdge(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {privatevoidprocessCallToReturnEdge(WrappedFactAtStatement<Field,Fact,Stmt,Method>factAtStmt){ Stmt stmt = factAtStmt.getStatement();Stmtstmt=factAtStmt.getStatement(); int numberOfPredecessors = context.icfg.getPredsOf(stmt).size(); intnumberOfPredecessors=context.icfg.getPredsOf(stmt).size(); if(numberOfPredecessors > 1 || (context.icfg.isStartPoint(stmt) && numberOfPredecessors > 0)) {if(numberOfPredecessors>1||(context.icfg.isStartPoint(stmt)&&numberOfPredecessors>0)){ ctrFlowJoinResolvers.getOrCreate(factAtStmt.getAsFactAtStatement()).addIncoming(factAtStmt.getFact());ctrFlowJoinResolvers.getOrCreate(factAtStmt.getAsFactAtStatement()).addIncoming(factAtStmt.getFact()); }} else {else{ processNonJoiningCallToReturnFlow(factAtStmt);processNonJoiningCallToReturnFlow(factAtStmt); }} }} private void processNonJoiningCallToReturnFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {privatevoidprocessNonJoiningCallToReturnFlow(WrappedFactAtStatement<Field,Fact,Stmt,Method>factAtStmt){ Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(factAtStmt.getStatement());Collection<Stmt>returnSites=context.icfg.getReturnSitesOfCallAt(factAtStmt.getStatement()); for(Stmt returnSite : returnSites) {for(StmtreturnSite:returnSites){ Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeCallToReturnFlow(factAtStmt, returnSite);Collection<ConstrainedFact<Field,Fact,Stmt,Method>>targetFacts=context.flowProcessor.computeCallToReturnFlow(factAtStmt,returnSite); for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {for(ConstrainedFact<Field,Fact,Stmt,Method>targetFact:targetFacts){ //TODO handle constraint//TODO handle constraint scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, targetFact.getFact()));scheduleEdgeTo(newWrappedFactAtStatement<Field,Fact,Stmt,Method>(returnSite,targetFact.getFact())); }} }} }} private void processNormalFlow(WrappedFactAtStatement<Field,Fact, Stmt, Method> factAtStmt) {privatevoidprocessNormalFlow(WrappedFactAtStatement<Field,Fact,Stmt,Method>factAtStmt){ Stmt stmt = factAtStmt.getStatement();Stmtstmt=factAtStmt.getStatement(); int numberOfPredecessors = context.icfg.getPredsOf(stmt).size();intnumberOfPredecessors=context.icfg.getPredsOf(stmt).size(); if((numberOfPredecessors > 1 && !context.icfg.isExitStmt(stmt)) || (context.icfg.isStartPoint(stmt) && numberOfPredecessors > 0)) {if((numberOfPredecessors>1&&!context.icfg.isExitStmt(stmt))||(context.icfg.isStartPoint(stmt)&&numberOfPredecessors>0)){ ctrFlowJoinResolvers.getOrCreate(factAtStmt.getAsFactAtStatement()).addIncoming(factAtStmt.getFact());ctrFlowJoinResolvers.getOrCreate(factAtStmt.getAsFactAtStatement()).addIncoming(factAtStmt.getFact()); }} else {else{ processNormalNonJoiningFlow(factAtStmt);processNormalNonJoiningFlow(factAtStmt); }} }} void processFlowFromJoinStmt(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {voidprocessFlowFromJoinStmt(WrappedFactAtStatement<Field,Fact,Stmt,Method>factAtStmt){ if(context.icfg.isCallStmt(factAtStmt.getStatement()))if(context.icfg.isCallStmt(factAtStmt.getStatement())) processNonJoiningCallToReturnFlow(factAtStmt);processNonJoiningCallToReturnFlow(factAtStmt); elseelse processNormalNonJoiningFlow(factAtStmt);processNormalNonJoiningFlow(factAtStmt); }}  private void processNormalNonJoiningFlow(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {privatevoidprocessNormalNonJoiningFlow(WrappedFactAtStatement<Field,Fact,Stmt,Method>factAtStmt){ final List<Stmt> successors = context.icfg.getSuccsOf(factAtStmt.getStatement());finalList<Stmt>successors=context.icfg.getSuccsOf(factAtStmt.getStatement()); Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeNormalFlow(factAtStmt);Collection<ConstrainedFact<Field,Fact,Stmt,Method>>targetFacts=context.flowProcessor.computeNormalFlow(factAtStmt); for (final ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {for(finalConstrainedFact<Field,Fact,Stmt,Method>targetFact:targetFacts){ if(targetFact.getConstraint() == null)if(targetFact.getConstraint()==null) scheduleEdgeTo(successors, targetFact.getFact());scheduleEdgeTo(successors,targetFact.getFact()); else {else{ targetFact.getFact().getResolver().resolve(targetFact.getConstraint(), new InterestCallback<Field, Fact, Stmt, Method>() {targetFact.getFact().getResolver().resolve(targetFact.getConstraint(),newInterestCallback<Field,Fact,Stmt,Method>(){ @Override@Override public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer,publicvoidinterest(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {Resolver<Field,Fact,Stmt,Method>resolver){ analyzer.scheduleEdgeTo(successors, new WrappedFact<>(targetFact.getFact().getFact(), targetFact.getFact().getAccessPath(), resolver));analyzer.scheduleEdgeTo(successors,newWrappedFact<>(targetFact.getFact().getFact(),targetFact.getFact().getAccessPath(),resolver)); }} @Override@Override public void canBeResolvedEmpty() {publicvoidcanBeResolvedEmpty(){ callEdgeResolver.resolve(targetFact.getConstraint(), this);callEdgeResolver.resolve(targetFact.getConstraint(),this); }} });}); }} }} }}  PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> getOrCreateNestedAnalyzer(AccessPath<Field> newAccPath) {PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>getOrCreateNestedAnalyzer(AccessPath<Field>newAccPath){ if(newAccPath.equals(accessPath) || isZeroSource())if(newAccPath.equals(accessPath)||isZeroSource()) return this;returnthis;  if(!nestedAnalyzers.containsKey(newAccPath)) {if(!nestedAnalyzers.containsKey(newAccPath)){  if(token)if(token) throw new AssertionError();thrownewAssertionError();  assert accessPath.getDeltaTo(newAccPath).accesses.length <= 1;assertaccessPath.getDeltaTo(newAccPath).accesses.length<=1;  final PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> nestedAnalyzer = new PerAccessPathMethodAnalyzer<>(method, sourceFact, context, newAccPath, this);finalPerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>nestedAnalyzer=newPerAccessPathMethodAnalyzer<>(method,sourceFact,context,newAccPath,this); nestedAnalyzers.put(newAccPath, nestedAnalyzer);nestedAnalyzers.put(newAccPath,nestedAnalyzer); for(IncomingEdge<Field, Fact, Stmt, Method> incEdge : incomingEdges) {for(IncomingEdge<Field,Fact,Stmt,Method>incEdge:incomingEdges){ if(newAccPath.isPrefixOf(incEdge.getCalleeSourceFact().getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX)if(newAccPath.isPrefixOf(incEdge.getCalleeSourceFact().getAccessPath())==PrefixTestResult.GUARANTEED_PREFIX) nestedAnalyzer.addIncomingEdge(incEdge);nestedAnalyzer.addIncomingEdge(incEdge); else if(incEdge.getCalleeSourceFact().getAccessPath().isPrefixOf(newAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX))elseif(incEdge.getCalleeSourceFact().getAccessPath().isPrefixOf(newAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) incEdge.registerInterestCallback(nestedAnalyzer);incEdge.registerInterestCallback(nestedAnalyzer); }} }} return nestedAnalyzers.get(newAccPath);returnnestedAnalyzers.get(newAccPath); }}  boolean token;booleantoken; boolean recursiveLock;booleanrecursiveLock;  boolean isLocked() {booleanisLocked(){ if(recursiveLock)if(recursiveLock) return true;returntrue; if(parent == null)if(parent==null) return false;returnfalse; return parent.isLocked();returnparent.isLocked(); }}  public void addIncomingEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge) {publicvoidaddIncomingEdge(IncomingEdge<Field,Fact,Stmt,Method>incEdge){ if(accessPath.isPrefixOf(incEdge.getCalleeSourceFact().getAccessPath()) == PrefixTestResult.GUARANTEED_PREFIX) {if(accessPath.isPrefixOf(incEdge.getCalleeSourceFact().getAccessPath())==PrefixTestResult.GUARANTEED_PREFIX){ log("Incoming Edge: "+incEdge);log("Incoming Edge: "+incEdge); if(!incomingEdges.add(incEdge))if(!incomingEdges.add(incEdge)) return;return;  callEdgeResolver.interest(this, callEdgeResolver);callEdgeResolver.interest(this,callEdgeResolver);  applySummaries(incEdge);applySummaries(incEdge); token=true;token=true; for(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> nestedAnalyzer : nestedAnalyzers.values())for(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>nestedAnalyzer:nestedAnalyzers.values()) nestedAnalyzer.addIncomingEdge(incEdge);nestedAnalyzer.addIncomingEdge(incEdge); token=false;token=false; }} else if(incEdge.getCalleeSourceFact().getAccessPath().isPrefixOf(accessPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {elseif(incEdge.getCalleeSourceFact().getAccessPath().isPrefixOf(accessPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)){ recursiveLock = true;recursiveLock=true; incEdge.registerInterestCallback(this);incEdge.registerInterestCallback(this); recursiveLock = false;recursiveLock=false; }} }} private void applySummary(IncomingEdge<Field, Fact, Stmt, Method> incEdge, WrappedFactAtStatement<Field, Fact, Stmt, Method> exitFact) {privatevoidapplySummary(IncomingEdge<Field,Fact,Stmt,Method>incEdge,WrappedFactAtStatement<Field,Fact,Stmt,Method>exitFact){ Collection<Stmt> returnSites = context.icfg.getReturnSitesOfCallAt(incEdge.getCallSite());Collection<Stmt>returnSites=context.icfg.getReturnSitesOfCallAt(incEdge.getCallSite()); for(Stmt returnSite : returnSites) {for(StmtreturnSite:returnSites){ Collection<ConstrainedFact<Field, Fact, Stmt, Method>> targetFacts = context.flowProcessor.computeReturnFlow(context.factHandler, exitFact, method, returnSite, incEdge);Collection<ConstrainedFact<Field,Fact,Stmt,Method>>targetFacts=context.flowProcessor.computeReturnFlow(context.factHandler,exitFact,method,returnSite,incEdge); for (ConstrainedFact<Field, Fact, Stmt, Method> targetFact : targetFacts) {for(ConstrainedFact<Field,Fact,Stmt,Method>targetFact:targetFacts){ //TODO handle constraint//TODO handle constraint scheduleReturnEdge(incEdge, targetFact.getFact(), returnSite);scheduleReturnEdge(incEdge,targetFact.getFact(),returnSite); }} }} }} void scheduleUnbalancedReturnEdgeTo(WrappedFactAtStatement<Field, Fact, Stmt, Method> fact) {voidscheduleUnbalancedReturnEdgeTo(WrappedFactAtStatement<Field,Fact,Stmt,Method>fact){ ReturnSiteResolver<Field,Fact,Stmt,Method> resolver = returnSiteResolvers.getOrCreate(fact.getAsFactAtStatement());ReturnSiteResolver<Field,Fact,Stmt,Method>resolver=returnSiteResolvers.getOrCreate(fact.getAsFactAtStatement()); resolver.addIncoming(new WrappedFact<>(fact.getFact().getFact(), fact.getFact().getAccessPath(), resolver.addIncoming(newWrappedFact<>(fact.getFact().getFact(),fact.getFact().getAccessPath(), fact.getFact().getResolver()), null, Delta.<Field>empty());fact.getFact().getResolver()),null,Delta.<Field>empty()); }}  private void scheduleReturnEdge(IncomingEdge<Field, Fact, Stmt, Method> incEdge, WrappedFact<Field, Fact, Stmt, Method> fact, Stmt returnSite) {privatevoidscheduleReturnEdge(IncomingEdge<Field,Fact,Stmt,Method>incEdge,WrappedFact<Field,Fact,Stmt,Method>fact,StmtreturnSite){ Delta<Field> delta = accessPath.getDeltaTo(incEdge.getCalleeSourceFact().getAccessPath());Delta<Field>delta=accessPath.getDeltaTo(incEdge.getCalleeSourceFact().getAccessPath()); ReturnSiteResolver<Field, Fact, Stmt, Method> returnSiteResolver = incEdge.getCallerAnalyzer().returnSiteResolvers.getOrCreate(ReturnSiteResolver<Field,Fact,Stmt,Method>returnSiteResolver=incEdge.getCallerAnalyzer().returnSiteResolvers.getOrCreate( new FactAtStatement<Fact, Stmt>(fact.getFact(), returnSite));newFactAtStatement<Fact,Stmt>(fact.getFact(),returnSite)); returnSiteResolver.addIncoming(fact, incEdge.getCalleeSourceFact().getResolver(), delta);returnSiteResolver.addIncoming(fact,incEdge.getCalleeSourceFact().getResolver(),delta); }} private void applySummaries(IncomingEdge<Field, Fact, Stmt, Method> incEdge) {privatevoidapplySummaries(IncomingEdge<Field,Fact,Stmt,Method>incEdge){ for(WrappedFactAtStatement<Field, Fact, Stmt, Method> summary : summaries) {for(WrappedFactAtStatement<Field,Fact,Stmt,Method>summary:summaries){ applySummary(incEdge, summary);applySummary(incEdge,summary); }} }}  public boolean isZeroSource() {publicbooleanisZeroSource(){ return sourceFact.equals(context.zeroValue);returnsourceFact.equals(context.zeroValue); }} private class Job implements Runnable {privateclassJobimplementsRunnable{ private WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt;privateWrappedFactAtStatement<Field,Fact,Stmt,Method>factAtStmt; public Job(WrappedFactAtStatement<Field, Fact, Stmt, Method> factAtStmt) {publicJob(WrappedFactAtStatement<Field,Fact,Stmt,Method>factAtStmt){ this.factAtStmt = factAtStmt;this.factAtStmt=factAtStmt; }} @Override@Override public void run() {publicvoidrun(){ if (context.icfg.isCallStmt(factAtStmt.getStatement())) {if(context.icfg.isCallStmt(factAtStmt.getStatement())){ processCall(factAtStmt);processCall(factAtStmt); } else {}else{ if (context.icfg.isExitStmt(factAtStmt.getStatement())) {if(context.icfg.isExitStmt(factAtStmt.getStatement())){ processExit(factAtStmt);processExit(factAtStmt); }} if (!context.icfg.getSuccsOf(factAtStmt.getStatement()).isEmpty()) {if(!context.icfg.getSuccsOf(factAtStmt.getStatement()).isEmpty()){ processNormalFlow(factAtStmt);processNormalFlow(factAtStmt); }} }} }} }} public CallEdgeResolver<Field, Fact, Stmt, Method> getCallEdgeResolver() {publicCallEdgeResolver<Field,Fact,Stmt,Method>getCallEdgeResolver(){ return callEdgeResolver;returncallEdgeResolver; }}  public void debugInterest() {publicvoiddebugInterest(){ JsonDocument root = new JsonDocument();JsonDocumentroot=newJsonDocument();  List<PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> worklist = Lists.newLinkedList();List<PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>>worklist=Lists.newLinkedList(); worklist.add(this);worklist.add(this); Set<PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method>> visited = Sets.newHashSet();Set<PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>>visited=Sets.newHashSet();  while(!worklist.isEmpty()) {while(!worklist.isEmpty()){ PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> current = worklist.remove(0);PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>current=worklist.remove(0); if(!visited.add(current))if(!visited.add(current)) continue;continue;  JsonDocument currentMethodDoc = root.doc(current.method.toString()+ "___"+current.sourceFact);JsonDocumentcurrentMethodDoc=root.doc(current.method.toString()+"___"+current.sourceFact); JsonDocument currentDoc = currentMethodDoc.doc("accPath").doc("_"+current.accessPath.toString());JsonDocumentcurrentDoc=currentMethodDoc.doc("accPath").doc("_"+current.accessPath.toString());  for(IncomingEdge<Field, Fact, Stmt, Method> incEdge : current.incomingEdges) {for(IncomingEdge<Field,Fact,Stmt,Method>incEdge:current.incomingEdges){ currentDoc.doc("incoming").doc(incEdge.getCallerAnalyzer().method+"___"+incEdge.getCallerAnalyzer().sourceFact).doc("_"+incEdge.getCallerAnalyzer().accessPath.toString());currentDoc.doc("incoming").doc(incEdge.getCallerAnalyzer().method+"___"+incEdge.getCallerAnalyzer().sourceFact).doc("_"+incEdge.getCallerAnalyzer().accessPath.toString()); worklist.add(incEdge.getCallerAnalyzer());worklist.add(incEdge.getCallerAnalyzer()); }} }}  try {try{ FileWriter writer = new FileWriter("debug/incoming.json");FileWriterwriter=newFileWriter("debug/incoming.json"); StringBuilder builder = new StringBuilder();StringBuilderbuilder=newStringBuilder(); builder.append("var root=");builder.append("var root="); root.write(builder, 0);root.write(builder,0); writer.write(builder.toString());writer.write(builder.toString()); writer.close();writer.close(); } catch (IOException e) {}catch(IOExceptione){ e.printStackTrace();e.printStackTrace(); }} }}  public void debugNestings() {publicvoiddebugNestings(){ PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> current = this;PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>current=this; while(current.parent != null)while(current.parent!=null) current = current.parent;current=current.parent;  JsonDocument root = new JsonDocument();JsonDocumentroot=newJsonDocument(); debugNestings(current, root);debugNestings(current,root);  try {try{ FileWriter writer = new FileWriter("debug/nestings.json");FileWriterwriter=newFileWriter("debug/nestings.json"); StringBuilder builder = new StringBuilder();StringBuilderbuilder=newStringBuilder(); builder.append("var root=");builder.append("var root="); root.write(builder, 0);root.write(builder,0); writer.write(builder.toString());writer.write(builder.toString()); writer.close();writer.close(); } catch (IOException e) {}catch(IOExceptione){ e.printStackTrace();e.printStackTrace(); }} }} private void debugNestings(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> current, JsonDocument parentDoc) {privatevoiddebugNestings(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>current,JsonDocumentparentDoc){ JsonDocument currentDoc = parentDoc.doc(current.accessPath.toString());JsonDocumentcurrentDoc=parentDoc.doc(current.accessPath.toString()); for(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> nestedAnalyzer : current.nestedAnalyzers.values()) {for(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>nestedAnalyzer:current.nestedAnalyzers.values()){ debugNestings(nestedAnalyzer, currentDoc);debugNestings(nestedAnalyzer,currentDoc); }} }}}}








src/heros/alias/Resolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.List;










import java.util.Map;





















import com.google.common.collect.HashMultimap;










import com.google.common.collect.Lists;





















import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.Constraint;





















public abstract class Resolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private boolean interest = false;










 private List<InterestCallback<Field, Fact, Stmt, Method>> interestCallbacks = Lists.newLinkedList();










 protected PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer;










 private boolean canBeResolvedEmpty = false;










 










 public Resolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 this.analyzer = analyzer;










 }





















 public abstract void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback);










 










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 if(interest)










 return;










 










 log("Interest given");










 interest = true;










 for(InterestCallback<Field, Fact, Stmt, Method> callback : Lists.newLinkedList(interestCallbacks)) {










 callback.interest(analyzer, resolver);










 }










 










 if(canBeResolvedEmpty)










 interestCallbacks = null;










 }










 










 protected void canBeResolvedEmpty() {










 if(canBeResolvedEmpty)










 return;










 










 canBeResolvedEmpty = true;










 for(InterestCallback<Field, Fact, Stmt, Method> callback : Lists.newLinkedList(interestCallbacks)) {










 callback.canBeResolvedEmpty();










 }










 










 if(interest)










 interestCallbacks = null;










 }





















 public boolean isInterestGiven() {










 return interest;










 }





















 protected void registerCallback(InterestCallback<Field, Fact, Stmt, Method> callback) {










 if(interest) {










 callback.interest(analyzer, this);










 }










 else {










 log("Callback registered");










 interestCallbacks.add(callback);










 }





















 if(canBeResolvedEmpty)










 callback.canBeResolvedEmpty();










 }










 










 protected abstract void log(String message);










 










}












src/heros/alias/Resolver.java



0 → 100644







View file @ 3398e46f








src/heros/alias/Resolver.java



0 → 100644









View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.List;










import java.util.Map;





















import com.google.common.collect.HashMultimap;










import com.google.common.collect.Lists;





















import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.Constraint;





















public abstract class Resolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private boolean interest = false;










 private List<InterestCallback<Field, Fact, Stmt, Method>> interestCallbacks = Lists.newLinkedList();










 protected PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer;










 private boolean canBeResolvedEmpty = false;










 










 public Resolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 this.analyzer = analyzer;










 }





















 public abstract void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback);










 










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 if(interest)










 return;










 










 log("Interest given");










 interest = true;










 for(InterestCallback<Field, Fact, Stmt, Method> callback : Lists.newLinkedList(interestCallbacks)) {










 callback.interest(analyzer, resolver);










 }










 










 if(canBeResolvedEmpty)










 interestCallbacks = null;










 }










 










 protected void canBeResolvedEmpty() {










 if(canBeResolvedEmpty)










 return;










 










 canBeResolvedEmpty = true;










 for(InterestCallback<Field, Fact, Stmt, Method> callback : Lists.newLinkedList(interestCallbacks)) {










 callback.canBeResolvedEmpty();










 }










 










 if(interest)










 interestCallbacks = null;










 }





















 public boolean isInterestGiven() {










 return interest;










 }





















 protected void registerCallback(InterestCallback<Field, Fact, Stmt, Method> callback) {










 if(interest) {










 callback.interest(analyzer, this);










 }










 else {










 log("Callback registered");










 interestCallbacks.add(callback);










 }





















 if(canBeResolvedEmpty)










 callback.canBeResolvedEmpty();










 }










 










 protected abstract void log(String message);










 










}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.List;










import java.util.Map;





















import com.google.common.collect.HashMultimap;










import com.google.common.collect.Lists;





















import heros.alias.FlowFunction.ConstrainedFact;










import heros.alias.FlowFunction.Constraint;





















public abstract class Resolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private boolean interest = false;










 private List<InterestCallback<Field, Fact, Stmt, Method>> interestCallbacks = Lists.newLinkedList();










 protected PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer;










 private boolean canBeResolvedEmpty = false;










 










 public Resolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {










 this.analyzer = analyzer;










 }





















 public abstract void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback);










 










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 if(interest)










 return;










 










 log("Interest given");










 interest = true;










 for(InterestCallback<Field, Fact, Stmt, Method> callback : Lists.newLinkedList(interestCallbacks)) {










 callback.interest(analyzer, resolver);










 }










 










 if(canBeResolvedEmpty)










 interestCallbacks = null;










 }










 










 protected void canBeResolvedEmpty() {










 if(canBeResolvedEmpty)










 return;










 










 canBeResolvedEmpty = true;










 for(InterestCallback<Field, Fact, Stmt, Method> callback : Lists.newLinkedList(interestCallbacks)) {










 callback.canBeResolvedEmpty();










 }










 










 if(interest)










 interestCallbacks = null;










 }





















 public boolean isInterestGiven() {










 return interest;










 }





















 protected void registerCallback(InterestCallback<Field, Fact, Stmt, Method> callback) {










 if(interest) {










 callback.interest(analyzer, this);










 }










 else {










 log("Callback registered");










 interestCallbacks.add(callback);










 }





















 if(canBeResolvedEmpty)










 callback.canBeResolvedEmpty();










 }










 










 protected abstract void log(String message);










 










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import java.util.List;importjava.util.List;import java.util.Map;importjava.util.Map;import com.google.common.collect.HashMultimap;importcom.google.common.collect.HashMultimap;import com.google.common.collect.Lists;importcom.google.common.collect.Lists;import heros.alias.FlowFunction.ConstrainedFact;importheros.alias.FlowFunction.ConstrainedFact;import heros.alias.FlowFunction.Constraint;importheros.alias.FlowFunction.Constraint;public abstract class Resolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {publicabstractclassResolver<FieldextendsAccessPath.FieldRef<Field>,Fact,Stmt,Method>{ private boolean interest = false;privatebooleaninterest=false; private List<InterestCallback<Field, Fact, Stmt, Method>> interestCallbacks = Lists.newLinkedList();privateList<InterestCallback<Field,Fact,Stmt,Method>>interestCallbacks=Lists.newLinkedList(); protected PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer;protectedPerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer; private boolean canBeResolvedEmpty = false;privatebooleancanBeResolvedEmpty=false;  public Resolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer) {publicResolver(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer){ this.analyzer = analyzer;this.analyzer=analyzer; }} public abstract void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback);publicabstractvoidresolve(Constraint<Field>constraint,InterestCallback<Field,Fact,Stmt,Method>callback);  public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {publicvoidinterest(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer,Resolver<Field,Fact,Stmt,Method>resolver){ if(interest)if(interest) return;return;  log("Interest given");log("Interest given"); interest = true;interest=true; for(InterestCallback<Field, Fact, Stmt, Method> callback : Lists.newLinkedList(interestCallbacks)) {for(InterestCallback<Field,Fact,Stmt,Method>callback:Lists.newLinkedList(interestCallbacks)){ callback.interest(analyzer, resolver);callback.interest(analyzer,resolver); }}  if(canBeResolvedEmpty)if(canBeResolvedEmpty) interestCallbacks = null;interestCallbacks=null; }}  protected void canBeResolvedEmpty() {protectedvoidcanBeResolvedEmpty(){ if(canBeResolvedEmpty)if(canBeResolvedEmpty) return;return;  canBeResolvedEmpty = true;canBeResolvedEmpty=true; for(InterestCallback<Field, Fact, Stmt, Method> callback : Lists.newLinkedList(interestCallbacks)) {for(InterestCallback<Field,Fact,Stmt,Method>callback:Lists.newLinkedList(interestCallbacks)){ callback.canBeResolvedEmpty();callback.canBeResolvedEmpty(); }}  if(interest)if(interest) interestCallbacks = null;interestCallbacks=null; }} public boolean isInterestGiven() {publicbooleanisInterestGiven(){ return interest;returninterest; }} protected void registerCallback(InterestCallback<Field, Fact, Stmt, Method> callback) {protectedvoidregisterCallback(InterestCallback<Field,Fact,Stmt,Method>callback){ if(interest) {if(interest){ callback.interest(analyzer, this);callback.interest(analyzer,this); }} else {else{ log("Callback registered");log("Callback registered"); interestCallbacks.add(callback);interestCallbacks.add(callback); }} if(canBeResolvedEmpty)if(canBeResolvedEmpty) callback.canBeResolvedEmpty();callback.canBeResolvedEmpty(); }}  protected abstract void log(String message);protectedabstractvoidlog(Stringmessage); }}








src/heros/alias/ReturnSiteResolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















import java.util.Map;










import java.util.Set;





















import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private Stmt returnSite;










 private AccessPath<Field> resolvedAccPath;










 private boolean propagated = false;










 private Set<ReturnEdge> incomingFacts;










 private Map<AccessPath<Field>, ReturnSiteResolver<Field, Fact, Stmt, Method>> nestedResolvers = Maps.newHashMap();










 private ReturnSiteResolver<Field, Fact, Stmt, Method> parent;





















 public ReturnSiteResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt returnSite) {










 this(analyzer, returnSite, new AccessPath<Field>(), null);










 }





















 private ReturnSiteResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt returnSite, AccessPath<Field> resolvedAccPath, ReturnSiteResolver<Field, Fact, Stmt, Method> parent) {










 super(analyzer);










 this.returnSite = returnSite;










 this.resolvedAccPath = resolvedAccPath;










 this.parent = parent;










 this.incomingFacts = Sets.newHashSet();










 }










 










 @Override










 public String toString() {










 return "<"+resolvedAccPath+":"+returnSite+">";










 }










 










 public AccessPath<Field> getResolvedAccessPath() {










 return resolvedAccPath;










 }










 










 public void addIncoming(final WrappedFact<Field, Fact, Stmt, Method> fact, 










 Resolver<Field, Fact, Stmt, Method> resolverAtCaller, 










 Delta<Field> callDelta) {










 










 addIncoming(new ReturnEdge(fact, resolverAtCaller, callDelta));










 }










 










 private void addIncoming(final ReturnEdge retEdge) {










 if(resolvedAccPath.isPrefixOf(retEdge.incAccessPath) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Edge "+retEdge);










 if(!incomingFacts.add(retEdge))










 return;





















 interest(analyzer, this);










 










 for(ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver : nestedResolvers.values())










 nestedResolver.addIncoming(nestedResolver.new ReturnEdge(retEdge.incFact, retEdge.incAccessPath, retEdge.incResolver, 










 retEdge.resolverAtCaller, retEdge.callDelta, retEdge.usedAccessPathOfIncResolver));





















 if(!propagated) {










 propagated=true;










 analyzer.scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, 










 new WrappedFact<>(retEdge.incFact, new AccessPath<Field>(), this)));










 }










 }










 else if(retEdge.incAccessPath.isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 log("Incoming potential prefix:  "+retEdge);










 retEdge.resolveViaDelta();










 }










 }










 










 protected void log(String message) {










 analyzer.log("Return Site "+toString()+": "+message);










 }





















 @Override










 public void resolve(Constraint<Field> constraint, final InterestCallback<Field, Fact, Stmt, Method> callback) {










 log("Resolve: "+constraint);










 if(!constraint.canBeAppliedTo(resolvedAccPath))










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);










 }










 










 private ReturnSiteResolver<Field, Fact, Stmt, Method> getOrCreateNestedResolver(AccessPath<Field> candidateAccPath) {










 if(resolvedAccPath.equals(candidateAccPath))










 return this;










 










 if(!nestedResolvers.containsKey(candidateAccPath)) {










 assert resolvedAccPath.getDeltaTo(candidateAccPath).accesses.length <= 1;










 final ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver = new ReturnSiteResolver<>(analyzer, returnSite, candidateAccPath, this);










 nestedResolver.propagated = true;










 nestedResolvers.put(candidateAccPath, nestedResolver);





















 for(ReturnSiteResolver<Field, Fact, Stmt, Method>.ReturnEdge retEdge: incomingFacts) {










 nestedResolver.addIncoming(nestedResolver.new ReturnEdge(retEdge.incFact, retEdge.incAccessPath, retEdge.incResolver, 










 retEdge.resolverAtCaller, retEdge.callDelta, retEdge.usedAccessPathOfIncResolver));










 } 










 }










 return nestedResolvers.get(candidateAccPath);










 }










 










 private class ReturnEdge {





















 final Fact incFact;










 final Resolver<Field, Fact, Stmt, Method> resolverAtCaller;










 final Delta<Field> callDelta;










 final AccessPath<Field> incAccessPath;










 final Resolver<Field, Fact, Stmt, Method> incResolver;










 final Delta<Field> usedAccessPathOfIncResolver;





















 public ReturnEdge(WrappedFact<Field, Fact, Stmt, Method> fact, Resolver<Field, Fact, Stmt, Method> resolverAtCaller,










 Delta<Field> callDelta) {










 this(fact.getFact(), fact.getAccessPath(), fact.getResolver(), resolverAtCaller, callDelta, Delta.<Field>empty());










 }










 










 private ReturnEdge(Fact incFact, AccessPath<Field> incAccessPath, Resolver<Field, Fact, Stmt, Method> incResolver, 










 Resolver<Field, Fact, Stmt, Method> resolverAtCaller, Delta<Field> callDelta, Delta<Field> usedAccessPathOfIncResolver) {










 this.incFact = incFact;










 this.incAccessPath = incAccessPath;










 this.incResolver = incResolver;










 this.resolverAtCaller = resolverAtCaller;










 this.callDelta = callDelta;










 this.usedAccessPathOfIncResolver = usedAccessPathOfIncResolver;










 }










 










 @Override










 public String toString() {










 return String.format("IncFact: %s%s, Delta: %s, IncResolver: <%s:%s>, ResolverAtCallSite: %s", incFact, incAccessPath, callDelta, usedAccessPathOfIncResolver, incResolver, resolverAtCaller);










 }










 










 public void resolveViaDelta() {










 if(incResolver == null || incResolver instanceof CallEdgeResolver) {










 resolveViaDeltaAndPotentiallyDelegateToCallSite();










 } else {










 //resolve via incoming facts resolver










 Delta<Field> delta = usedAccessPathOfIncResolver.applyTo(incAccessPath, true).getDeltaTo(resolvedAccPath);










 assert delta.accesses.length <= 1;










 incResolver.resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {





















 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, resolver, resolverAtCaller, callDelta, incAccessPath.getDeltaTo(resolvedAccPath)));










 ReturnSiteResolver.this.interest(analyzer, resolver);










 }










 










 @Override










 public void canBeResolvedEmpty() {










 resolveViaDeltaAndPotentiallyDelegateToCallSite();










 }










 });










 } 










 }





















 private void resolveViaDeltaAndPotentiallyDelegateToCallSite() {










 final AccessPath<Field> currAccPath = callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath, true), true);










 if(resolvedAccPath.isPrefixOf(currAccPath) == PrefixTestResult.GUARANTEED_PREFIX) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver));










 ReturnSiteResolver.this.interest(analyzer, ReturnSiteResolver.this);










 } else if(currAccPath.isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 resolveViaCallSiteResolver(currAccPath);










 }










 }





















 protected void resolveViaCallSiteResolver(AccessPath<Field> currAccPath) {










 if(resolverAtCaller == null || resolverAtCaller instanceof CallEdgeResolver) {










 ReturnSiteResolver.this.canBeResolvedEmpty();










 } else {










 resolverAtCaller.resolve(new DeltaConstraint<>(currAccPath.getDeltaTo(resolvedAccPath)), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, null, resolver, Delta.<Field>empty(), incAccessPath.getDeltaTo(resolvedAccPath)));










 ReturnSiteResolver.this.interest(analyzer, ReturnSiteResolver.this);










 }










 










 @Override










 public void canBeResolvedEmpty() {










 ReturnSiteResolver.this.canBeResolvedEmpty();










 }










 });










 }










 }










 }





















 public Stmt getReturnSite() {










 return returnSite;










 }










}












src/heros/alias/ReturnSiteResolver.java



0 → 100644







View file @ 3398e46f








src/heros/alias/ReturnSiteResolver.java



0 → 100644









View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















import java.util.Map;










import java.util.Set;





















import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private Stmt returnSite;










 private AccessPath<Field> resolvedAccPath;










 private boolean propagated = false;










 private Set<ReturnEdge> incomingFacts;










 private Map<AccessPath<Field>, ReturnSiteResolver<Field, Fact, Stmt, Method>> nestedResolvers = Maps.newHashMap();










 private ReturnSiteResolver<Field, Fact, Stmt, Method> parent;





















 public ReturnSiteResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt returnSite) {










 this(analyzer, returnSite, new AccessPath<Field>(), null);










 }





















 private ReturnSiteResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt returnSite, AccessPath<Field> resolvedAccPath, ReturnSiteResolver<Field, Fact, Stmt, Method> parent) {










 super(analyzer);










 this.returnSite = returnSite;










 this.resolvedAccPath = resolvedAccPath;










 this.parent = parent;










 this.incomingFacts = Sets.newHashSet();










 }










 










 @Override










 public String toString() {










 return "<"+resolvedAccPath+":"+returnSite+">";










 }










 










 public AccessPath<Field> getResolvedAccessPath() {










 return resolvedAccPath;










 }










 










 public void addIncoming(final WrappedFact<Field, Fact, Stmt, Method> fact, 










 Resolver<Field, Fact, Stmt, Method> resolverAtCaller, 










 Delta<Field> callDelta) {










 










 addIncoming(new ReturnEdge(fact, resolverAtCaller, callDelta));










 }










 










 private void addIncoming(final ReturnEdge retEdge) {










 if(resolvedAccPath.isPrefixOf(retEdge.incAccessPath) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Edge "+retEdge);










 if(!incomingFacts.add(retEdge))










 return;





















 interest(analyzer, this);










 










 for(ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver : nestedResolvers.values())










 nestedResolver.addIncoming(nestedResolver.new ReturnEdge(retEdge.incFact, retEdge.incAccessPath, retEdge.incResolver, 










 retEdge.resolverAtCaller, retEdge.callDelta, retEdge.usedAccessPathOfIncResolver));





















 if(!propagated) {










 propagated=true;










 analyzer.scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, 










 new WrappedFact<>(retEdge.incFact, new AccessPath<Field>(), this)));










 }










 }










 else if(retEdge.incAccessPath.isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 log("Incoming potential prefix:  "+retEdge);










 retEdge.resolveViaDelta();










 }










 }










 










 protected void log(String message) {










 analyzer.log("Return Site "+toString()+": "+message);










 }





















 @Override










 public void resolve(Constraint<Field> constraint, final InterestCallback<Field, Fact, Stmt, Method> callback) {










 log("Resolve: "+constraint);










 if(!constraint.canBeAppliedTo(resolvedAccPath))










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);










 }










 










 private ReturnSiteResolver<Field, Fact, Stmt, Method> getOrCreateNestedResolver(AccessPath<Field> candidateAccPath) {










 if(resolvedAccPath.equals(candidateAccPath))










 return this;










 










 if(!nestedResolvers.containsKey(candidateAccPath)) {










 assert resolvedAccPath.getDeltaTo(candidateAccPath).accesses.length <= 1;










 final ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver = new ReturnSiteResolver<>(analyzer, returnSite, candidateAccPath, this);










 nestedResolver.propagated = true;










 nestedResolvers.put(candidateAccPath, nestedResolver);





















 for(ReturnSiteResolver<Field, Fact, Stmt, Method>.ReturnEdge retEdge: incomingFacts) {










 nestedResolver.addIncoming(nestedResolver.new ReturnEdge(retEdge.incFact, retEdge.incAccessPath, retEdge.incResolver, 










 retEdge.resolverAtCaller, retEdge.callDelta, retEdge.usedAccessPathOfIncResolver));










 } 










 }










 return nestedResolvers.get(candidateAccPath);










 }










 










 private class ReturnEdge {





















 final Fact incFact;










 final Resolver<Field, Fact, Stmt, Method> resolverAtCaller;










 final Delta<Field> callDelta;










 final AccessPath<Field> incAccessPath;










 final Resolver<Field, Fact, Stmt, Method> incResolver;










 final Delta<Field> usedAccessPathOfIncResolver;





















 public ReturnEdge(WrappedFact<Field, Fact, Stmt, Method> fact, Resolver<Field, Fact, Stmt, Method> resolverAtCaller,










 Delta<Field> callDelta) {










 this(fact.getFact(), fact.getAccessPath(), fact.getResolver(), resolverAtCaller, callDelta, Delta.<Field>empty());










 }










 










 private ReturnEdge(Fact incFact, AccessPath<Field> incAccessPath, Resolver<Field, Fact, Stmt, Method> incResolver, 










 Resolver<Field, Fact, Stmt, Method> resolverAtCaller, Delta<Field> callDelta, Delta<Field> usedAccessPathOfIncResolver) {










 this.incFact = incFact;










 this.incAccessPath = incAccessPath;










 this.incResolver = incResolver;










 this.resolverAtCaller = resolverAtCaller;










 this.callDelta = callDelta;










 this.usedAccessPathOfIncResolver = usedAccessPathOfIncResolver;










 }










 










 @Override










 public String toString() {










 return String.format("IncFact: %s%s, Delta: %s, IncResolver: <%s:%s>, ResolverAtCallSite: %s", incFact, incAccessPath, callDelta, usedAccessPathOfIncResolver, incResolver, resolverAtCaller);










 }










 










 public void resolveViaDelta() {










 if(incResolver == null || incResolver instanceof CallEdgeResolver) {










 resolveViaDeltaAndPotentiallyDelegateToCallSite();










 } else {










 //resolve via incoming facts resolver










 Delta<Field> delta = usedAccessPathOfIncResolver.applyTo(incAccessPath, true).getDeltaTo(resolvedAccPath);










 assert delta.accesses.length <= 1;










 incResolver.resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {





















 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, resolver, resolverAtCaller, callDelta, incAccessPath.getDeltaTo(resolvedAccPath)));










 ReturnSiteResolver.this.interest(analyzer, resolver);










 }










 










 @Override










 public void canBeResolvedEmpty() {










 resolveViaDeltaAndPotentiallyDelegateToCallSite();










 }










 });










 } 










 }





















 private void resolveViaDeltaAndPotentiallyDelegateToCallSite() {










 final AccessPath<Field> currAccPath = callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath, true), true);










 if(resolvedAccPath.isPrefixOf(currAccPath) == PrefixTestResult.GUARANTEED_PREFIX) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver));










 ReturnSiteResolver.this.interest(analyzer, ReturnSiteResolver.this);










 } else if(currAccPath.isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 resolveViaCallSiteResolver(currAccPath);










 }










 }





















 protected void resolveViaCallSiteResolver(AccessPath<Field> currAccPath) {










 if(resolverAtCaller == null || resolverAtCaller instanceof CallEdgeResolver) {










 ReturnSiteResolver.this.canBeResolvedEmpty();










 } else {










 resolverAtCaller.resolve(new DeltaConstraint<>(currAccPath.getDeltaTo(resolvedAccPath)), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, null, resolver, Delta.<Field>empty(), incAccessPath.getDeltaTo(resolvedAccPath)));










 ReturnSiteResolver.this.interest(analyzer, ReturnSiteResolver.this);










 }










 










 @Override










 public void canBeResolvedEmpty() {










 ReturnSiteResolver.this.canBeResolvedEmpty();










 }










 });










 }










 }










 }





















 public Stmt getReturnSite() {










 return returnSite;










 }










}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.FlowFunction.Constraint;





















import java.util.Map;










import java.util.Set;





















import com.google.common.collect.Maps;










import com.google.common.collect.Sets;





















public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {





















 private Stmt returnSite;










 private AccessPath<Field> resolvedAccPath;










 private boolean propagated = false;










 private Set<ReturnEdge> incomingFacts;










 private Map<AccessPath<Field>, ReturnSiteResolver<Field, Fact, Stmt, Method>> nestedResolvers = Maps.newHashMap();










 private ReturnSiteResolver<Field, Fact, Stmt, Method> parent;





















 public ReturnSiteResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt returnSite) {










 this(analyzer, returnSite, new AccessPath<Field>(), null);










 }





















 private ReturnSiteResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt returnSite, AccessPath<Field> resolvedAccPath, ReturnSiteResolver<Field, Fact, Stmt, Method> parent) {










 super(analyzer);










 this.returnSite = returnSite;










 this.resolvedAccPath = resolvedAccPath;










 this.parent = parent;










 this.incomingFacts = Sets.newHashSet();










 }










 










 @Override










 public String toString() {










 return "<"+resolvedAccPath+":"+returnSite+">";










 }










 










 public AccessPath<Field> getResolvedAccessPath() {










 return resolvedAccPath;










 }










 










 public void addIncoming(final WrappedFact<Field, Fact, Stmt, Method> fact, 










 Resolver<Field, Fact, Stmt, Method> resolverAtCaller, 










 Delta<Field> callDelta) {










 










 addIncoming(new ReturnEdge(fact, resolverAtCaller, callDelta));










 }










 










 private void addIncoming(final ReturnEdge retEdge) {










 if(resolvedAccPath.isPrefixOf(retEdge.incAccessPath) == PrefixTestResult.GUARANTEED_PREFIX) {










 log("Incoming Edge "+retEdge);










 if(!incomingFacts.add(retEdge))










 return;





















 interest(analyzer, this);










 










 for(ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver : nestedResolvers.values())










 nestedResolver.addIncoming(nestedResolver.new ReturnEdge(retEdge.incFact, retEdge.incAccessPath, retEdge.incResolver, 










 retEdge.resolverAtCaller, retEdge.callDelta, retEdge.usedAccessPathOfIncResolver));





















 if(!propagated) {










 propagated=true;










 analyzer.scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, 










 new WrappedFact<>(retEdge.incFact, new AccessPath<Field>(), this)));










 }










 }










 else if(retEdge.incAccessPath.isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 log("Incoming potential prefix:  "+retEdge);










 retEdge.resolveViaDelta();










 }










 }










 










 protected void log(String message) {










 analyzer.log("Return Site "+toString()+": "+message);










 }





















 @Override










 public void resolve(Constraint<Field> constraint, final InterestCallback<Field, Fact, Stmt, Method> callback) {










 log("Resolve: "+constraint);










 if(!constraint.canBeAppliedTo(resolvedAccPath))










 return;










 










 AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);










 ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);










 if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))










 throw new AssertionError();










 










 nestedResolver.registerCallback(callback);










 }










 










 private ReturnSiteResolver<Field, Fact, Stmt, Method> getOrCreateNestedResolver(AccessPath<Field> candidateAccPath) {










 if(resolvedAccPath.equals(candidateAccPath))










 return this;










 










 if(!nestedResolvers.containsKey(candidateAccPath)) {










 assert resolvedAccPath.getDeltaTo(candidateAccPath).accesses.length <= 1;










 final ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver = new ReturnSiteResolver<>(analyzer, returnSite, candidateAccPath, this);










 nestedResolver.propagated = true;










 nestedResolvers.put(candidateAccPath, nestedResolver);





















 for(ReturnSiteResolver<Field, Fact, Stmt, Method>.ReturnEdge retEdge: incomingFacts) {










 nestedResolver.addIncoming(nestedResolver.new ReturnEdge(retEdge.incFact, retEdge.incAccessPath, retEdge.incResolver, 










 retEdge.resolverAtCaller, retEdge.callDelta, retEdge.usedAccessPathOfIncResolver));










 } 










 }










 return nestedResolvers.get(candidateAccPath);










 }










 










 private class ReturnEdge {





















 final Fact incFact;










 final Resolver<Field, Fact, Stmt, Method> resolverAtCaller;










 final Delta<Field> callDelta;










 final AccessPath<Field> incAccessPath;










 final Resolver<Field, Fact, Stmt, Method> incResolver;










 final Delta<Field> usedAccessPathOfIncResolver;





















 public ReturnEdge(WrappedFact<Field, Fact, Stmt, Method> fact, Resolver<Field, Fact, Stmt, Method> resolverAtCaller,










 Delta<Field> callDelta) {










 this(fact.getFact(), fact.getAccessPath(), fact.getResolver(), resolverAtCaller, callDelta, Delta.<Field>empty());










 }










 










 private ReturnEdge(Fact incFact, AccessPath<Field> incAccessPath, Resolver<Field, Fact, Stmt, Method> incResolver, 










 Resolver<Field, Fact, Stmt, Method> resolverAtCaller, Delta<Field> callDelta, Delta<Field> usedAccessPathOfIncResolver) {










 this.incFact = incFact;










 this.incAccessPath = incAccessPath;










 this.incResolver = incResolver;










 this.resolverAtCaller = resolverAtCaller;










 this.callDelta = callDelta;










 this.usedAccessPathOfIncResolver = usedAccessPathOfIncResolver;










 }










 










 @Override










 public String toString() {










 return String.format("IncFact: %s%s, Delta: %s, IncResolver: <%s:%s>, ResolverAtCallSite: %s", incFact, incAccessPath, callDelta, usedAccessPathOfIncResolver, incResolver, resolverAtCaller);










 }










 










 public void resolveViaDelta() {










 if(incResolver == null || incResolver instanceof CallEdgeResolver) {










 resolveViaDeltaAndPotentiallyDelegateToCallSite();










 } else {










 //resolve via incoming facts resolver










 Delta<Field> delta = usedAccessPathOfIncResolver.applyTo(incAccessPath, true).getDeltaTo(resolvedAccPath);










 assert delta.accesses.length <= 1;










 incResolver.resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {





















 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, resolver, resolverAtCaller, callDelta, incAccessPath.getDeltaTo(resolvedAccPath)));










 ReturnSiteResolver.this.interest(analyzer, resolver);










 }










 










 @Override










 public void canBeResolvedEmpty() {










 resolveViaDeltaAndPotentiallyDelegateToCallSite();










 }










 });










 } 










 }





















 private void resolveViaDeltaAndPotentiallyDelegateToCallSite() {










 final AccessPath<Field> currAccPath = callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath, true), true);










 if(resolvedAccPath.isPrefixOf(currAccPath) == PrefixTestResult.GUARANTEED_PREFIX) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver));










 ReturnSiteResolver.this.interest(analyzer, ReturnSiteResolver.this);










 } else if(currAccPath.isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {










 resolveViaCallSiteResolver(currAccPath);










 }










 }





















 protected void resolveViaCallSiteResolver(AccessPath<Field> currAccPath) {










 if(resolverAtCaller == null || resolverAtCaller instanceof CallEdgeResolver) {










 ReturnSiteResolver.this.canBeResolvedEmpty();










 } else {










 resolverAtCaller.resolve(new DeltaConstraint<>(currAccPath.getDeltaTo(resolvedAccPath)), new InterestCallback<Field, Fact, Stmt, Method>() {










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 incomingFacts.add(new ReturnEdge(incFact, incAccessPath, null, resolver, Delta.<Field>empty(), incAccessPath.getDeltaTo(resolvedAccPath)));










 ReturnSiteResolver.this.interest(analyzer, ReturnSiteResolver.this);










 }










 










 @Override










 public void canBeResolvedEmpty() {










 ReturnSiteResolver.this.canBeResolvedEmpty();










 }










 });










 }










 }










 }





















 public Stmt getReturnSite() {










 return returnSite;










 }










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.alias.AccessPath.Delta;importheros.alias.AccessPath.Delta;import heros.alias.AccessPath.PrefixTestResult;importheros.alias.AccessPath.PrefixTestResult;import heros.alias.FlowFunction.Constraint;importheros.alias.FlowFunction.Constraint;import java.util.Map;importjava.util.Map;import java.util.Set;importjava.util.Set;import com.google.common.collect.Maps;importcom.google.common.collect.Maps;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;public class ReturnSiteResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends Resolver<Field, Fact, Stmt, Method> {publicclassReturnSiteResolver<FieldextendsAccessPath.FieldRef<Field>,Fact,Stmt,Method>extendsResolver<Field,Fact,Stmt,Method>{ private Stmt returnSite;privateStmtreturnSite; private AccessPath<Field> resolvedAccPath;privateAccessPath<Field>resolvedAccPath; private boolean propagated = false;privatebooleanpropagated=false; private Set<ReturnEdge> incomingFacts;privateSet<ReturnEdge>incomingFacts; private Map<AccessPath<Field>, ReturnSiteResolver<Field, Fact, Stmt, Method>> nestedResolvers = Maps.newHashMap();privateMap<AccessPath<Field>,ReturnSiteResolver<Field,Fact,Stmt,Method>>nestedResolvers=Maps.newHashMap(); private ReturnSiteResolver<Field, Fact, Stmt, Method> parent;privateReturnSiteResolver<Field,Fact,Stmt,Method>parent; public ReturnSiteResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt returnSite) {publicReturnSiteResolver(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer,StmtreturnSite){ this(analyzer, returnSite, new AccessPath<Field>(), null);this(analyzer,returnSite,newAccessPath<Field>(),null); }} private ReturnSiteResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Stmt returnSite, AccessPath<Field> resolvedAccPath, ReturnSiteResolver<Field, Fact, Stmt, Method> parent) {privateReturnSiteResolver(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer,StmtreturnSite,AccessPath<Field>resolvedAccPath,ReturnSiteResolver<Field,Fact,Stmt,Method>parent){ super(analyzer);super(analyzer); this.returnSite = returnSite;this.returnSite=returnSite; this.resolvedAccPath = resolvedAccPath;this.resolvedAccPath=resolvedAccPath; this.parent = parent;this.parent=parent; this.incomingFacts = Sets.newHashSet();this.incomingFacts=Sets.newHashSet(); }}  @Override@Override public String toString() {publicStringtoString(){ return "<"+resolvedAccPath+":"+returnSite+">";return"<"+resolvedAccPath+":"+returnSite+">"; }}  public AccessPath<Field> getResolvedAccessPath() {publicAccessPath<Field>getResolvedAccessPath(){ return resolvedAccPath;returnresolvedAccPath; }}  public void addIncoming(final WrappedFact<Field, Fact, Stmt, Method> fact, publicvoidaddIncoming(finalWrappedFact<Field,Fact,Stmt,Method>fact, Resolver<Field, Fact, Stmt, Method> resolverAtCaller, Resolver<Field,Fact,Stmt,Method>resolverAtCaller, Delta<Field> callDelta) {Delta<Field>callDelta){  addIncoming(new ReturnEdge(fact, resolverAtCaller, callDelta));addIncoming(newReturnEdge(fact,resolverAtCaller,callDelta)); }}  private void addIncoming(final ReturnEdge retEdge) {privatevoidaddIncoming(finalReturnEdgeretEdge){ if(resolvedAccPath.isPrefixOf(retEdge.incAccessPath) == PrefixTestResult.GUARANTEED_PREFIX) {if(resolvedAccPath.isPrefixOf(retEdge.incAccessPath)==PrefixTestResult.GUARANTEED_PREFIX){ log("Incoming Edge "+retEdge);log("Incoming Edge "+retEdge); if(!incomingFacts.add(retEdge))if(!incomingFacts.add(retEdge)) return;return; interest(analyzer, this);interest(analyzer,this);  for(ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver : nestedResolvers.values())for(ReturnSiteResolver<Field,Fact,Stmt,Method>nestedResolver:nestedResolvers.values()) nestedResolver.addIncoming(nestedResolver.new ReturnEdge(retEdge.incFact, retEdge.incAccessPath, retEdge.incResolver, nestedResolver.addIncoming(nestedResolver.newReturnEdge(retEdge.incFact,retEdge.incAccessPath,retEdge.incResolver, retEdge.resolverAtCaller, retEdge.callDelta, retEdge.usedAccessPathOfIncResolver));retEdge.resolverAtCaller,retEdge.callDelta,retEdge.usedAccessPathOfIncResolver)); if(!propagated) {if(!propagated){ propagated=true;propagated=true; analyzer.scheduleEdgeTo(new WrappedFactAtStatement<Field, Fact, Stmt, Method>(returnSite, analyzer.scheduleEdgeTo(newWrappedFactAtStatement<Field,Fact,Stmt,Method>(returnSite, new WrappedFact<>(retEdge.incFact, new AccessPath<Field>(), this)));newWrappedFact<>(retEdge.incFact,newAccessPath<Field>(),this))); }} }} else if(retEdge.incAccessPath.isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {elseif(retEdge.incAccessPath.isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)){ log("Incoming potential prefix:  "+retEdge);log("Incoming potential prefix:  "+retEdge); retEdge.resolveViaDelta();retEdge.resolveViaDelta(); }} }}  protected void log(String message) {protectedvoidlog(Stringmessage){ analyzer.log("Return Site "+toString()+": "+message);analyzer.log("Return Site "+toString()+": "+message); }} @Override@Override public void resolve(Constraint<Field> constraint, final InterestCallback<Field, Fact, Stmt, Method> callback) {publicvoidresolve(Constraint<Field>constraint,finalInterestCallback<Field,Fact,Stmt,Method>callback){ log("Resolve: "+constraint);log("Resolve: "+constraint); if(!constraint.canBeAppliedTo(resolvedAccPath))if(!constraint.canBeAppliedTo(resolvedAccPath)) return;return;  AccessPath<Field> candidateAccPath = constraint.applyToAccessPath(resolvedAccPath, false);AccessPath<Field>candidateAccPath=constraint.applyToAccessPath(resolvedAccPath,false); ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver = getOrCreateNestedResolver(candidateAccPath);ReturnSiteResolver<Field,Fact,Stmt,Method>nestedResolver=getOrCreateNestedResolver(candidateAccPath); if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath, false)))if(!nestedResolver.resolvedAccPath.equals(constraint.applyToAccessPath(resolvedAccPath,false))) throw new AssertionError();thrownewAssertionError();  nestedResolver.registerCallback(callback);nestedResolver.registerCallback(callback); }}  private ReturnSiteResolver<Field, Fact, Stmt, Method> getOrCreateNestedResolver(AccessPath<Field> candidateAccPath) {privateReturnSiteResolver<Field,Fact,Stmt,Method>getOrCreateNestedResolver(AccessPath<Field>candidateAccPath){ if(resolvedAccPath.equals(candidateAccPath))if(resolvedAccPath.equals(candidateAccPath)) return this;returnthis;  if(!nestedResolvers.containsKey(candidateAccPath)) {if(!nestedResolvers.containsKey(candidateAccPath)){ assert resolvedAccPath.getDeltaTo(candidateAccPath).accesses.length <= 1;assertresolvedAccPath.getDeltaTo(candidateAccPath).accesses.length<=1; final ReturnSiteResolver<Field, Fact, Stmt, Method> nestedResolver = new ReturnSiteResolver<>(analyzer, returnSite, candidateAccPath, this);finalReturnSiteResolver<Field,Fact,Stmt,Method>nestedResolver=newReturnSiteResolver<>(analyzer,returnSite,candidateAccPath,this); nestedResolver.propagated = true;nestedResolver.propagated=true; nestedResolvers.put(candidateAccPath, nestedResolver);nestedResolvers.put(candidateAccPath,nestedResolver); for(ReturnSiteResolver<Field, Fact, Stmt, Method>.ReturnEdge retEdge: incomingFacts) {for(ReturnSiteResolver<Field,Fact,Stmt,Method>.ReturnEdgeretEdge:incomingFacts){ nestedResolver.addIncoming(nestedResolver.new ReturnEdge(retEdge.incFact, retEdge.incAccessPath, retEdge.incResolver, nestedResolver.addIncoming(nestedResolver.newReturnEdge(retEdge.incFact,retEdge.incAccessPath,retEdge.incResolver, retEdge.resolverAtCaller, retEdge.callDelta, retEdge.usedAccessPathOfIncResolver));retEdge.resolverAtCaller,retEdge.callDelta,retEdge.usedAccessPathOfIncResolver)); } } }} return nestedResolvers.get(candidateAccPath);returnnestedResolvers.get(candidateAccPath); }}  private class ReturnEdge {privateclassReturnEdge{ final Fact incFact;finalFactincFact; final Resolver<Field, Fact, Stmt, Method> resolverAtCaller;finalResolver<Field,Fact,Stmt,Method>resolverAtCaller; final Delta<Field> callDelta;finalDelta<Field>callDelta; final AccessPath<Field> incAccessPath;finalAccessPath<Field>incAccessPath; final Resolver<Field, Fact, Stmt, Method> incResolver;finalResolver<Field,Fact,Stmt,Method>incResolver; final Delta<Field> usedAccessPathOfIncResolver;finalDelta<Field>usedAccessPathOfIncResolver; public ReturnEdge(WrappedFact<Field, Fact, Stmt, Method> fact, Resolver<Field, Fact, Stmt, Method> resolverAtCaller,publicReturnEdge(WrappedFact<Field,Fact,Stmt,Method>fact,Resolver<Field,Fact,Stmt,Method>resolverAtCaller, Delta<Field> callDelta) {Delta<Field>callDelta){ this(fact.getFact(), fact.getAccessPath(), fact.getResolver(), resolverAtCaller, callDelta, Delta.<Field>empty());this(fact.getFact(),fact.getAccessPath(),fact.getResolver(),resolverAtCaller,callDelta,Delta.<Field>empty()); }}  private ReturnEdge(Fact incFact, AccessPath<Field> incAccessPath, Resolver<Field, Fact, Stmt, Method> incResolver, privateReturnEdge(FactincFact,AccessPath<Field>incAccessPath,Resolver<Field,Fact,Stmt,Method>incResolver, Resolver<Field, Fact, Stmt, Method> resolverAtCaller, Delta<Field> callDelta, Delta<Field> usedAccessPathOfIncResolver) {Resolver<Field,Fact,Stmt,Method>resolverAtCaller,Delta<Field>callDelta,Delta<Field>usedAccessPathOfIncResolver){ this.incFact = incFact;this.incFact=incFact; this.incAccessPath = incAccessPath;this.incAccessPath=incAccessPath; this.incResolver = incResolver;this.incResolver=incResolver; this.resolverAtCaller = resolverAtCaller;this.resolverAtCaller=resolverAtCaller; this.callDelta = callDelta;this.callDelta=callDelta; this.usedAccessPathOfIncResolver = usedAccessPathOfIncResolver;this.usedAccessPathOfIncResolver=usedAccessPathOfIncResolver; }}  @Override@Override public String toString() {publicStringtoString(){ return String.format("IncFact: %s%s, Delta: %s, IncResolver: <%s:%s>, ResolverAtCallSite: %s", incFact, incAccessPath, callDelta, usedAccessPathOfIncResolver, incResolver, resolverAtCaller);returnString.format("IncFact: %s%s, Delta: %s, IncResolver: <%s:%s>, ResolverAtCallSite: %s",incFact,incAccessPath,callDelta,usedAccessPathOfIncResolver,incResolver,resolverAtCaller); }}  public void resolveViaDelta() {publicvoidresolveViaDelta(){ if(incResolver == null || incResolver instanceof CallEdgeResolver) {if(incResolver==null||incResolverinstanceofCallEdgeResolver){ resolveViaDeltaAndPotentiallyDelegateToCallSite();resolveViaDeltaAndPotentiallyDelegateToCallSite(); } else {}else{ //resolve via incoming facts resolver//resolve via incoming facts resolver Delta<Field> delta = usedAccessPathOfIncResolver.applyTo(incAccessPath, true).getDeltaTo(resolvedAccPath);Delta<Field>delta=usedAccessPathOfIncResolver.applyTo(incAccessPath,true).getDeltaTo(resolvedAccPath); assert delta.accesses.length <= 1;assertdelta.accesses.length<=1; incResolver.resolve(new DeltaConstraint<>(delta), new InterestCallback<Field, Fact, Stmt, Method>() {incResolver.resolve(newDeltaConstraint<>(delta),newInterestCallback<Field,Fact,Stmt,Method>(){ @Override@Override public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {publicvoidinterest(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer,Resolver<Field,Fact,Stmt,Method>resolver){ incomingFacts.add(new ReturnEdge(incFact, incAccessPath, resolver, resolverAtCaller, callDelta, incAccessPath.getDeltaTo(resolvedAccPath)));incomingFacts.add(newReturnEdge(incFact,incAccessPath,resolver,resolverAtCaller,callDelta,incAccessPath.getDeltaTo(resolvedAccPath))); ReturnSiteResolver.this.interest(analyzer, resolver);ReturnSiteResolver.this.interest(analyzer,resolver); }}  @Override@Override public void canBeResolvedEmpty() {publicvoidcanBeResolvedEmpty(){ resolveViaDeltaAndPotentiallyDelegateToCallSite();resolveViaDeltaAndPotentiallyDelegateToCallSite(); }} });}); } } }} private void resolveViaDeltaAndPotentiallyDelegateToCallSite() {privatevoidresolveViaDeltaAndPotentiallyDelegateToCallSite(){ final AccessPath<Field> currAccPath = callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath, true), true);finalAccessPath<Field>currAccPath=callDelta.applyTo(usedAccessPathOfIncResolver.applyTo(incAccessPath,true),true); if(resolvedAccPath.isPrefixOf(currAccPath) == PrefixTestResult.GUARANTEED_PREFIX) {if(resolvedAccPath.isPrefixOf(currAccPath)==PrefixTestResult.GUARANTEED_PREFIX){ incomingFacts.add(new ReturnEdge(incFact, incAccessPath, null, resolverAtCaller, callDelta, usedAccessPathOfIncResolver));incomingFacts.add(newReturnEdge(incFact,incAccessPath,null,resolverAtCaller,callDelta,usedAccessPathOfIncResolver)); ReturnSiteResolver.this.interest(analyzer, ReturnSiteResolver.this);ReturnSiteResolver.this.interest(analyzer,ReturnSiteResolver.this); } else if(currAccPath.isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)) {}elseif(currAccPath.isPrefixOf(resolvedAccPath).atLeast(PrefixTestResult.POTENTIAL_PREFIX)){ resolveViaCallSiteResolver(currAccPath);resolveViaCallSiteResolver(currAccPath); }} }} protected void resolveViaCallSiteResolver(AccessPath<Field> currAccPath) {protectedvoidresolveViaCallSiteResolver(AccessPath<Field>currAccPath){ if(resolverAtCaller == null || resolverAtCaller instanceof CallEdgeResolver) {if(resolverAtCaller==null||resolverAtCallerinstanceofCallEdgeResolver){ ReturnSiteResolver.this.canBeResolvedEmpty();ReturnSiteResolver.this.canBeResolvedEmpty(); } else {}else{ resolverAtCaller.resolve(new DeltaConstraint<>(currAccPath.getDeltaTo(resolvedAccPath)), new InterestCallback<Field, Fact, Stmt, Method>() {resolverAtCaller.resolve(newDeltaConstraint<>(currAccPath.getDeltaTo(resolvedAccPath)),newInterestCallback<Field,Fact,Stmt,Method>(){ @Override@Override public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {publicvoidinterest(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer,Resolver<Field,Fact,Stmt,Method>resolver){ incomingFacts.add(new ReturnEdge(incFact, incAccessPath, null, resolver, Delta.<Field>empty(), incAccessPath.getDeltaTo(resolvedAccPath)));incomingFacts.add(newReturnEdge(incFact,incAccessPath,null,resolver,Delta.<Field>empty(),incAccessPath.getDeltaTo(resolvedAccPath))); ReturnSiteResolver.this.interest(analyzer, ReturnSiteResolver.this);ReturnSiteResolver.this.interest(analyzer,ReturnSiteResolver.this); }}  @Override@Override public void canBeResolvedEmpty() {publicvoidcanBeResolvedEmpty(){ ReturnSiteResolver.this.canBeResolvedEmpty();ReturnSiteResolver.this.canBeResolvedEmpty(); }} });}); }} }} }} public Stmt getReturnSite() {publicStmtgetReturnSite(){ return returnSite;returnreturnSite; }}}}








src/heros/alias/Scheduler.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.LinkedList;










import com.google.common.collect.Lists;





















public class Scheduler {





















 private LinkedList<Runnable> worklist = Lists.newLinkedList();










 










 public void schedule(Runnable job) {










 worklist.add(job);










 }





















 public void runAndAwaitCompletion() {










 while(!worklist.isEmpty()) {










 worklist.removeLast().run();










 }










 }





















}












src/heros/alias/Scheduler.java



0 → 100644







View file @ 3398e46f








src/heros/alias/Scheduler.java



0 → 100644









View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.LinkedList;










import com.google.common.collect.Lists;





















public class Scheduler {





















 private LinkedList<Runnable> worklist = Lists.newLinkedList();










 










 public void schedule(Runnable job) {










 worklist.add(job);










 }





















 public void runAndAwaitCompletion() {










 while(!worklist.isEmpty()) {










 worklist.removeLast().run();










 }










 }





















}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.util.LinkedList;










import com.google.common.collect.Lists;





















public class Scheduler {





















 private LinkedList<Runnable> worklist = Lists.newLinkedList();










 










 public void schedule(Runnable job) {










 worklist.add(job);










 }





















 public void runAndAwaitCompletion() {










 while(!worklist.isEmpty()) {










 worklist.removeLast().run();










 }










 }





















}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import java.util.LinkedList;importjava.util.LinkedList;import com.google.common.collect.Lists;importcom.google.common.collect.Lists;public class Scheduler {publicclassScheduler{ private LinkedList<Runnable> worklist = Lists.newLinkedList();privateLinkedList<Runnable>worklist=Lists.newLinkedList();  public void schedule(Runnable job) {publicvoidschedule(Runnablejob){ worklist.add(job);worklist.add(job); }} public void runAndAwaitCompletion() {publicvoidrunAndAwaitCompletion(){ while(!worklist.isEmpty()) {while(!worklist.isEmpty()){ worklist.removeLast().run();worklist.removeLast().run(); }} }}}}








src/heros/alias/TestDebugger.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.io.FileWriter;










import java.io.IOException;










import java.util.Set;





















import com.google.common.collect.Sets;





















import heros.InterproceduralCFG;










import heros.alias.TestHelper.Edge;





















public class TestDebugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 private JsonDocument root = new JsonDocument();










 private I icfg;










 










 public void writeJsonDebugFile(String filename) {










 try {










 FileWriter writer = new FileWriter(filename);










 StringBuilder builder = new StringBuilder();










 builder.append("var root=");










 root.write(builder, 0);










 writer.write(builder.toString());










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }










 










 /* (non-Javadoc)










	 * @see heros.alias.Debugger#setICFG(I)










	 */










 @Override










 public void setICFG(I icfg) {










 this.icfg = icfg;










 }





















 /* (non-Javadoc)










	 * @see heros.alias.Debugger#initialSeed(Stmt)










	 */










 @Override










 public void initialSeed(Stmt stmt) {










 stmt(stmt).keyValue("seed", "true");










 










 includeSuccessors(stmt, Sets.<Stmt> newHashSet());










 }










 










 private void includeSuccessors(Stmt stmt, Set<Stmt> visited) {










 if(!visited.add(stmt))










 return;










 










 JsonDocument doc = stmt(stmt);










 for(Stmt succ : icfg.getSuccsOf(stmt)) {










 doc.array("successors").add(succ.toString());










 stmt(succ);










 includeSuccessors(succ, visited);










 }










 










 if(icfg.isCallStmt(stmt)) {










 for(Method m : icfg.getCalleesOfCallAt(stmt)) {










 doc.doc("calls").doc(m.toString());










 for(Stmt sp : icfg.getStartPointsOf(m)) {










 stmt(sp).keyValue("startPoint", "true");










 includeSuccessors(sp, visited);










 }










 }










 for(Stmt retSite :icfg.getReturnSitesOfCallAt(stmt)) {










 doc.array("successors").add(retSite.toString());










 stmt(retSite);










 includeSuccessors(retSite, visited);










 }










 }










 if(icfg.isExitStmt(stmt)) {










 for(Stmt callSite : icfg.getCallersOf(icfg.getMethodOf(stmt))) {










 for(Stmt retSite : icfg.getReturnSitesOfCallAt(callSite)) {










 doc.doc("returns").doc(retSite.toString());










 includeSuccessors(retSite, visited);










 }










 }










 }










 }





















 protected JsonDocument stmt(Stmt stmt) {










 Method methodOf = icfg.getMethodOf(stmt);










 return root.doc("methods").doc(methodOf.toString()).doc(stmt.toString());










 }










 










 public void expectNormalFlow(Stmt unit, String expectedFlowFunctionsToString) {










 stmt(unit).keyValue("flow", expectedFlowFunctionsToString);










 }





















 public void expectCallFlow(Stmt callSite, Method destinationMethod, String expectedFlowFunctionsToString) {










 stmt(callSite).doc("calls").doc(destinationMethod.toString()).keyValue("flow", expectedFlowFunctionsToString);










 }





















 public void expectReturnFlow(Stmt exitStmt, Stmt returnSite, String expectedFlowFunctionsToString) {










 if(returnSite != null)










 stmt(exitStmt).doc("returns").doc(returnSite.toString()).keyValue("flow", expectedFlowFunctionsToString);










 }





















 static void tabs(int tabs, StringBuilder builder) {










 for(int i=0; i<tabs; i++)










 builder.append("\t");










 }





















}












src/heros/alias/TestDebugger.java



0 → 100644







View file @ 3398e46f








src/heros/alias/TestDebugger.java



0 → 100644









View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.io.FileWriter;










import java.io.IOException;










import java.util.Set;





















import com.google.common.collect.Sets;





















import heros.InterproceduralCFG;










import heros.alias.TestHelper.Edge;





















public class TestDebugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 private JsonDocument root = new JsonDocument();










 private I icfg;










 










 public void writeJsonDebugFile(String filename) {










 try {










 FileWriter writer = new FileWriter(filename);










 StringBuilder builder = new StringBuilder();










 builder.append("var root=");










 root.write(builder, 0);










 writer.write(builder.toString());










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }










 










 /* (non-Javadoc)










	 * @see heros.alias.Debugger#setICFG(I)










	 */










 @Override










 public void setICFG(I icfg) {










 this.icfg = icfg;










 }





















 /* (non-Javadoc)










	 * @see heros.alias.Debugger#initialSeed(Stmt)










	 */










 @Override










 public void initialSeed(Stmt stmt) {










 stmt(stmt).keyValue("seed", "true");










 










 includeSuccessors(stmt, Sets.<Stmt> newHashSet());










 }










 










 private void includeSuccessors(Stmt stmt, Set<Stmt> visited) {










 if(!visited.add(stmt))










 return;










 










 JsonDocument doc = stmt(stmt);










 for(Stmt succ : icfg.getSuccsOf(stmt)) {










 doc.array("successors").add(succ.toString());










 stmt(succ);










 includeSuccessors(succ, visited);










 }










 










 if(icfg.isCallStmt(stmt)) {










 for(Method m : icfg.getCalleesOfCallAt(stmt)) {










 doc.doc("calls").doc(m.toString());










 for(Stmt sp : icfg.getStartPointsOf(m)) {










 stmt(sp).keyValue("startPoint", "true");










 includeSuccessors(sp, visited);










 }










 }










 for(Stmt retSite :icfg.getReturnSitesOfCallAt(stmt)) {










 doc.array("successors").add(retSite.toString());










 stmt(retSite);










 includeSuccessors(retSite, visited);










 }










 }










 if(icfg.isExitStmt(stmt)) {










 for(Stmt callSite : icfg.getCallersOf(icfg.getMethodOf(stmt))) {










 for(Stmt retSite : icfg.getReturnSitesOfCallAt(callSite)) {










 doc.doc("returns").doc(retSite.toString());










 includeSuccessors(retSite, visited);










 }










 }










 }










 }





















 protected JsonDocument stmt(Stmt stmt) {










 Method methodOf = icfg.getMethodOf(stmt);










 return root.doc("methods").doc(methodOf.toString()).doc(stmt.toString());










 }










 










 public void expectNormalFlow(Stmt unit, String expectedFlowFunctionsToString) {










 stmt(unit).keyValue("flow", expectedFlowFunctionsToString);










 }





















 public void expectCallFlow(Stmt callSite, Method destinationMethod, String expectedFlowFunctionsToString) {










 stmt(callSite).doc("calls").doc(destinationMethod.toString()).keyValue("flow", expectedFlowFunctionsToString);










 }





















 public void expectReturnFlow(Stmt exitStmt, Stmt returnSite, String expectedFlowFunctionsToString) {










 if(returnSite != null)










 stmt(exitStmt).doc("returns").doc(returnSite.toString()).keyValue("flow", expectedFlowFunctionsToString);










 }





















 static void tabs(int tabs, StringBuilder builder) {










 for(int i=0; i<tabs; i++)










 builder.append("\t");










 }





















}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import java.io.FileWriter;










import java.io.IOException;










import java.util.Set;





















import com.google.common.collect.Sets;





















import heros.InterproceduralCFG;










import heros.alias.TestHelper.Edge;





















public class TestDebugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {





















 private JsonDocument root = new JsonDocument();










 private I icfg;










 










 public void writeJsonDebugFile(String filename) {










 try {










 FileWriter writer = new FileWriter(filename);










 StringBuilder builder = new StringBuilder();










 builder.append("var root=");










 root.write(builder, 0);










 writer.write(builder.toString());










 writer.close();










 } catch (IOException e) {










 e.printStackTrace();










 }










 }










 










 /* (non-Javadoc)










	 * @see heros.alias.Debugger#setICFG(I)










	 */










 @Override










 public void setICFG(I icfg) {










 this.icfg = icfg;










 }





















 /* (non-Javadoc)










	 * @see heros.alias.Debugger#initialSeed(Stmt)










	 */










 @Override










 public void initialSeed(Stmt stmt) {










 stmt(stmt).keyValue("seed", "true");










 










 includeSuccessors(stmt, Sets.<Stmt> newHashSet());










 }










 










 private void includeSuccessors(Stmt stmt, Set<Stmt> visited) {










 if(!visited.add(stmt))










 return;










 










 JsonDocument doc = stmt(stmt);










 for(Stmt succ : icfg.getSuccsOf(stmt)) {










 doc.array("successors").add(succ.toString());










 stmt(succ);










 includeSuccessors(succ, visited);










 }










 










 if(icfg.isCallStmt(stmt)) {










 for(Method m : icfg.getCalleesOfCallAt(stmt)) {










 doc.doc("calls").doc(m.toString());










 for(Stmt sp : icfg.getStartPointsOf(m)) {










 stmt(sp).keyValue("startPoint", "true");










 includeSuccessors(sp, visited);










 }










 }










 for(Stmt retSite :icfg.getReturnSitesOfCallAt(stmt)) {










 doc.array("successors").add(retSite.toString());










 stmt(retSite);










 includeSuccessors(retSite, visited);










 }










 }










 if(icfg.isExitStmt(stmt)) {










 for(Stmt callSite : icfg.getCallersOf(icfg.getMethodOf(stmt))) {










 for(Stmt retSite : icfg.getReturnSitesOfCallAt(callSite)) {










 doc.doc("returns").doc(retSite.toString());










 includeSuccessors(retSite, visited);










 }










 }










 }










 }





















 protected JsonDocument stmt(Stmt stmt) {










 Method methodOf = icfg.getMethodOf(stmt);










 return root.doc("methods").doc(methodOf.toString()).doc(stmt.toString());










 }










 










 public void expectNormalFlow(Stmt unit, String expectedFlowFunctionsToString) {










 stmt(unit).keyValue("flow", expectedFlowFunctionsToString);










 }





















 public void expectCallFlow(Stmt callSite, Method destinationMethod, String expectedFlowFunctionsToString) {










 stmt(callSite).doc("calls").doc(destinationMethod.toString()).keyValue("flow", expectedFlowFunctionsToString);










 }





















 public void expectReturnFlow(Stmt exitStmt, Stmt returnSite, String expectedFlowFunctionsToString) {










 if(returnSite != null)










 stmt(exitStmt).doc("returns").doc(returnSite.toString()).keyValue("flow", expectedFlowFunctionsToString);










 }





















 static void tabs(int tabs, StringBuilder builder) {










 for(int i=0; i<tabs; i++)










 builder.append("\t");










 }





















}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import java.io.FileWriter;importjava.io.FileWriter;import java.io.IOException;importjava.io.IOException;import java.util.Set;importjava.util.Set;import com.google.common.collect.Sets;importcom.google.common.collect.Sets;import heros.InterproceduralCFG;importheros.InterproceduralCFG;import heros.alias.TestHelper.Edge;importheros.alias.TestHelper.Edge;public class TestDebugger<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method, I extends InterproceduralCFG<Stmt, Method>> implements Debugger<Field, Fact, Stmt, Method, I> {publicclassTestDebugger<FieldextendsAccessPath.FieldRef<Field>,Fact,Stmt,Method,IextendsInterproceduralCFG<Stmt,Method>>implementsDebugger<Field,Fact,Stmt,Method,I>{ private JsonDocument root = new JsonDocument();privateJsonDocumentroot=newJsonDocument(); private I icfg;privateIicfg;  public void writeJsonDebugFile(String filename) {publicvoidwriteJsonDebugFile(Stringfilename){ try {try{ FileWriter writer = new FileWriter(filename);FileWriterwriter=newFileWriter(filename); StringBuilder builder = new StringBuilder();StringBuilderbuilder=newStringBuilder(); builder.append("var root=");builder.append("var root="); root.write(builder, 0);root.write(builder,0); writer.write(builder.toString());writer.write(builder.toString()); writer.close();writer.close(); } catch (IOException e) {}catch(IOExceptione){ e.printStackTrace();e.printStackTrace(); }} }}  /* (non-Javadoc)/* (non-Javadoc)	 * @see heros.alias.Debugger#setICFG(I)	 * @see heros.alias.Debugger#setICFG(I)	 */	 */ @Override@Override public void setICFG(I icfg) {publicvoidsetICFG(Iicfg){ this.icfg = icfg;this.icfg=icfg; }} /* (non-Javadoc)/* (non-Javadoc)	 * @see heros.alias.Debugger#initialSeed(Stmt)	 * @see heros.alias.Debugger#initialSeed(Stmt)	 */	 */ @Override@Override public void initialSeed(Stmt stmt) {publicvoidinitialSeed(Stmtstmt){ stmt(stmt).keyValue("seed", "true");stmt(stmt).keyValue("seed","true");  includeSuccessors(stmt, Sets.<Stmt> newHashSet());includeSuccessors(stmt,Sets.<Stmt>newHashSet()); }}  private void includeSuccessors(Stmt stmt, Set<Stmt> visited) {privatevoidincludeSuccessors(Stmtstmt,Set<Stmt>visited){ if(!visited.add(stmt))if(!visited.add(stmt)) return;return;  JsonDocument doc = stmt(stmt);JsonDocumentdoc=stmt(stmt); for(Stmt succ : icfg.getSuccsOf(stmt)) {for(Stmtsucc:icfg.getSuccsOf(stmt)){ doc.array("successors").add(succ.toString());doc.array("successors").add(succ.toString()); stmt(succ);stmt(succ); includeSuccessors(succ, visited);includeSuccessors(succ,visited); }}  if(icfg.isCallStmt(stmt)) {if(icfg.isCallStmt(stmt)){ for(Method m : icfg.getCalleesOfCallAt(stmt)) {for(Methodm:icfg.getCalleesOfCallAt(stmt)){ doc.doc("calls").doc(m.toString());doc.doc("calls").doc(m.toString()); for(Stmt sp : icfg.getStartPointsOf(m)) {for(Stmtsp:icfg.getStartPointsOf(m)){ stmt(sp).keyValue("startPoint", "true");stmt(sp).keyValue("startPoint","true"); includeSuccessors(sp, visited);includeSuccessors(sp,visited); }} }} for(Stmt retSite :icfg.getReturnSitesOfCallAt(stmt)) {for(StmtretSite:icfg.getReturnSitesOfCallAt(stmt)){ doc.array("successors").add(retSite.toString());doc.array("successors").add(retSite.toString()); stmt(retSite);stmt(retSite); includeSuccessors(retSite, visited);includeSuccessors(retSite,visited); }} }} if(icfg.isExitStmt(stmt)) {if(icfg.isExitStmt(stmt)){ for(Stmt callSite : icfg.getCallersOf(icfg.getMethodOf(stmt))) {for(StmtcallSite:icfg.getCallersOf(icfg.getMethodOf(stmt))){ for(Stmt retSite : icfg.getReturnSitesOfCallAt(callSite)) {for(StmtretSite:icfg.getReturnSitesOfCallAt(callSite)){ doc.doc("returns").doc(retSite.toString());doc.doc("returns").doc(retSite.toString()); includeSuccessors(retSite, visited);includeSuccessors(retSite,visited); }} }} }} }} protected JsonDocument stmt(Stmt stmt) {protectedJsonDocumentstmt(Stmtstmt){ Method methodOf = icfg.getMethodOf(stmt);MethodmethodOf=icfg.getMethodOf(stmt); return root.doc("methods").doc(methodOf.toString()).doc(stmt.toString());returnroot.doc("methods").doc(methodOf.toString()).doc(stmt.toString()); }}  public void expectNormalFlow(Stmt unit, String expectedFlowFunctionsToString) {publicvoidexpectNormalFlow(Stmtunit,StringexpectedFlowFunctionsToString){ stmt(unit).keyValue("flow", expectedFlowFunctionsToString);stmt(unit).keyValue("flow",expectedFlowFunctionsToString); }} public void expectCallFlow(Stmt callSite, Method destinationMethod, String expectedFlowFunctionsToString) {publicvoidexpectCallFlow(StmtcallSite,MethoddestinationMethod,StringexpectedFlowFunctionsToString){ stmt(callSite).doc("calls").doc(destinationMethod.toString()).keyValue("flow", expectedFlowFunctionsToString);stmt(callSite).doc("calls").doc(destinationMethod.toString()).keyValue("flow",expectedFlowFunctionsToString); }} public void expectReturnFlow(Stmt exitStmt, Stmt returnSite, String expectedFlowFunctionsToString) {publicvoidexpectReturnFlow(StmtexitStmt,StmtreturnSite,StringexpectedFlowFunctionsToString){ if(returnSite != null)if(returnSite!=null) stmt(exitStmt).doc("returns").doc(returnSite.toString()).keyValue("flow", expectedFlowFunctionsToString);stmt(exitStmt).doc("returns").doc(returnSite.toString()).keyValue("flow",expectedFlowFunctionsToString); }} static void tabs(int tabs, StringBuilder builder) {staticvoidtabs(inttabs,StringBuilderbuilder){ for(int i=0; i<tabs; i++)for(inti=0;i<tabs;i++) builder.append("\t");builder.append("\t"); }}}}








src/heros/alias/Transition.java








View file @ 3398e46f






......@@ -72,14 +72,16 @@ public interface Transition<FieldRef> {









 } else {










 Set<FieldRef> otherExcludedFields = ((ExclusionPathTransition<FieldRef>) t).excludedFields;










 boolean intersection = false;










 boolean containsAll = true;










 boolean containsAll = excludedFields.containsAll(otherExcludedFields);










 boolean oppositeContainsAll = otherExcludedFields.containsAll(excludedFields);










 for(FieldRef field : excludedFields) {










 if(otherExcludedFields.contains(field))










 if(otherExcludedFields.contains(field)) {










 intersection = true;










 else










  containsAll = false;










  break;










 }










 }










 return new MatchResult<>(containsAll || !intersection, containsAll);










 boolean potentialMatch = oppositeContainsAll || !intersection || (!containsAll && !oppositeContainsAll);










 return new MatchResult<>(potentialMatch, oppositeContainsAll);










 }










 










 return new MatchResult<>(false, false);



......












src/heros/alias/Transition.java








View file @ 3398e46f








src/heros/alias/Transition.java










View file @ 3398e46f


3398e46f



......@@ -72,14 +72,16 @@ public interface Transition<FieldRef> {









 } else {










 Set<FieldRef> otherExcludedFields = ((ExclusionPathTransition<FieldRef>) t).excludedFields;










 boolean intersection = false;










 boolean containsAll = true;










 boolean containsAll = excludedFields.containsAll(otherExcludedFields);










 boolean oppositeContainsAll = otherExcludedFields.containsAll(excludedFields);










 for(FieldRef field : excludedFields) {










 if(otherExcludedFields.contains(field))










 if(otherExcludedFields.contains(field)) {










 intersection = true;










 else










  containsAll = false;










  break;










 }










 }










 return new MatchResult<>(containsAll || !intersection, containsAll);










 boolean potentialMatch = oppositeContainsAll || !intersection || (!containsAll && !oppositeContainsAll);










 return new MatchResult<>(potentialMatch, oppositeContainsAll);










 }










 










 return new MatchResult<>(false, false);



......






......@@ -72,14 +72,16 @@ public interface Transition<FieldRef> {









 } else {










 Set<FieldRef> otherExcludedFields = ((ExclusionPathTransition<FieldRef>) t).excludedFields;










 boolean intersection = false;










 boolean containsAll = true;










 boolean containsAll = excludedFields.containsAll(otherExcludedFields);










 boolean oppositeContainsAll = otherExcludedFields.containsAll(excludedFields);










 for(FieldRef field : excludedFields) {










 if(otherExcludedFields.contains(field))










 if(otherExcludedFields.contains(field)) {










 intersection = true;










 else










  containsAll = false;










  break;










 }










 }










 return new MatchResult<>(containsAll || !intersection, containsAll);










 boolean potentialMatch = oppositeContainsAll || !intersection || (!containsAll && !oppositeContainsAll);










 return new MatchResult<>(potentialMatch, oppositeContainsAll);










 }










 










 return new MatchResult<>(false, false);



......


 } else {}else{ Set<FieldRef> otherExcludedFields = ((ExclusionPathTransition<FieldRef>) t).excludedFields;Set<FieldRef>otherExcludedFields=((ExclusionPathTransition<FieldRef>)t).excludedFields; boolean intersection = false;booleanintersection=false; boolean containsAll = true;booleancontainsAll=true; boolean containsAll = excludedFields.containsAll(otherExcludedFields);booleancontainsAll=excludedFields.containsAll(otherExcludedFields); boolean oppositeContainsAll = otherExcludedFields.containsAll(excludedFields);booleanoppositeContainsAll=otherExcludedFields.containsAll(excludedFields); for(FieldRef field : excludedFields) {for(FieldReffield:excludedFields){ if(otherExcludedFields.contains(field))if(otherExcludedFields.contains(field)) if(otherExcludedFields.contains(field)) {if(otherExcludedFields.contains(field)) {{ intersection = true;intersection=true; elseelseelse  containsAll = false; containsAllcontainsAll == falsefalse;;  break; breakbreak;; }}} }} return new MatchResult<>(containsAll || !intersection, containsAll);returnnewMatchResult<>(containsAll||!intersection,containsAll); boolean potentialMatch = oppositeContainsAll || !intersection || (!containsAll && !oppositeContainsAll);booleanpotentialMatch=oppositeContainsAll||!intersection||(!containsAll&&!oppositeContainsAll); return new MatchResult<>(potentialMatch, oppositeContainsAll);returnnewMatchResult<>(potentialMatch,oppositeContainsAll); }}  return new MatchResult<>(false, false);returnnewMatchResult<>(false,false);








test/heros/alias/Fact.java

→

src/heros/alias/WrappedFact.java








View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at



......@@ -10,87 +10,58 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;





















import java.util.ArrayList;










import java.util.Arrays;










import java.util.regex.Matcher;










import java.util.regex.Pattern;










public class WrappedFact<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method>{





















import com.google.common.base.Joiner;










import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, TestFieldRef, Fact> {





















 public final String baseValue;










 public final AccessPath<TestFieldRef> accessPath;










 private final Fact fact;










 private final AccessPath<Field> accessPath;










 private final Resolver<Field, Fact, Stmt, Method> resolver;










 










 public Fact(String name) {










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 AccessPath<TestFieldRef> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();










 baseValue = name.substring(0, firstSeparator);










 matcher.reset();










 WrappedFact(Fact fact, AccessPath<Field> accessPath, Resolver<Field, Fact, Stmt, Method> resolver) {










 assert fact != null;










 assert accessPath != null;










 assert resolver != null;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(separator.equals(".")) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(new TestFieldRef(identifier));










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 TestFieldRef[] fExcl = new TestFieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new TestFieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 }










 }










 this.fact = fact;










 this.accessPath = accessPath;










 this.resolver = resolver;










 }










 










 public Fact(String baseValue, AccessPath<TestFieldRef> accessPath) {










 this.baseValue = baseValue;










 this.accessPath = accessPath;










 public Fact getFact() {










 return fact;










 }










 










 @Override










 public String toString() {










 return "[Fact "+baseValue+(accessPath.isEmpty() ? "" : accessPath)+"]";










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta, boolean merge) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath, merge), resolver); //TODO keep resolver?










 }





















 @Override










 public String getBaseValue() {










 return baseValue;










 }





















 @Override










 public AccessPath<TestFieldRef> getAccessPath() {










 public AccessPath<Field> getAccessPath() {










 return accessPath;










 }





















 @Override










 public void addNeighbor(Fact originalAbstraction) {










 










 










 public WrappedFact<Field, Fact, Stmt, Method> applyConstraint(Constraint<Field> constraint, Fact zeroValue, boolean sourceFact) {










 if(fact.equals(zeroValue))










 return this;










 else










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath, sourceFact), resolver);










 }





















 










 @Override










 public void setCallingContext(Fact callingContext) {










 










 public String toString() {










 String result = fact.toString()+accessPath;










 if(resolver != null)










 result+=resolver.toString();










 return result;










 }





















 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((accessPath == null) ? 0 : accessPath.hashCode());










 result = prime * result + ((baseValue == null) ? 0 : baseValue.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -100,25 +71,29 @@ public class Fact implements FieldSensitiveFact<String, TestFieldRef, Fact> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof Fact))










 if (getClass() != obj.getClass())










 return false;










 Fact other = (Fact) obj;










 WrappedFact other = (WrappedFact) obj;










 if (accessPath == null) {










 if (other.accessPath != null)










 return false;










 } else if (!accessPath.equals(other.accessPath))










 return false;










 if (baseValue == null) {










 if (other.baseValue != null)










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!baseValue.equals(other.baseValue))










 } else if (!fact.equals(other.fact))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }





















 @Override










 public Fact cloneWithAccessPath(AccessPath<TestFieldRef> accessPath) {










 return new Fact(baseValue, accessPath);










 public Resolver<Field, Fact, Stmt, Method> getResolver() {










 return resolver;










 }










 










 



......












test/heros/alias/Fact.java

→

src/heros/alias/WrappedFact.java








View file @ 3398e46f








test/heros/alias/Fact.java

→

src/heros/alias/WrappedFact.java





testsrcWrapped




View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at



......@@ -10,87 +10,58 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;





















import java.util.ArrayList;










import java.util.Arrays;










import java.util.regex.Matcher;










import java.util.regex.Pattern;










public class WrappedFact<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method>{





















import com.google.common.base.Joiner;










import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, TestFieldRef, Fact> {





















 public final String baseValue;










 public final AccessPath<TestFieldRef> accessPath;










 private final Fact fact;










 private final AccessPath<Field> accessPath;










 private final Resolver<Field, Fact, Stmt, Method> resolver;










 










 public Fact(String name) {










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 AccessPath<TestFieldRef> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();










 baseValue = name.substring(0, firstSeparator);










 matcher.reset();










 WrappedFact(Fact fact, AccessPath<Field> accessPath, Resolver<Field, Fact, Stmt, Method> resolver) {










 assert fact != null;










 assert accessPath != null;










 assert resolver != null;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(separator.equals(".")) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(new TestFieldRef(identifier));










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 TestFieldRef[] fExcl = new TestFieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new TestFieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 }










 }










 this.fact = fact;










 this.accessPath = accessPath;










 this.resolver = resolver;










 }










 










 public Fact(String baseValue, AccessPath<TestFieldRef> accessPath) {










 this.baseValue = baseValue;










 this.accessPath = accessPath;










 public Fact getFact() {










 return fact;










 }










 










 @Override










 public String toString() {










 return "[Fact "+baseValue+(accessPath.isEmpty() ? "" : accessPath)+"]";










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta, boolean merge) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath, merge), resolver); //TODO keep resolver?










 }





















 @Override










 public String getBaseValue() {










 return baseValue;










 }





















 @Override










 public AccessPath<TestFieldRef> getAccessPath() {










 public AccessPath<Field> getAccessPath() {










 return accessPath;










 }





















 @Override










 public void addNeighbor(Fact originalAbstraction) {










 










 










 public WrappedFact<Field, Fact, Stmt, Method> applyConstraint(Constraint<Field> constraint, Fact zeroValue, boolean sourceFact) {










 if(fact.equals(zeroValue))










 return this;










 else










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath, sourceFact), resolver);










 }





















 










 @Override










 public void setCallingContext(Fact callingContext) {










 










 public String toString() {










 String result = fact.toString()+accessPath;










 if(resolver != null)










 result+=resolver.toString();










 return result;










 }





















 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((accessPath == null) ? 0 : accessPath.hashCode());










 result = prime * result + ((baseValue == null) ? 0 : baseValue.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -100,25 +71,29 @@ public class Fact implements FieldSensitiveFact<String, TestFieldRef, Fact> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof Fact))










 if (getClass() != obj.getClass())










 return false;










 Fact other = (Fact) obj;










 WrappedFact other = (WrappedFact) obj;










 if (accessPath == null) {










 if (other.accessPath != null)










 return false;










 } else if (!accessPath.equals(other.accessPath))










 return false;










 if (baseValue == null) {










 if (other.baseValue != null)










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!baseValue.equals(other.baseValue))










 } else if (!fact.equals(other.fact))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }





















 @Override










 public Fact cloneWithAccessPath(AccessPath<TestFieldRef> accessPath) {










 return new Fact(baseValue, accessPath);










 public Resolver<Field, Fact, Stmt, Method> getResolver() {










 return resolver;










 }










 










 



......













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at



......@@ -10,87 +10,58 @@









 ******************************************************************************/










package heros.alias;





















import heros.alias.FlowFunction.Constraint;





















import java.util.ArrayList;










import java.util.Arrays;










import java.util.regex.Matcher;










import java.util.regex.Pattern;










public class WrappedFact<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method>{





















import com.google.common.base.Joiner;










import com.google.common.collect.Lists;
































public class Fact implements FieldSensitiveFact<String, TestFieldRef, Fact> {





















 public final String baseValue;










 public final AccessPath<TestFieldRef> accessPath;










 private final Fact fact;










 private final AccessPath<Field> accessPath;










 private final Resolver<Field, Fact, Stmt, Method> resolver;










 










 public Fact(String name) {










 Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(name);










 AccessPath<TestFieldRef> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 int firstSeparator = matcher.find() ? matcher.start() : name.length();










 baseValue = name.substring(0, firstSeparator);










 matcher.reset();










 WrappedFact(Fact fact, AccessPath<Field> accessPath, Resolver<Field, Fact, Stmt, Method> resolver) {










 assert fact != null;










 assert accessPath != null;










 assert resolver != null;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(separator.equals(".")) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(new TestFieldRef(identifier));










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 TestFieldRef[] fExcl = new TestFieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new TestFieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 }










 }










 this.fact = fact;










 this.accessPath = accessPath;










 this.resolver = resolver;










 }










 










 public Fact(String baseValue, AccessPath<TestFieldRef> accessPath) {










 this.baseValue = baseValue;










 this.accessPath = accessPath;










 public Fact getFact() {










 return fact;










 }










 










 @Override










 public String toString() {










 return "[Fact "+baseValue+(accessPath.isEmpty() ? "" : accessPath)+"]";










 public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta, boolean merge) {










 return new WrappedFact<>(fact, delta.applyTo(accessPath, merge), resolver); //TODO keep resolver?










 }





















 @Override










 public String getBaseValue() {










 return baseValue;










 }





















 @Override










 public AccessPath<TestFieldRef> getAccessPath() {










 public AccessPath<Field> getAccessPath() {










 return accessPath;










 }





















 @Override










 public void addNeighbor(Fact originalAbstraction) {










 










 










 public WrappedFact<Field, Fact, Stmt, Method> applyConstraint(Constraint<Field> constraint, Fact zeroValue, boolean sourceFact) {










 if(fact.equals(zeroValue))










 return this;










 else










 return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath, sourceFact), resolver);










 }





















 










 @Override










 public void setCallingContext(Fact callingContext) {










 










 public String toString() {










 String result = fact.toString()+accessPath;










 if(resolver != null)










 result+=resolver.toString();










 return result;










 }





















 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((accessPath == null) ? 0 : accessPath.hashCode());










 result = prime * result + ((baseValue == null) ? 0 : baseValue.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());










 return result;










 }














......@@ -100,25 +71,29 @@ public class Fact implements FieldSensitiveFact<String, TestFieldRef, Fact> {









 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof Fact))










 if (getClass() != obj.getClass())










 return false;










 Fact other = (Fact) obj;










 WrappedFact other = (WrappedFact) obj;










 if (accessPath == null) {










 if (other.accessPath != null)










 return false;










 } else if (!accessPath.equals(other.accessPath))










 return false;










 if (baseValue == null) {










 if (other.baseValue != null)










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!baseValue.equals(other.baseValue))










 } else if (!fact.equals(other.fact))










 return false;










 if (resolver == null) {










 if (other.resolver != null)










 return false;










 } else if (!resolver.equals(other.resolver))










 return false;










 return true;










 }





















 @Override










 public Fact cloneWithAccessPath(AccessPath<TestFieldRef> accessPath) {










 return new Fact(baseValue, accessPath);










 public Resolver<Field, Fact, Stmt, Method> getResolver() {










 return resolver;










 }










 










 



......


/*******************************************************************************/******************************************************************************* * Copyright (c) 2014 Johannes Lerch. * Copyright (c) 2014 Johannes Lerch.4 * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch.5 * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.alias.FlowFunction.Constraint;importheros.alias.FlowFunction.Constraint;import java.util.ArrayList;importjava.util.ArrayList;import java.util.Arrays;importjava.util.Arrays;import java.util.regex.Matcher;importjava.util.regex.Matcher;import java.util.regex.Pattern;importjava.util.regex.Pattern;public class WrappedFact<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method>{publicclassWrappedFact<FieldextendsAccessPath.FieldRef<Field>,Fact,Stmt,Method>{import com.google.common.base.Joiner;importcom.google.common.base.Joiner;import com.google.common.collect.Lists;importcom.google.common.collect.Lists;public class Fact implements FieldSensitiveFact<String, TestFieldRef, Fact> {publicclassFactimplementsFieldSensitiveFact<String,TestFieldRef,Fact>{ public final String baseValue;publicfinalStringbaseValue; public final AccessPath<TestFieldRef> accessPath;publicfinalAccessPath<TestFieldRef>accessPath; private final Fact fact;privatefinalFactfact; private final AccessPath<Field> accessPath;privatefinalAccessPath<Field>accessPath; private final Resolver<Field, Fact, Stmt, Method> resolver;privatefinalResolver<Field,Fact,Stmt,Method>resolver;  public Fact(String name) {publicFact(Stringname){ Pattern pattern = Pattern.compile("(\\.|\\^)([^\\.\\^]+)");Patternpattern=Pattern.compile("(\\.|\\^)([^\\.\\^]+)"); Matcher matcher = pattern.matcher(name);Matchermatcher=pattern.matcher(name); AccessPath<TestFieldRef> accessPath = new AccessPath<>();AccessPath<TestFieldRef>accessPath=newAccessPath<>(); boolean addedExclusions = false;booleanaddedExclusions=false;  int firstSeparator = matcher.find() ? matcher.start() : name.length();intfirstSeparator=matcher.find()?matcher.start():name.length(); baseValue = name.substring(0, firstSeparator);baseValue=name.substring(0,firstSeparator); matcher.reset();matcher.reset(); WrappedFact(Fact fact, AccessPath<Field> accessPath, Resolver<Field, Fact, Stmt, Method> resolver) {WrappedFact(Factfact,AccessPath<Field>accessPath,Resolver<Field,Fact,Stmt,Method>resolver){ assert fact != null;assertfact!=null; assert accessPath != null;assertaccessPath!=null; assert resolver != null;assertresolver!=null;  while(matcher.find()) {while(matcher.find()){ String separator = matcher.group(1);Stringseparator=matcher.group(1); String identifier = matcher.group(2);Stringidentifier=matcher.group(2);  if(separator.equals(".")) {if(separator.equals(".")){ if(addedExclusions)if(addedExclusions) throw new IllegalArgumentException("Access path contains field references after exclusions.");thrownewIllegalArgumentException("Access path contains field references after exclusions."); accessPath = accessPath.addFieldReference(new TestFieldRef(identifier));accessPath=accessPath.addFieldReference(newTestFieldRef(identifier)); } else {}else{ addedExclusions=true;addedExclusions=true; String[] excl = identifier.split(",");String[]excl=identifier.split(","); TestFieldRef[] fExcl = new TestFieldRef[excl.length];TestFieldRef[]fExcl=newTestFieldRef[excl.length]; for(int i=0; i<excl.length; i++)for(inti=0;i<excl.length;i++) fExcl[i] = new TestFieldRef(excl[i]);fExcl[i]=newTestFieldRef(excl[i]); accessPath = accessPath.appendExcludedFieldReference(fExcl);accessPath=accessPath.appendExcludedFieldReference(fExcl); }} }} this.fact = fact;this.fact=fact; this.accessPath = accessPath;this.accessPath=accessPath; this.resolver = resolver;this.resolver=resolver; }}  public Fact(String baseValue, AccessPath<TestFieldRef> accessPath) {publicFact(StringbaseValue,AccessPath<TestFieldRef>accessPath){ this.baseValue = baseValue;this.baseValue=baseValue; this.accessPath = accessPath;this.accessPath=accessPath; public Fact getFact() {publicFactgetFact(){ return fact;returnfact; }}  @Override@Override public String toString() {publicStringtoString(){ return "[Fact "+baseValue+(accessPath.isEmpty() ? "" : accessPath)+"]";return"[Fact "+baseValue+(accessPath.isEmpty()?"":accessPath)+"]"; public WrappedFact<Field, Fact, Stmt, Method> applyDelta(AccessPath.Delta<Field> delta, boolean merge) {publicWrappedFact<Field,Fact,Stmt,Method>applyDelta(AccessPath.Delta<Field>delta,booleanmerge){ return new WrappedFact<>(fact, delta.applyTo(accessPath, merge), resolver); //TODO keep resolver?returnnewWrappedFact<>(fact,delta.applyTo(accessPath,merge),resolver);//TODO keep resolver? }} @Override@Override public String getBaseValue() {publicStringgetBaseValue(){ return baseValue;returnbaseValue; }} @Override@Override public AccessPath<TestFieldRef> getAccessPath() {publicAccessPath<TestFieldRef>getAccessPath(){ public AccessPath<Field> getAccessPath() {publicAccessPath<Field>getAccessPath(){ return accessPath;returnaccessPath; }} @Override@Override public void addNeighbor(Fact originalAbstraction) {publicvoidaddNeighbor(FactoriginalAbstraction){   public WrappedFact<Field, Fact, Stmt, Method> applyConstraint(Constraint<Field> constraint, Fact zeroValue, boolean sourceFact) {publicWrappedFact<Field,Fact,Stmt,Method>applyConstraint(Constraint<Field>constraint,FactzeroValue,booleansourceFact){ if(fact.equals(zeroValue))if(fact.equals(zeroValue)) return this;returnthis; elseelse return new WrappedFact<>(fact, constraint.applyToAccessPath(accessPath, sourceFact), resolver);returnnewWrappedFact<>(fact,constraint.applyToAccessPath(accessPath,sourceFact),resolver); }}  @Override@Override public void setCallingContext(Fact callingContext) {publicvoidsetCallingContext(FactcallingContext){  public String toString() {publicStringtoString(){ String result = fact.toString()+accessPath;Stringresult=fact.toString()+accessPath; if(resolver != null)if(resolver!=null) result+=resolver.toString();result+=resolver.toString(); return result;returnresult; }}  @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + ((accessPath == null) ? 0 : accessPath.hashCode());result=prime*result+((accessPath==null)?0:accessPath.hashCode()); result = prime * result + ((baseValue == null) ? 0 : baseValue.hashCode());result=prime*result+((baseValue==null)?0:baseValue.hashCode()); result = prime * result + ((fact == null) ? 0 : fact.hashCode());result=prime*result+((fact==null)?0:fact.hashCode()); result = prime * result + ((resolver == null) ? 0 : resolver.hashCode());result=prime*result+((resolver==null)?0:resolver.hashCode()); return result;returnresult; }} return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (!(obj instanceof Fact))if(!(!(objobj instanceofinstanceof FactFact)) if (getClass() != obj.getClass())if(getClassgetClass()() !=!= objobj..getClassgetClass())( return false;returnfalse; Fact other = (Fact) obj;Factother=(Fact)obj; WrappedFact other = (WrappedFact) obj;WrappedFactWrappedother=(WrappedFactWrapped)obj; if (accessPath == null) {if(accessPath==null){ if (other.accessPath != null)if(other.accessPath!=null) return false;returnfalse; } else if (!accessPath.equals(other.accessPath))}elseif(!accessPath.equals(other.accessPath)) return false;returnfalse; if (baseValue == null) {if(baseValuebaseValue==null){ if (other.baseValue != null)if(other.baseValuebaseValue!=null) if (fact == null) {if(factfact==null){ if (other.fact != null)if(other.factfact!=null) return false;returnfalse; } else if (!baseValue.equals(other.baseValue))}elseif(!baseValue.equals(other.baseValue)) } else if (!fact.equals(other.fact))}elseif(!fact.equals(other.fact)) return false;returnfalse; if (resolver == null) {if(resolver==null){ if (other.resolver != null)if(other.resolver!=null) return false;returnfalse; } else if (!resolver.equals(other.resolver))}elseif(!resolver.equals(other.resolver)) return false;returnfalse; return true;returntrue; }} @Override@Override public Fact cloneWithAccessPath(AccessPath<TestFieldRef> accessPath) {publicFactcloneWithAccessPath(AccessPath<TestFieldRef>accessPath){ return new Fact(baseValue, accessPath);returnnewFact(baseValue,accessPath); public Resolver<Field, Fact, Stmt, Method> getResolver() {publicResolver<Field,Fact,Stmt,Method>getResolver(){ return resolver;returnresolver; }}  








src/heros/alias/SummaryEdge.java

→

src/heros/alias/WrappedFactAtStatement.java








View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at



......@@ -10,70 +10,66 @@









 ******************************************************************************/










package heros.alias;





















public class SummaryEdge<D, N> {










public class WrappedFactAtStatement<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private D sourceFact;










 private N targetStmt;










 private D targetFact;










 private WrappedFact<Field,Fact, Stmt, Method> fact;










 private Stmt stmt;





















 public WrappedFactAtStatement(Stmt stmt, WrappedFact<Field, Fact, Stmt, Method> fact) {










 this.stmt = stmt;










 this.fact = fact;










 }





















 public WrappedFact<Field,Fact, Stmt, Method> getFact() {










 return fact;










 }





















 public Stmt getStatement() {










 return stmt;










 }










 










 public FactAtStatement<Fact, Stmt> getAsFactAtStatement() {










 return new FactAtStatement<Fact, Stmt>(fact.getFact(), stmt);










 }










 










 public SummaryEdge(D sourceFact, N targetStmt, D targetFact) {










 this.sourceFact = sourceFact;










 this.targetStmt = targetStmt;










 this.targetFact = targetFact;










 public boolean canDeltaBeApplied(AccessPath.Delta<Field> delta) {










 return delta.canBeAppliedTo(fact.getAccessPath());










 }










 










 @Override










 public String toString() {










 return "[SummaryEdge: "+sourceFact+" -> "+targetFact+" @stmt: "+targetStmt+"]";










 return fact+" @ "+stmt;










 }





















 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((sourceFact == null) ? 0 : sourceFact.hashCode());










 result = prime * result + ((targetFact == null) ? 0 : targetFact.hashCode());










 result = prime * result + ((targetStmt == null) ? 0 : targetStmt.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((stmt == null) ? 0 : stmt.hashCode());










 return result;










 }










 





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SummaryEdge))










 if (getClass() != obj.getClass())










 return false;










 SummaryEdge other = (SummaryEdge) obj;










 if (sourceFact == null) {










 if (other.sourceFact != null)










 WrappedFactAtStatement other = (WrappedFactAtStatement) obj;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!sourceFact.equals(other.sourceFact))










 } else if (!fact.equals(other.fact))










 return false;










 if (targetFact == null) {










 if (other.targetFact != null)










 if (stmt == null) {










 if (other.stmt != null)










 return false;










 } else if (!targetFact.equals(other.targetFact))










 return false;










 if (targetStmt == null) {










 if (other.targetStmt != null)










 return false;










 } else if (!targetStmt.equals(other.targetStmt))










 } else if (!stmt.equals(other.stmt))










 return false;










 return true;










 }





















 public D getSourceFact() {










 return sourceFact;










 }










 










 public D getTargetFact() {










 return targetFact;










 }










 










 public N getTargetStmt() {










 return targetStmt;










 }










 










}












src/heros/alias/SummaryEdge.java

→

src/heros/alias/WrappedFactAtStatement.java








View file @ 3398e46f








src/heros/alias/SummaryEdge.java

→

src/heros/alias/WrappedFactAtStatement.java





SummaryEdgeWrappedFactAtStatement




View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at



......@@ -10,70 +10,66 @@









 ******************************************************************************/










package heros.alias;





















public class SummaryEdge<D, N> {










public class WrappedFactAtStatement<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private D sourceFact;










 private N targetStmt;










 private D targetFact;










 private WrappedFact<Field,Fact, Stmt, Method> fact;










 private Stmt stmt;





















 public WrappedFactAtStatement(Stmt stmt, WrappedFact<Field, Fact, Stmt, Method> fact) {










 this.stmt = stmt;










 this.fact = fact;










 }





















 public WrappedFact<Field,Fact, Stmt, Method> getFact() {










 return fact;










 }





















 public Stmt getStatement() {










 return stmt;










 }










 










 public FactAtStatement<Fact, Stmt> getAsFactAtStatement() {










 return new FactAtStatement<Fact, Stmt>(fact.getFact(), stmt);










 }










 










 public SummaryEdge(D sourceFact, N targetStmt, D targetFact) {










 this.sourceFact = sourceFact;










 this.targetStmt = targetStmt;










 this.targetFact = targetFact;










 public boolean canDeltaBeApplied(AccessPath.Delta<Field> delta) {










 return delta.canBeAppliedTo(fact.getAccessPath());










 }










 










 @Override










 public String toString() {










 return "[SummaryEdge: "+sourceFact+" -> "+targetFact+" @stmt: "+targetStmt+"]";










 return fact+" @ "+stmt;










 }





















 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((sourceFact == null) ? 0 : sourceFact.hashCode());










 result = prime * result + ((targetFact == null) ? 0 : targetFact.hashCode());










 result = prime * result + ((targetStmt == null) ? 0 : targetStmt.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((stmt == null) ? 0 : stmt.hashCode());










 return result;










 }










 





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SummaryEdge))










 if (getClass() != obj.getClass())










 return false;










 SummaryEdge other = (SummaryEdge) obj;










 if (sourceFact == null) {










 if (other.sourceFact != null)










 WrappedFactAtStatement other = (WrappedFactAtStatement) obj;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!sourceFact.equals(other.sourceFact))










 } else if (!fact.equals(other.fact))










 return false;










 if (targetFact == null) {










 if (other.targetFact != null)










 if (stmt == null) {










 if (other.stmt != null)










 return false;










 } else if (!targetFact.equals(other.targetFact))










 return false;










 if (targetStmt == null) {










 if (other.targetStmt != null)










 return false;










 } else if (!targetStmt.equals(other.targetStmt))










 } else if (!stmt.equals(other.stmt))










 return false;










 return true;










 }





















 public D getSourceFact() {










 return sourceFact;










 }










 










 public D getTargetFact() {










 return targetFact;










 }










 










 public N getTargetStmt() {










 return targetStmt;










 }










 










}













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at



......@@ -10,70 +10,66 @@









 ******************************************************************************/










package heros.alias;





















public class SummaryEdge<D, N> {










public class WrappedFactAtStatement<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {





















 private D sourceFact;










 private N targetStmt;










 private D targetFact;










 private WrappedFact<Field,Fact, Stmt, Method> fact;










 private Stmt stmt;





















 public WrappedFactAtStatement(Stmt stmt, WrappedFact<Field, Fact, Stmt, Method> fact) {










 this.stmt = stmt;










 this.fact = fact;










 }





















 public WrappedFact<Field,Fact, Stmt, Method> getFact() {










 return fact;










 }





















 public Stmt getStatement() {










 return stmt;










 }










 










 public FactAtStatement<Fact, Stmt> getAsFactAtStatement() {










 return new FactAtStatement<Fact, Stmt>(fact.getFact(), stmt);










 }










 










 public SummaryEdge(D sourceFact, N targetStmt, D targetFact) {










 this.sourceFact = sourceFact;










 this.targetStmt = targetStmt;










 this.targetFact = targetFact;










 public boolean canDeltaBeApplied(AccessPath.Delta<Field> delta) {










 return delta.canBeAppliedTo(fact.getAccessPath());










 }










 










 @Override










 public String toString() {










 return "[SummaryEdge: "+sourceFact+" -> "+targetFact+" @stmt: "+targetStmt+"]";










 return fact+" @ "+stmt;










 }





















 










 @Override










 public int hashCode() {










 final int prime = 31;










 int result = 1;










 result = prime * result + ((sourceFact == null) ? 0 : sourceFact.hashCode());










 result = prime * result + ((targetFact == null) ? 0 : targetFact.hashCode());










 result = prime * result + ((targetStmt == null) ? 0 : targetStmt.hashCode());










 result = prime * result + ((fact == null) ? 0 : fact.hashCode());










 result = prime * result + ((stmt == null) ? 0 : stmt.hashCode());










 return result;










 }










 





















 @Override










 public boolean equals(Object obj) {










 if (this == obj)










 return true;










 if (obj == null)










 return false;










 if (!(obj instanceof SummaryEdge))










 if (getClass() != obj.getClass())










 return false;










 SummaryEdge other = (SummaryEdge) obj;










 if (sourceFact == null) {










 if (other.sourceFact != null)










 WrappedFactAtStatement other = (WrappedFactAtStatement) obj;










 if (fact == null) {










 if (other.fact != null)










 return false;










 } else if (!sourceFact.equals(other.sourceFact))










 } else if (!fact.equals(other.fact))










 return false;










 if (targetFact == null) {










 if (other.targetFact != null)










 if (stmt == null) {










 if (other.stmt != null)










 return false;










 } else if (!targetFact.equals(other.targetFact))










 return false;










 if (targetStmt == null) {










 if (other.targetStmt != null)










 return false;










 } else if (!targetStmt.equals(other.targetStmt))










 } else if (!stmt.equals(other.stmt))










 return false;










 return true;










 }





















 public D getSourceFact() {










 return sourceFact;










 }










 










 public D getTargetFact() {










 return targetFact;










 }










 










 public N getTargetStmt() {










 return targetStmt;










 }










 










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2014 Johannes Lerch. * Copyright (c) 2014 Johannes Lerch.4 * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch.5 * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;public class SummaryEdge<D, N> {publicclassSummaryEdgeSummaryEdge<<DD,, NN>{public class WrappedFactAtStatement<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> {publicclassWrappedFactAtStatementWrappedFactAtStatement<<FieldField extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldField>,>, FactFact,, StmtStmt,, MethodMethod>{ private D sourceFact;privateDsourceFact; private N targetStmt;privateNtargetStmt; private D targetFact;privateDtargetFact; private WrappedFact<Field,Fact, Stmt, Method> fact;privateWrappedFact<Field,Fact,Stmt,Method>fact; private Stmt stmt;privateStmtstmt; public WrappedFactAtStatement(Stmt stmt, WrappedFact<Field, Fact, Stmt, Method> fact) {publicWrappedFactAtStatement(Stmtstmt,WrappedFact<Field,Fact,Stmt,Method>fact){ this.stmt = stmt;this.stmt=stmt; this.fact = fact;this.fact=fact; }} public WrappedFact<Field,Fact, Stmt, Method> getFact() {publicWrappedFact<Field,Fact,Stmt,Method>getFact(){ return fact;returnfact; }} public Stmt getStatement() {publicStmtgetStatement(){ return stmt;returnstmt; }}  public FactAtStatement<Fact, Stmt> getAsFactAtStatement() {publicFactAtStatement<Fact,Stmt>getAsFactAtStatement(){ return new FactAtStatement<Fact, Stmt>(fact.getFact(), stmt);returnnewFactAtStatement<Fact,Stmt>(fact.getFact(),stmt); }}  public SummaryEdge(D sourceFact, N targetStmt, D targetFact) {publicSummaryEdge(DsourceFact,NtargetStmt,DtargetFact){ this.sourceFact = sourceFact;this.sourceFact=sourceFact; this.targetStmt = targetStmt;this.targetStmt=targetStmt; this.targetFact = targetFact;this.targetFact=targetFact; public boolean canDeltaBeApplied(AccessPath.Delta<Field> delta) {publicbooleancanDeltaBeApplied(AccessPath.Delta<Field>delta){ return delta.canBeAppliedTo(fact.getAccessPath());returndelta.canBeAppliedTo(fact.getAccessPath()); }}  @Override@Override public String toString() {publicStringtoString(){ return "[SummaryEdge: "+sourceFact+" -> "+targetFact+" @stmt: "+targetStmt+"]";return"[SummaryEdge: ""[SummaryEdge: "++sourceFactsourceFact++" -> "" -> "++targetFacttargetFact++" @stmt: "" @stmt: "++targetStmttargetStmt++"]""]"; return fact+" @ "+stmt;returnfactfact++" @ "" @ "++stmtstmt; }}  @Override@Override public int hashCode() {publicinthashCode(){ final int prime = 31;finalintprime=31; int result = 1;intresult=1; result = prime * result + ((sourceFact == null) ? 0 : sourceFact.hashCode());result=prime*result+((sourceFact==null)?0:sourceFact.hashCode()); result = prime * result + ((targetFact == null) ? 0 : targetFact.hashCode());result=prime*result+((targetFact==null)?0:targetFact.hashCode()); result = prime * result + ((targetStmt == null) ? 0 : targetStmt.hashCode());result=prime*result+((targetStmt==null)?0:targetStmt.hashCode()); result = prime * result + ((fact == null) ? 0 : fact.hashCode());result=prime*result+((fact==null)?0:fact.hashCode()); result = prime * result + ((stmt == null) ? 0 : stmt.hashCode());result=prime*result+((stmt==null)?0:stmt.hashCode()); return result;returnresult; }}   @Override@Override public boolean equals(Object obj) {publicbooleanequals(Objectobj){ if (this == obj)if(this==obj) return true;returntrue; if (obj == null)if(obj==null) return false;returnfalse; if (!(obj instanceof SummaryEdge))if(!(!(objobj instanceofinstanceof SummaryEdgeSummaryEdge)) if (getClass() != obj.getClass())if(getClassgetClass()() !=!= objobj..getClassgetClass())( return false;returnfalse; SummaryEdge other = (SummaryEdge) obj;SummaryEdgeSummaryEdge otherother == ((SummaryEdgeSummaryEdge)obj; if (sourceFact == null) {if(sourceFactsourceF==null){ if (other.sourceFact != null)if(other.sourceFactsourceF!=null) WrappedFactAtStatement other = (WrappedFactAtStatement) obj;WrappedFactAtStatementWrappedFactAtStatement otherother == ((WrappedFactAtStatementWrappedFactAtStatement)obj; if (fact == null) {if(factf==null){ if (other.fact != null)if(other.factf!=null) return false;returnfalse; } else if (!sourceFact.equals(other.sourceFact))}elseif(!sourceFactsourceF.equals(other.sourceFactsourceF)) } else if (!fact.equals(other.fact))}elseif(!factf.equals(other.factf)) return false;returnfalse; if (targetFact == null) {if(targetFacttargetFac==null){ if (other.targetFact != null)if(other.targetFacttargetFac!=null) if (stmt == null) {if(stmtstm==null){ if (other.stmt != null)if(other.stmtstm!=null) return false;returnfalse; } else if (!targetFact.equals(other.targetFact))}elseif(!targetFact.equals(other.targetFact)) return false;returnfalse; if (targetStmt == null) {if(targetStmt==null){ if (other.targetStmt != null)if(other.targetStmt!=null) return false;returnfalse; } else if (!targetStmt.equals(other.targetStmt))}elseif(!targetStmt.equals(other.targetStmt)) } else if (!stmt.equals(other.stmt))}elseif(!stmt.equals(other.stmt)) return false;returnfalse; return true;returntrue; }} public D getSourceFact() {publicDgetSourceFact(){ return sourceFact;returnsourceFact; }}  public D getTargetFact() {publicDgetTargetFact(){ return targetFact;returntargetFact; }}  public N getTargetStmt() {publicNgetTargetStmt(){ return targetStmt;returntargetStmt; }} }}








src/heros/alias/ZeroCallEdgeResolver.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class ZeroCallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends CallEdgeResolver<Field, Fact, Stmt, Method> {





















 private ZeroHandler<Field> zeroHandler;





















 public ZeroCallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, ZeroHandler<Field> zeroHandler) {










 super(analyzer);










 this.zeroHandler = zeroHandler;










 }





















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) {










 if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(new AccessPath<Field>(), true)))










 callback.interest(analyzer, this);










 }










 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 }










}












src/heros/alias/ZeroCallEdgeResolver.java



0 → 100644







View file @ 3398e46f








src/heros/alias/ZeroCallEdgeResolver.java



0 → 100644









View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class ZeroCallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends CallEdgeResolver<Field, Fact, Stmt, Method> {





















 private ZeroHandler<Field> zeroHandler;





















 public ZeroCallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, ZeroHandler<Field> zeroHandler) {










 super(analyzer);










 this.zeroHandler = zeroHandler;










 }





















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) {










 if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(new AccessPath<Field>(), true)))










 callback.interest(analyzer, this);










 }










 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 }










}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.alias.AccessPath.Delta;










import heros.alias.FlowFunction.Constraint;





















public class ZeroCallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends CallEdgeResolver<Field, Fact, Stmt, Method> {





















 private ZeroHandler<Field> zeroHandler;





















 public ZeroCallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, ZeroHandler<Field> zeroHandler) {










 super(analyzer);










 this.zeroHandler = zeroHandler;










 }





















 @Override










 public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) {










 if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(new AccessPath<Field>(), true)))










 callback.interest(analyzer, this);










 }










 










 @Override










 public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {










 }










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.alias.AccessPath.Delta;importheros.alias.AccessPath.Delta;import heros.alias.FlowFunction.Constraint;importheros.alias.FlowFunction.Constraint;public class ZeroCallEdgeResolver<Field extends AccessPath.FieldRef<Field>, Fact, Stmt, Method> extends CallEdgeResolver<Field, Fact, Stmt, Method> {publicclassZeroCallEdgeResolver<FieldextendsAccessPath.FieldRef<Field>,Fact,Stmt,Method>extendsCallEdgeResolver<Field,Fact,Stmt,Method>{ private ZeroHandler<Field> zeroHandler;privateZeroHandler<Field>zeroHandler; public ZeroCallEdgeResolver(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, ZeroHandler<Field> zeroHandler) {publicZeroCallEdgeResolver(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer,ZeroHandler<Field>zeroHandler){ super(analyzer);super(analyzer); this.zeroHandler = zeroHandler;this.zeroHandler=zeroHandler; }} @Override@Override public void resolve(Constraint<Field> constraint, InterestCallback<Field, Fact, Stmt, Method> callback) {publicvoidresolve(Constraint<Field>constraint,InterestCallback<Field,Fact,Stmt,Method>callback){ if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(new AccessPath<Field>(), true)))if(zeroHandler.shouldGenerateAccessPath(constraint.applyToAccessPath(newAccessPath<Field>(),true))) callback.interest(analyzer, this);callback.interest(analyzer,this); }}  @Override@Override public void interest(PerAccessPathMethodAnalyzer<Field, Fact, Stmt, Method> analyzer, Resolver<Field, Fact, Stmt, Method> resolver) {publicvoidinterest(PerAccessPathMethodAnalyzer<Field,Fact,Stmt,Method>analyzer,Resolver<Field,Fact,Stmt,Method>resolver){ }}}}








src/heros/alias/FieldSensitiveFact.java

→

src/heros/alias/ZeroHandler.java








View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch, Johannes Späth.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch, Johannes Späth - initial API and implementation










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.solver.LinkedNode;










public interface ZeroHandler<Field extends AccessPath.FieldRef<Field>> {





















public interface FieldSensitiveFact<BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D> extends LinkedNode<D>{





















 BaseValue getBaseValue();










 










 AccessPath<FieldRef> getAccessPath();










 










 D cloneWithAccessPath(AccessPath<FieldRef> accessPath);










 










 boolean shouldGenerateAccessPath(AccessPath<Field> accPath);










}












src/heros/alias/FieldSensitiveFact.java

→

src/heros/alias/ZeroHandler.java








View file @ 3398e46f








src/heros/alias/FieldSensitiveFact.java

→

src/heros/alias/ZeroHandler.java





FieldSensitiveFactZeroHandler




View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch, Johannes Späth.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch, Johannes Späth - initial API and implementation










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.solver.LinkedNode;










public interface ZeroHandler<Field extends AccessPath.FieldRef<Field>> {





















public interface FieldSensitiveFact<BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D> extends LinkedNode<D>{





















 BaseValue getBaseValue();










 










 AccessPath<FieldRef> getAccessPath();










 










 D cloneWithAccessPath(AccessPath<FieldRef> accessPath);










 










 boolean shouldGenerateAccessPath(AccessPath<Field> accPath);










}













/*******************************************************************************










 * Copyright (c) 2014 Johannes Lerch, Johannes Späth.










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch, Johannes Späth - initial API and implementation










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import heros.solver.LinkedNode;










public interface ZeroHandler<Field extends AccessPath.FieldRef<Field>> {





















public interface FieldSensitiveFact<BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D> extends LinkedNode<D>{





















 BaseValue getBaseValue();










 










 AccessPath<FieldRef> getAccessPath();










 










 D cloneWithAccessPath(AccessPath<FieldRef> accessPath);










 










 boolean shouldGenerateAccessPath(AccessPath<Field> accPath);










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2014 Johannes Lerch, Johannes Späth. * Copyright (c) 2014 Johannes Lerch, Johannes Späth.4, Johannes Späth * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch.5 * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch, Johannes Späth - initial API and implementation *     Johannes Lerch, Johannes Späth - initial API and implementation, Johannes Späth *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import heros.solver.LinkedNode;importimport heros.solver.LinkedNodeheros.solver.LinkedNode;;public interface ZeroHandler<Field extends AccessPath.FieldRef<Field>> {publicpublic interfaceinterface ZeroHandlerZeroHandler<<FieldField extendsextends AccessPathAccessPath..FieldRefFieldRef<<FieldField>>>> {{public interface FieldSensitiveFact<BaseValue, FieldRef extends AccessPath.FieldRef<FieldRef>, D> extends LinkedNode<D>{publicinterfaceFieldSensitiveFact<BaseValue,FieldRefextendsAccessPath.FieldRef<FieldRef>,D>extendsLinkedNode<D>{ BaseValue getBaseValue();BaseValuegetBaseValue();  AccessPath<FieldRef> getAccessPath();AccessPath<FieldRef>getAccessPath();  D cloneWithAccessPath(AccessPath<FieldRef> accessPath);DcloneWithAccessPath(AccessPath<FieldRef>accessPath);  boolean shouldGenerateAccessPath(AccessPath<Field> accPath);booleanshouldGenerateAccessPath(AccessPath<Field>accPath);}}








test/heros/alias/AccessPathTest.java








View file @ 3398e46f






......@@ -19,6 +19,7 @@ import org.junit.Test;




















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.SubAccessPath.*;














......@@ -36,7 +37,7 @@ public class AccessPathTest {









 }










 return result;










 }










 





















 private static SetOfPossibleFieldAccesses<TestFieldRef> anyOf(String...fields) {










 Set<TestFieldRef> set = Sets.newHashSet();










 for(String f : fields)



......@@ -49,7 +50,7 @@ public class AccessPathTest {









 }










 










 private static AccessPath<TestFieldRef> ap(SubAccessPath<TestFieldRef>... path) {










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet(), null);










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet());










 }










 










 @Test



......@@ -64,6 +65,12 @@ public class AccessPathTest {









 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMultipleFieldsAndMerge() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(f("b", "a")));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<TestFieldRef> sut = ap(s("a"));



......@@ -190,6 +197,20 @@ public class AccessPathTest {









 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaFromSetToSet() {










 Delta<TestFieldRef> actual = ap(anyOf("a")).appendExcludedFieldReference(f("f")).getDeltaTo(ap(anyOf("a")).appendExcludedFieldReference(f("g")));










 assertArrayEquals(new SubAccessPath[] { anyOf("a") }, actual.accesses);










 assertEquals(Sets.newHashSet(f("g")), actual.exclusions);










 }










 










 @Test










 public void emptyDeltaOnEqualExclusions() {










 AccessPath<TestFieldRef> actual = ap().appendExcludedFieldReference(f("f"));










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).exclusions.equals(Sets.newHashSet(f("f"))));










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;



......@@ -227,6 +248,12 @@ public class AccessPathTest {









 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void multipleExclPrefixOfMultipleExcl() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference(f("f", "h"))));










 }










 










 @Test










 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));



......












test/heros/alias/AccessPathTest.java








View file @ 3398e46f








test/heros/alias/AccessPathTest.java










View file @ 3398e46f


3398e46f



......@@ -19,6 +19,7 @@ import org.junit.Test;




















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.SubAccessPath.*;














......@@ -36,7 +37,7 @@ public class AccessPathTest {









 }










 return result;










 }










 





















 private static SetOfPossibleFieldAccesses<TestFieldRef> anyOf(String...fields) {










 Set<TestFieldRef> set = Sets.newHashSet();










 for(String f : fields)



......@@ -49,7 +50,7 @@ public class AccessPathTest {









 }










 










 private static AccessPath<TestFieldRef> ap(SubAccessPath<TestFieldRef>... path) {










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet(), null);










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet());










 }










 










 @Test



......@@ -64,6 +65,12 @@ public class AccessPathTest {









 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMultipleFieldsAndMerge() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(f("b", "a")));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<TestFieldRef> sut = ap(s("a"));



......@@ -190,6 +197,20 @@ public class AccessPathTest {









 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaFromSetToSet() {










 Delta<TestFieldRef> actual = ap(anyOf("a")).appendExcludedFieldReference(f("f")).getDeltaTo(ap(anyOf("a")).appendExcludedFieldReference(f("g")));










 assertArrayEquals(new SubAccessPath[] { anyOf("a") }, actual.accesses);










 assertEquals(Sets.newHashSet(f("g")), actual.exclusions);










 }










 










 @Test










 public void emptyDeltaOnEqualExclusions() {










 AccessPath<TestFieldRef> actual = ap().appendExcludedFieldReference(f("f"));










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).exclusions.equals(Sets.newHashSet(f("f"))));










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;



......@@ -227,6 +248,12 @@ public class AccessPathTest {









 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void multipleExclPrefixOfMultipleExcl() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference(f("f", "h"))));










 }










 










 @Test










 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));



......






......@@ -19,6 +19,7 @@ import org.junit.Test;




















import com.google.common.collect.Sets;





















import heros.alias.AccessPath.Delta;










import heros.alias.AccessPath.PrefixTestResult;










import heros.alias.SubAccessPath.*;














......@@ -36,7 +37,7 @@ public class AccessPathTest {









 }










 return result;










 }










 





















 private static SetOfPossibleFieldAccesses<TestFieldRef> anyOf(String...fields) {










 Set<TestFieldRef> set = Sets.newHashSet();










 for(String f : fields)



......@@ -49,7 +50,7 @@ public class AccessPathTest {









 }










 










 private static AccessPath<TestFieldRef> ap(SubAccessPath<TestFieldRef>... path) {










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet(), null);










 return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet());










 }










 










 @Test



......@@ -64,6 +65,12 @@ public class AccessPathTest {









 assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference(f("b")));










 }










 










 @Test










 public void addMultipleFieldsAndMerge() {










 AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a"));










 assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(f("b", "a")));










 }










 










 @Test










 public void addWithoutMerge() {










 AccessPath<TestFieldRef> sut = ap(s("a"));



......@@ -190,6 +197,20 @@ public class AccessPathTest {









 assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);










 }










 










 @Test










 public void deltaFromSetToSet() {










 Delta<TestFieldRef> actual = ap(anyOf("a")).appendExcludedFieldReference(f("f")).getDeltaTo(ap(anyOf("a")).appendExcludedFieldReference(f("g")));










 assertArrayEquals(new SubAccessPath[] { anyOf("a") }, actual.accesses);










 assertEquals(Sets.newHashSet(f("g")), actual.exclusions);










 }










 










 @Test










 public void emptyDeltaOnEqualExclusions() {










 AccessPath<TestFieldRef> actual = ap().appendExcludedFieldReference(f("f"));










 assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).accesses.length);










 assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).exclusions.equals(Sets.newHashSet(f("f"))));










 }










 










 @Test










 public void deltaMatchingMergedField() {










 SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;



......@@ -227,6 +248,12 @@ public class AccessPathTest {









 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));










 }










 










 @Test










 public void multipleExclPrefixOfMultipleExcl() {










 AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));










 assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference(f("f", "h"))));










 }










 










 @Test










 public void mergedFieldsPrefixOf() {










 assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));



......


import com.google.common.collect.Sets;importcom.google.common.collect.Sets;import heros.alias.AccessPath.Delta;importheros.alias.AccessPath.Delta;import heros.alias.AccessPath.PrefixTestResult;importheros.alias.AccessPath.PrefixTestResult;import heros.alias.SubAccessPath.*;importheros.alias.SubAccessPath.*; }} return result;returnresult; }}   private static SetOfPossibleFieldAccesses<TestFieldRef> anyOf(String...fields) {privatestaticSetOfPossibleFieldAccesses<TestFieldRef>anyOf(String...fields){ Set<TestFieldRef> set = Sets.newHashSet();Set<TestFieldRef>set=Sets.newHashSet(); for(String f : fields)for(Stringf:fields) }}  private static AccessPath<TestFieldRef> ap(SubAccessPath<TestFieldRef>... path) {privatestaticAccessPath<TestFieldRef>ap(SubAccessPath<TestFieldRef>...path){ return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet(), null);returnnewAccessPath<TestFieldRef>(path,Sets.<TestFieldRef>newHashSet(),, nullnull); return new AccessPath<TestFieldRef>(path, Sets.<TestFieldRef> newHashSet());returnnewAccessPath<TestFieldRef>(path,Sets.<TestFieldRef>newHashSet()); }}  @Test@Test assertEquals(ap(s("a"), anyOf("b","c")), sut.addFieldReference(f("b")));assertEquals(ap(s("a"),anyOf("b","c")),sut.addFieldReference(f("b"))); }}  @Test@Test public void addMultipleFieldsAndMerge() {publicvoidaddMultipleFieldsAndMerge(){ AccessPath<TestFieldRef> sut = AccessPath.<TestFieldRef>empty().addFieldReference(f("a"));AccessPath<TestFieldRef>sut=AccessPath.<TestFieldRef>empty().addFieldReference(f("a")); assertEquals(ap(anyOf("a", "b")), sut.addFieldReference(f("b", "a")));assertEquals(ap(anyOf("a","b")),sut.addFieldReference(f("b","a"))); }}  @Test@Test public void addWithoutMerge() {publicvoidaddWithoutMerge(){ AccessPath<TestFieldRef> sut = ap(s("a"));AccessPath<TestFieldRef>sut=ap(s("a")); assertArrayEquals(new SubAccessPath[] { anyOf("f") } , actual);assertArrayEquals(newSubAccessPath[]{anyOf("f")},actual); }}  @Test@Test public void deltaFromSetToSet() {publicvoiddeltaFromSetToSet(){ Delta<TestFieldRef> actual = ap(anyOf("a")).appendExcludedFieldReference(f("f")).getDeltaTo(ap(anyOf("a")).appendExcludedFieldReference(f("g")));Delta<TestFieldRef>actual=ap(anyOf("a")).appendExcludedFieldReference(f("f")).getDeltaTo(ap(anyOf("a")).appendExcludedFieldReference(f("g"))); assertArrayEquals(new SubAccessPath[] { anyOf("a") }, actual.accesses);assertArrayEquals(newSubAccessPath[]{anyOf("a")},actual.accesses); assertEquals(Sets.newHashSet(f("g")), actual.exclusions);assertEquals(Sets.newHashSet(f("g")),actual.exclusions); }}  @Test@Test public void emptyDeltaOnEqualExclusions() {publicvoidemptyDeltaOnEqualExclusions(){ AccessPath<TestFieldRef> actual = ap().appendExcludedFieldReference(f("f"));AccessPath<TestFieldRef>actual=ap().appendExcludedFieldReference(f("f")); assertEquals(0, actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).accesses.length);assertEquals(0,actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).accesses.length); assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).exclusions.equals(Sets.newHashSet(f("f"))));assertTrue(actual.getDeltaTo(ap().appendExcludedFieldReference(f("f"))).exclusions.equals(Sets.newHashSet(f("f")))); }}  @Test@Test public void deltaMatchingMergedField() {publicvoiddeltaMatchingMergedField(){ SubAccessPath<TestFieldRef>[] actual = ap(s("a"), s("b")).getDeltaTo(ap(s("a"), anyOf("b"))).accesses;SubAccessPath<TestFieldRef>[]actual=ap(s("a"),s("b")).getDeltaTo(ap(s("a"),anyOf("b"))).accesses; assertEquals(PrefixTestResult.GUARANTEED_PREFIX, sut.isPrefixOf(ap(anyOf("f"), s("h"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,sut.isPrefixOf(ap(anyOf("f"),s("h")))); }}  @Test@Test public void multipleExclPrefixOfMultipleExcl() {publicvoidmultipleExclPrefixOfMultipleExcl(){ AccessPath<TestFieldRef> sut = ap().appendExcludedFieldReference(f("f", "g"));AccessPath<TestFieldRef>sut=ap().appendExcludedFieldReference(f("f","g")); assertEquals(PrefixTestResult.POTENTIAL_PREFIX, sut.isPrefixOf(ap().appendExcludedFieldReference(f("f", "h"))));assertEquals(PrefixTestResult.POTENTIAL_PREFIX,sut.isPrefixOf(ap().appendExcludedFieldReference(f("f","h")))); }}  @Test@Test public void mergedFieldsPrefixOf() {publicvoidmergedFieldsPrefixOf(){ assertEquals(PrefixTestResult.GUARANTEED_PREFIX, ap(anyOf("f")).isPrefixOf(ap(s("f"))));assertEquals(PrefixTestResult.GUARANTEED_PREFIX,ap(anyOf("f")).isPrefixOf(ap(s("f"))));








test/heros/alias/AccessPathUtilTest.java








View file @ 3398e46f






......@@ -11,125 +11,109 @@









package heros.alias;





















import static heros.alias.AccessPath.PrefixTestResult.*;










import static heros.alias.AccessPathUtil.applyAbstractedSummary;










import static heros.alias.AccessPathUtil.isPrefixOf;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertTrue;





















import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import heros.alias.AccessPath.PrefixTestResult;





















import org.junit.Test;





















public class AccessPathUtilTest {





















 public static AccessPath<TestFieldRef> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<TestFieldRef> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(new TestFieldRef(identifier));










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 TestFieldRef[] fExcl = new TestFieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new TestFieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 }










 }










 return accessPath;










 }










 










 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a"), new Fact("a.f")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a")));










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("f")));










 assertEquals(NO_PREFIX, ap("f").isPrefixOf(ap("")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a"), new Fact("a")));










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.b"), new Fact("a.b.c")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.b.c"), new Fact("a.b")));










 assertEquals(GUARANTEED_PREFIX, ap("b").isPrefixOf(ap("b.c")));










 assertEquals(NO_PREFIX, ap("b.c").isPrefixOf(ap("b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.g")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.g"), new Fact("a^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g")));










 assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a^f")));










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f,g"), new Fact("a^f,g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertEquals(POTENTIAL_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.g.g")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.f.h")));










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f,g"), new Fact("a^g")));










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f")));










 assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.g.h")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h")));










 }










 










 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a"), new Fact("a^f")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a")));










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));










 










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a.f^g^h")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 }










 










 @Test










 public void testAbstractedSummary() {










 assertEquals(new Fact("z.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h")));










 assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f")));










 }










 










 @Test










 public void testAbstractedFieldAccessSummary() {










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryIntroducesFieldAccess() {










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.c"), new SummaryEdge<>(new Fact("a"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryRemovesFieldAccess() {










 assertEquals(new Fact("z.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testNonAbstractedSummary() {










 assertEquals(new Fact("z"), applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testSummaryWithExcludedField() {










 assertEquals(new Fact("a.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testIdentityForExclusions() {










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a"))).get());










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).get());










 }










 










 @Test










 public void testMergeExclusions() {










 assertEquals(new Fact("a^f,g"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testNullOnImpossibleSubsumption() {










 assertFalse(applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).isPresent());










 }










}












test/heros/alias/AccessPathUtilTest.java








View file @ 3398e46f








test/heros/alias/AccessPathUtilTest.java










View file @ 3398e46f


3398e46f



......@@ -11,125 +11,109 @@









package heros.alias;





















import static heros.alias.AccessPath.PrefixTestResult.*;










import static heros.alias.AccessPathUtil.applyAbstractedSummary;










import static heros.alias.AccessPathUtil.isPrefixOf;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertTrue;





















import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import heros.alias.AccessPath.PrefixTestResult;





















import org.junit.Test;





















public class AccessPathUtilTest {





















 public static AccessPath<TestFieldRef> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<TestFieldRef> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(new TestFieldRef(identifier));










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 TestFieldRef[] fExcl = new TestFieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new TestFieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 }










 }










 return accessPath;










 }










 










 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a"), new Fact("a.f")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a")));










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("f")));










 assertEquals(NO_PREFIX, ap("f").isPrefixOf(ap("")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a"), new Fact("a")));










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.b"), new Fact("a.b.c")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.b.c"), new Fact("a.b")));










 assertEquals(GUARANTEED_PREFIX, ap("b").isPrefixOf(ap("b.c")));










 assertEquals(NO_PREFIX, ap("b.c").isPrefixOf(ap("b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.g")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.g"), new Fact("a^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g")));










 assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a^f")));










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f,g"), new Fact("a^f,g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertEquals(POTENTIAL_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.g.g")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.f.h")));










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f,g"), new Fact("a^g")));










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f")));










 assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.g.h")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h")));










 }










 










 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a"), new Fact("a^f")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a")));










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));










 










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a.f^g^h")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 }










 










 @Test










 public void testAbstractedSummary() {










 assertEquals(new Fact("z.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h")));










 assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f")));










 }










 










 @Test










 public void testAbstractedFieldAccessSummary() {










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryIntroducesFieldAccess() {










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.c"), new SummaryEdge<>(new Fact("a"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryRemovesFieldAccess() {










 assertEquals(new Fact("z.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testNonAbstractedSummary() {










 assertEquals(new Fact("z"), applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testSummaryWithExcludedField() {










 assertEquals(new Fact("a.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testIdentityForExclusions() {










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a"))).get());










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).get());










 }










 










 @Test










 public void testMergeExclusions() {










 assertEquals(new Fact("a^f,g"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testNullOnImpossibleSubsumption() {










 assertFalse(applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).isPresent());










 }










}






......@@ -11,125 +11,109 @@









package heros.alias;





















import static heros.alias.AccessPath.PrefixTestResult.*;










import static heros.alias.AccessPathUtil.applyAbstractedSummary;










import static heros.alias.AccessPathUtil.isPrefixOf;










import static org.junit.Assert.assertEquals;










import static org.junit.Assert.assertFalse;










import static org.junit.Assert.assertTrue;





















import java.util.regex.Matcher;










import java.util.regex.Pattern;





















import heros.alias.AccessPath.PrefixTestResult;





















import org.junit.Test;





















public class AccessPathUtilTest {





















 public static AccessPath<TestFieldRef> ap(String ap) {










 Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");










 Matcher matcher = pattern.matcher(ap);










 AccessPath<TestFieldRef> accessPath = new AccessPath<>();










 boolean addedExclusions = false;










 










 while(matcher.find()) {










 String separator = matcher.group(1);










 String identifier = matcher.group(2);










 










 if(".".equals(separator) || separator == null) {










 if(addedExclusions)










 throw new IllegalArgumentException("Access path contains field references after exclusions.");










 accessPath = accessPath.addFieldReference(new TestFieldRef(identifier));










 } else {










 addedExclusions=true;










 String[] excl = identifier.split(",");










 TestFieldRef[] fExcl = new TestFieldRef[excl.length];










 for(int i=0; i<excl.length; i++)










 fExcl[i] = new TestFieldRef(excl[i]);










 accessPath = accessPath.appendExcludedFieldReference(fExcl);










 }










 }










 return accessPath;










 }










 










 @Test










 public void testBaseValuePrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a"), new Fact("a.f")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a")));










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("f")));










 assertEquals(NO_PREFIX, ap("f").isPrefixOf(ap("")));










 }










 










 @Test










 public void testBaseValueIdentity() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a"), new Fact("a")));










 assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("")));










 }










 










 @Test










 public void testFieldAccessPrefixOfFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.b"), new Fact("a.b.c")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.b.c"), new Fact("a.b")));










 assertEquals(GUARANTEED_PREFIX, ap("b").isPrefixOf(ap("b.c")));










 assertEquals(NO_PREFIX, ap("b.c").isPrefixOf(ap("b")));










 }










 










 @Test










 public void testPrefixOfFieldAccessWithExclusion() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.g")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.g"), new Fact("a^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g")));










 assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f")));










 }










 










 @Test










 public void testIdentityWithExclusion() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a^f")));










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f,g"), new Fact("a^f,g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f")));










 assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g")));










 }










 










 @Test










 public void testDifferentExclusions() {










 assertEquals(POTENTIAL_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a^g")));










 assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g")));










 }










 










 @Test










 public void testMixedFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.g.g")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.f.h")));










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 }










 










 @Test










 public void testMultipleExclusions() {










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f,g"), new Fact("a^g")));










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f")));










 assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g")));










 assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g")));










 }





















 @Test










 public void testDifferentAccessPathLength() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.g.h")));










 assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h")));










 }










 










 @Test










 public void testExclusionRequiresFieldAccess() {










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a"), new Fact("a^f")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a")));










 assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));










 assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("")));










 










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));










 assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));










 










 assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a.f^g^h")));










 assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));










 }










 










 @Test










 public void testAbstractedSummary() {










 assertEquals(new Fact("z.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h")));










 assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f")));










 }










 










 @Test










 public void testAbstractedFieldAccessSummary() {










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryIntroducesFieldAccess() {










 assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.c"), new SummaryEdge<>(new Fact("a"), null, new Fact("z.b"))).get());










 }










 










 @Test










 public void testSummaryRemovesFieldAccess() {










 assertEquals(new Fact("z.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testNonAbstractedSummary() {










 assertEquals(new Fact("z"), applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());










 }










 










 @Test










 public void testSummaryWithExcludedField() {










 assertEquals(new Fact("a.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testIdentityForExclusions() {










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a"))).get());










 assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).get());










 }










 










 @Test










 public void testMergeExclusions() {










 assertEquals(new Fact("a^f,g"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());










 }










 










 @Test










 public void testNullOnImpossibleSubsumption() {










 assertFalse(applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).isPresent());










 }










}


package heros.alias;packageheros.alias;import static heros.alias.AccessPath.PrefixTestResult.*;importstaticheros.alias.AccessPath.PrefixTestResult.*;import static heros.alias.AccessPathUtil.applyAbstractedSummary;importstaticheros.alias.AccessPathUtil.applyAbstractedSummary;import static heros.alias.AccessPathUtil.isPrefixOf;importstaticheros.alias.AccessPathUtil.isPrefixOf;import static org.junit.Assert.assertEquals;importstaticorg.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;importstaticorg.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;importstaticorg.junit.Assert.assertTrue;import java.util.regex.Matcher;importjava.util.regex.Matcher;import java.util.regex.Pattern;importjava.util.regex.Pattern;import heros.alias.AccessPath.PrefixTestResult;importheros.alias.AccessPath.PrefixTestResult;import org.junit.Test;importorg.junit.Test;public class AccessPathUtilTest {publicclassAccessPathUtilTest{ public static AccessPath<TestFieldRef> ap(String ap) {publicstaticAccessPath<TestFieldRef>ap(Stringap){ Pattern pattern = Pattern.compile("(\\.|\\^)?([^\\.\\^]+)");Patternpattern=Pattern.compile("(\\.|\\^)?([^\\.\\^]+)"); Matcher matcher = pattern.matcher(ap);Matchermatcher=pattern.matcher(ap); AccessPath<TestFieldRef> accessPath = new AccessPath<>();AccessPath<TestFieldRef>accessPath=newAccessPath<>(); boolean addedExclusions = false;booleanaddedExclusions=false;  while(matcher.find()) {while(matcher.find()){ String separator = matcher.group(1);Stringseparator=matcher.group(1); String identifier = matcher.group(2);Stringidentifier=matcher.group(2);  if(".".equals(separator) || separator == null) {if(".".equals(separator)||separator==null){ if(addedExclusions)if(addedExclusions) throw new IllegalArgumentException("Access path contains field references after exclusions.");thrownewIllegalArgumentException("Access path contains field references after exclusions."); accessPath = accessPath.addFieldReference(new TestFieldRef(identifier));accessPath=accessPath.addFieldReference(newTestFieldRef(identifier)); } else {}else{ addedExclusions=true;addedExclusions=true; String[] excl = identifier.split(",");String[]excl=identifier.split(","); TestFieldRef[] fExcl = new TestFieldRef[excl.length];TestFieldRef[]fExcl=newTestFieldRef[excl.length]; for(int i=0; i<excl.length; i++)for(inti=0;i<excl.length;i++) fExcl[i] = new TestFieldRef(excl[i]);fExcl[i]=newTestFieldRef(excl[i]); accessPath = accessPath.appendExcludedFieldReference(fExcl);accessPath=accessPath.appendExcludedFieldReference(fExcl); }} }} return accessPath;returnaccessPath; }}  @Test@Test public void testBaseValuePrefixOfFieldAccess() {publicvoidtestBaseValuePrefixOfFieldAccess(){ assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a"), new Fact("a.f")));assertEquals(GUARANTEED_PREFIX,isPrefixOf(newnew FactFact(("a""a"),), newnew FactFact(("a.f""a.))); assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a")));assertEquals(NO_PREFIX,isPrefixOf(newnew FactFact(("a.f""a.f"),), newnew FactFact("a"a))); assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("f")));assertEquals(GUARANTEED_PREFIX,apap(("""").).isPrefixOf(apap(("f""))); assertEquals(NO_PREFIX, ap("f").isPrefixOf(ap("")));assertEquals(NO_PREFIX,apap(("f""f").).isPrefixOf(apap(""))); }}  @Test@Test public void testBaseValueIdentity() {publicvoidtestBaseValueIdentity(){ assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a"), new Fact("a")));assertEquals(GUARANTEED_PREFIX,isPrefixOf(newnew FactFact(("a""a"),), newnew FactFact(("a""a))); assertEquals(GUARANTEED_PREFIX, ap("").isPrefixOf(ap("")));assertEquals(GUARANTEED_PREFIX,apap(("""").).isPrefixOf(apap(("""))); }}  @Test@Test public void testFieldAccessPrefixOfFieldAccess() {publicvoidtestFieldAccessPrefixOfFieldAccess(){ assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.b"), new Fact("a.b.c")));assertEquals(GUARANTEED_PREFIX,isPrefixOf(newnew FactFact(("a.b""a.b"),), newnew FactFact(("a.b.c""a.))); assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.b.c"), new Fact("a.b")));assertEquals(NO_PREFIX,isPrefixOf(newnew FactFact(("a.b.c""a.b.c"),), newnew FactFact(("a.b""a.))); assertEquals(GUARANTEED_PREFIX, ap("b").isPrefixOf(ap("b.c")));assertEquals(GUARANTEED_PREFIX,apap(("b""b").).isPrefixOf(apap(("b.c""))); assertEquals(NO_PREFIX, ap("b.c").isPrefixOf(ap("b")));assertEquals(NO_PREFIX,apap(("b.c""b.c").).isPrefixOf(apap(("b""))); }}  @Test@Test public void testPrefixOfFieldAccessWithExclusion() {publicvoidtestPrefixOfFieldAccessWithExclusion(){ assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.g")));assertEquals(GUARANTEED_PREFIX, isPrefixOf(newnew FactFact(("a^f""a^f"),), newnew FactFact(("a.g""a.))); assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.g"), new Fact("a^f")));assertEquals(NO_PREFIX, isPrefixOf(newnew FactFact(("a.g""a.g"),), newnew FactFact(("a^f""a))); assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g")));assertEquals(GUARANTEED_PREFIX,apap(("^f""^f").).isPrefixOf(apap(("g""))); assertEquals(NO_PREFIX,ap("g").isPrefixOf(ap("^f")));assertEquals(NO_PREFIX,apap(("g""g").).isPrefixOf(apap(("^f""))); }}  @Test@Test public void testIdentityWithExclusion() {publicvoidtestIdentityWithExclusion(){ assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a^f")));assertEquals(GUARANTEED_PREFIX, isPrefixOf(newnew FactFact(("a^f""a^f"),), newnew FactFact("a^f"a))); assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f,g"), new Fact("a^f,g")));assertEquals(GUARANTEED_PREFIX, isPrefixOfisPrefixOf((newnew FactFact(("a^f,g""a^f,g"),), newnew FactFact("a^f,g"a))); assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f")));assertEquals(GUARANTEED_PREFIX,apap(("^f""^f").).isPrefixOf(apap("^f"))); assertEquals(GUARANTEED_PREFIX,ap("^f,g").isPrefixOf(ap("^f,g")));assertEquals(GUARANTEED_PREFIX,apap(("^f,g""^f,g").).isPrefixOfisPrefixOf((apap("^f,g"))); }}  @Test@Test public void testDifferentExclusions() {publicvoidtestDifferentExclusions(){ assertEquals(POTENTIAL_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a^g")));assertEquals(POTENTIAL_PREFIX, isPrefixOf(newnew FactFact(("a^f""a^f"),), newnew FactFact("a^g"a))); assertEquals(POTENTIAL_PREFIX,ap("^f").isPrefixOf(ap("^g")));assertEquals(POTENTIAL_PREFIX,apap(("^f""^f").).isPrefixOf(apap("^g"))); }}  @Test@Test public void testMixedFieldAccess() {publicvoidtestMixedFieldAccess(){ assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.g.g")));assertEquals(GUARANTEED_PREFIX, isPrefixOf(newnew FactFact(("a^f""a^f"),), newnew FactFact(("a.g.g""a.))); assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.f.h")));assertEquals(NO_PREFIX, isPrefixOf(newnew FactFact(("a^f""a^f"),), newnew FactFact(("a.f.h""a.))); assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));assertEquals(GUARANTEED_PREFIX, isPrefixOf(newnew FactFact(("a.f""a.f"),), newnew FactFact(("a.f^g""a.))); assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.g")));assertEquals(GUARANTEED_PREFIX,apap(("^f""^f").).isPrefixOf(apap(("g.g""))); assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("f.h")));assertEquals(NO_PREFIX,apap(("^f""^f").).isPrefixOf(apap(("f.h""))); assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));assertEquals(GUARANTEED_PREFIX,apap(("f""f").).isPrefixOf(apap(("f^g""))); }}  @Test@Test public void testMultipleExclusions() {publicvoidtestMultipleExclusions(){ assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f,g"), new Fact("a^f")));assertEquals(NO_PREFIX,isPrefixOf(newFact("a^f,g"),newFact("a^f"))); assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f,g"), new Fact("a^g")));assertEquals(NO_PREFIX,isPrefixOf(newFact("a^f,g"),newFact("a^g"))); assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a^f,g")));assertEquals(GUARANTEED_PREFIX,isPrefixOf(newFact("a^f"),newFact("a^f,g"))); assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f")));assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^f"))); assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g")));assertEquals(POTENTIAL_PREFIX,ap("^f,h").isPrefixOf(ap("^f,g"))); assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g")));assertEquals(NO_PREFIX,ap("^f,g").isPrefixOf(ap("^g"))); assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g")));assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("^f,g"))); }} @Test@Test public void testDifferentAccessPathLength() {publicvoidtestDifferentAccessPathLength(){ assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a.g.h")));assertEquals(GUARANTEED_PREFIX, isPrefixOf(newnew FactFact(("a^f""a^f"),), newnew FactFact(("a.g.h""a.))); assertEquals(GUARANTEED_PREFIX,ap("^f").isPrefixOf(ap("g.h")));assertEquals(GUARANTEED_PREFIX,apap(("^f""^f").).isPrefixOf(apap(("g.h""))); }}  @Test@Test public void testExclusionRequiresFieldAccess() {publicvoidtestExclusionRequiresFieldAccess(){ assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a"), new Fact("a^f")));assertEquals(GUARANTEED_PREFIX, isPrefixOf(newnew FactFact(("a""a"),), newnew FactFact("a^f"a))); assertEquals(NO_PREFIX, isPrefixOf(new Fact("a^f"), new Fact("a")));assertEquals(NO_PREFIX, isPrefixOf(newnew FactFact(("a^f""a^f"),), newnew FactFact("a"a))); assertEquals(GUARANTEED_PREFIX,ap("").isPrefixOf(ap("^f")));assertEquals(GUARANTEED_PREFIX,apap(("""").).isPrefixOf(apap("^f"))); assertEquals(NO_PREFIX,ap("^f").isPrefixOf(ap("")));assertEquals(NO_PREFIX,apap(("^f""^f").).isPrefixOf(apap("")));  assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a.f^g")));assertEquals(GUARANTEED_PREFIX, isPrefixOf(newnew FactFact(("a.f""a.f"),), newnew FactFact(("a.f^g""a.))); assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.f^g"), new Fact("a.f")));assertEquals(NO_PREFIX, isPrefixOf(newnew FactFact(("a.f^g""a.f^g"),), newnew FactFact(("a.f""a.))); assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g")));assertEquals(GUARANTEED_PREFIX,apap(("f""f").).isPrefixOf(apap(("f^g""))); assertEquals(NO_PREFIX,ap("f^g").isPrefixOf(ap("f")));assertEquals(NO_PREFIX,apap(("f^g""f^g").).isPrefixOf(apap(("f"")));  assertEquals(GUARANTEED_PREFIX, isPrefixOf(new Fact("a.f"), new Fact("a.f^g^h")));assertEquals(GUARANTEED_PREFIX,isPrefixOf(newFact("a.f"),newFact("a.f^g^h"))); assertEquals(NO_PREFIX, isPrefixOf(new Fact("a.f^g^h"), new Fact("a.f")));assertEquals(NO_PREFIX,isPrefixOf(newFact("a.f^g^h"),newFact("a.f"))); }}  @Test@Test public void testAbstractedSummary() {publicvoidtestAbstractedSummary(){ assertEquals(new Fact("z.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());assertEquals(newFact("z.f"),applyAbstractedSummary(newFact("a.f"),newSummaryEdge<>(newFact("a"),null,newFact("z"))).get()); assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h")));assertEquals(GUARANTEED_PREFIX,ap("f").isPrefixOf(ap("f^g^h"))); assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f")));assertEquals(NO_PREFIX,ap("f^g^h").isPrefixOf(ap("f"))); }}  @Test@Test public void testAbstractedFieldAccessSummary() {publicvoidtestAbstractedFieldAccessSummary(){ assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z.b"))).get());assertEquals(newFact("z.b.c"),applyAbstractedSummary(newFact("a.b.c"),newSummaryEdge<>(newFact("a.b"),null,newFact("z.b"))).get()); }}  @Test@Test public void testSummaryIntroducesFieldAccess() {publicvoidtestSummaryIntroducesFieldAccess(){ assertEquals(new Fact("z.b.c"), applyAbstractedSummary(new Fact("a.c"), new SummaryEdge<>(new Fact("a"), null, new Fact("z.b"))).get());assertEquals(newFact("z.b.c"),applyAbstractedSummary(newFact("a.c"),newSummaryEdge<>(newFact("a"),null,newFact("z.b"))).get()); }}  @Test@Test public void testSummaryRemovesFieldAccess() {publicvoidtestSummaryRemovesFieldAccess(){ assertEquals(new Fact("z.c"), applyAbstractedSummary(new Fact("a.b.c"), new SummaryEdge<>(new Fact("a.b"), null, new Fact("z"))).get());assertEquals(newFact("z.c"),applyAbstractedSummary(newFact("a.b.c"),newSummaryEdge<>(newFact("a.b"),null,newFact("z"))).get()); }}  @Test@Test public void testNonAbstractedSummary() {publicvoidtestNonAbstractedSummary(){ assertEquals(new Fact("z"), applyAbstractedSummary(new Fact("a"), new SummaryEdge<>(new Fact("a"), null, new Fact("z"))).get());assertEquals(newFact("z"),applyAbstractedSummary(newFact("a"),newSummaryEdge<>(newFact("a"),null,newFact("z"))).get()); }}  @Test@Test public void testSummaryWithExcludedField() {publicvoidtestSummaryWithExcludedField(){ assertEquals(new Fact("a.f"), applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());assertEquals(newFact("a.f"),applyAbstractedSummary(newFact("a.f"),newSummaryEdge<>(newFact("a"),null,newFact("a^g"))).get()); }}  @Test@Test public void testIdentityForExclusions() {publicvoidtestIdentityForExclusions(){ assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a"))).get());assertEquals(newFact("a^f"),applyAbstractedSummary(newFact("a^f"),newSummaryEdge<>(newFact("a"),null,newFact("a"))).get()); assertEquals(new Fact("a^f"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).get());assertEquals(newFact("a^f"),applyAbstractedSummary(newFact("a^f"),newSummaryEdge<>(newFact("a"),null,newFact("a^f"))).get()); }}  @Test@Test public void testMergeExclusions() {publicvoidtestMergeExclusions(){ assertEquals(new Fact("a^f,g"), applyAbstractedSummary(new Fact("a^f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^g"))).get());assertEquals(newFact("a^f,g"),applyAbstractedSummary(newFact("a^f"),newSummaryEdge<>(newFact("a"),null,newFact("a^g"))).get()); }}  @Test@Test public void testNullOnImpossibleSubsumption() {publicvoidtestNullOnImpossibleSubsumption(){ assertFalse(applyAbstractedSummary(new Fact("a.f"), new SummaryEdge<>(new Fact("a"), null, new Fact("a^f"))).isPresent());assertFalse(applyAbstractedSummary(newFact("a.f"),newSummaryEdge<>(newFact("a"),null,newFact("a^f"))).isPresent()); }}}}








test/heros/alias/ControlFlowJoinResolverTest.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;





















import org.junit.Before;










import org.junit.Test;










import org.mockito.ArgumentMatcher;










import org.mockito.Mockito;










import org.mockito.invocation.InvocationOnMock;










import org.mockito.stubbing.Answer;










import org.mockito.verification.VerificationMode;





















public class ControlFlowJoinResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement joinStmt;










 private ControlFlowJoinResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 joinStmt = new TestStatement("joinStmt");










 sut = new ControlFlowJoinResolver<>(analyzer, joinStmt);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);










 }





















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver));










 verify(analyzer).processFlowFromJoinStmt(eq(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver));










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));










 }










 










 










 private class ResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;





















 public ResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 this.accPath = accPath;










 }





















 @Override










 public boolean matches(Object argument) {










 ControlFlowJoinResolver resolver = (ControlFlowJoinResolver) argument;










 return resolver.isInterestGiven() && resolver.getResolvedAccessPath().equals(accPath) && resolver.getJoinStmt().equals(joinStmt);










 }










 }










}












test/heros/alias/ControlFlowJoinResolverTest.java



0 → 100644







View file @ 3398e46f








test/heros/alias/ControlFlowJoinResolverTest.java



0 → 100644









View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;





















import org.junit.Before;










import org.junit.Test;










import org.mockito.ArgumentMatcher;










import org.mockito.Mockito;










import org.mockito.invocation.InvocationOnMock;










import org.mockito.stubbing.Answer;










import org.mockito.verification.VerificationMode;





















public class ControlFlowJoinResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement joinStmt;










 private ControlFlowJoinResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 joinStmt = new TestStatement("joinStmt");










 sut = new ControlFlowJoinResolver<>(analyzer, joinStmt);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);










 }





















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver));










 verify(analyzer).processFlowFromJoinStmt(eq(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver));










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));










 }










 










 










 private class ResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;





















 public ResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 this.accPath = accPath;










 }





















 @Override










 public boolean matches(Object argument) {










 ControlFlowJoinResolver resolver = (ControlFlowJoinResolver) argument;










 return resolver.isInterestGiven() && resolver.getResolvedAccessPath().equals(accPath) && resolver.getJoinStmt().equals(joinStmt);










 }










 }










}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;





















import org.junit.Before;










import org.junit.Test;










import org.mockito.ArgumentMatcher;










import org.mockito.Mockito;










import org.mockito.invocation.InvocationOnMock;










import org.mockito.stubbing.Answer;










import org.mockito.verification.VerificationMode;





















public class ControlFlowJoinResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement joinStmt;










 private ControlFlowJoinResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 joinStmt = new TestStatement("joinStmt");










 sut = new ControlFlowJoinResolver<>(analyzer, joinStmt);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);










 }





















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver));










 verify(analyzer).processFlowFromJoinStmt(eq(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver));










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));










 }










 










 










 private class ResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;





















 public ResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 this.accPath = accPath;










 }





















 @Override










 public boolean matches(Object argument) {










 ControlFlowJoinResolver resolver = (ControlFlowJoinResolver) argument;










 return resolver.isInterestGiven() && resolver.getResolvedAccessPath().equals(accPath) && resolver.getJoinStmt().equals(joinStmt);










 }










 }










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import static org.junit.Assert.assertTrue;importstaticorg.junit.Assert.assertTrue;import static org.mockito.Mockito.*;importstaticorg.mockito.Mockito.*;import heros.alias.AccessPath.Delta;importheros.alias.AccessPath.Delta;import org.junit.Before;importorg.junit.Before;import org.junit.Test;importorg.junit.Test;import org.mockito.ArgumentMatcher;importorg.mockito.ArgumentMatcher;import org.mockito.Mockito;importorg.mockito.Mockito;import org.mockito.invocation.InvocationOnMock;importorg.mockito.invocation.InvocationOnMock;import org.mockito.stubbing.Answer;importorg.mockito.stubbing.Answer;import org.mockito.verification.VerificationMode;importorg.mockito.verification.VerificationMode;public class ControlFlowJoinResolverTest {publicclassControlFlowJoinResolverTest{ private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {privatestaticDeltaConstraint<TestFieldRef>getDeltaConstraint(String...fieldRefs){ return new DeltaConstraint<>(getDelta(fieldRefs));returnnewDeltaConstraint<>(getDelta(fieldRefs)); }} private static Delta<TestFieldRef> getDelta(String... fieldRefs) {privatestaticDelta<TestFieldRef>getDelta(String...fieldRefs){ AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);AccessPath<TestFieldRef>accPath=createAccessPath(fieldRefs); return new AccessPath<TestFieldRef>().getDeltaTo(accPath);returnnewAccessPath<TestFieldRef>().getDeltaTo(accPath); }} protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {protectedstaticAccessPath<TestFieldRef>createAccessPath(String...fieldRefs){ AccessPath<TestFieldRef> accPath = new AccessPath<>();AccessPath<TestFieldRef>accPath=newAccessPath<>(); for (String fieldRef : fieldRefs) {for(StringfieldRef:fieldRefs){ accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));accPath=accPath.addFieldReference(newTestFieldRef(fieldRef)); }} return accPath;returnaccPath; }} private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;privatePerAccessPathMethodAnalyzer<TestFieldRef,TestFact,TestStatement,TestMethod>analyzer; private TestStatement joinStmt;privateTestStatementjoinStmt; private ControlFlowJoinResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;privateControlFlowJoinResolver<TestFieldRef,TestFact,TestStatement,TestMethod>sut; private TestFact fact;privateTestFactfact; private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;privateInterestCallback<TestFieldRef,TestFact,TestStatement,TestMethod>callback; private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;privateResolver<TestFieldRef,TestFact,TestStatement,TestMethod>callEdgeResolver; @Before@Before public void before() {publicvoidbefore(){ analyzer = mock(PerAccessPathMethodAnalyzer.class);analyzer=mock(PerAccessPathMethodAnalyzer.class); joinStmt = new TestStatement("joinStmt");joinStmt=newTestStatement("joinStmt"); sut = new ControlFlowJoinResolver<>(analyzer, joinStmt);sut=newControlFlowJoinResolver<>(analyzer,joinStmt); fact = new TestFact("value");fact=newTestFact("value"); callback = mock(InterestCallback.class);callback=mock(InterestCallback.class); callEdgeResolver = mock(CallEdgeResolver.class);callEdgeResolver=mock(CallEdgeResolver.class); }} @Test@Test public void emptyIncomingFact() {publicvoidemptyIncomingFact(){ sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver));sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),callEdgeResolver)); verify(analyzer).processFlowFromJoinStmt(eq(new WrappedFactAtStatement<>(joinStmt, new WrappedFact<>(fact, createAccessPath(), sut))));verify(analyzer).processFlowFromJoinStmt(eq(newWrappedFactAtStatement<>(joinStmt,newWrappedFact<>(fact,createAccessPath(),sut)))); assertTrue(sut.isInterestGiven());assertTrue(sut.isInterestGiven()); }} @Test@Test public void resolveViaIncomingFact() {publicvoidresolveViaIncomingFact(){ sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback); sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver));sut.addIncoming(newWrappedFact<>(fact,createAccessPath("a"),callEdgeResolver)); verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));verify(callback).interest(eq(analyzer),argThat(newResolverArgumentMatcher(createAccessPath("a")))); }} @Test@Test public void registerCallbackAtIncomingResolver() {publicvoidregisterCallbackAtIncomingResolver(){ Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<TestFieldRef,TestFact,TestStatement,TestMethod>resolver=mock(Resolver.class); sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),resolver)); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback); verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));verify(resolver).resolve(eq(getDeltaConstraint("a")),any(InterestCallback.class)); }}  @Test@Test public void resolveViaIncomingResolver() {publicvoidresolveViaIncomingResolver(){ Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<TestFieldRef,TestFact,TestStatement,TestMethod>resolver=mock(Resolver.class); final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);finalResolver<TestFieldRef,TestFact,TestStatement,TestMethod>nestedResolver=mock(Resolver.class); Mockito.doAnswer(new Answer(){Mockito.doAnswer(newAnswer(){ @Override@Override public Object answer(InvocationOnMock invocation) throws Throwable {publicObjectanswer(InvocationOnMockinvocation)throwsThrowable{ InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = InterestCallback<TestFieldRef,TestFact,TestStatement,TestMethod>argCallback= (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];(InterestCallback<TestFieldRef,TestFact,TestStatement,TestMethod>)invocation.getArguments()[1]; argCallback.interest(null, nestedResolver);argCallback.interest(null,nestedResolver); return null;returnnull; }} }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));}).when(resolver).resolve(eq(getDeltaConstraint("a")),any(InterestCallback.class));  sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver));sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),resolver)); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback);  verify(callback).interest(eq(analyzer), argThat(new ResolverArgumentMatcher(createAccessPath("a"))));verify(callback).interest(eq(analyzer),argThat(newResolverArgumentMatcher(createAccessPath("a")))); }}   private class ResolverArgumentMatcher extendsprivateclassResolverArgumentMatcherextends ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {ArgumentMatcher<ReturnSiteResolver<TestFieldRef,TestFact,TestStatement,TestMethod>>{ private AccessPath<TestFieldRef> accPath;privateAccessPath<TestFieldRef>accPath; public ResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {publicResolverArgumentMatcher(AccessPath<TestFieldRef>accPath){ this.accPath = accPath;this.accPath=accPath; }} @Override@Override public boolean matches(Object argument) {publicbooleanmatches(Objectargument){ ControlFlowJoinResolver resolver = (ControlFlowJoinResolver) argument;ControlFlowJoinResolverresolver=(ControlFlowJoinResolver)argument; return resolver.isInterestGiven() && resolver.getResolvedAccessPath().equals(accPath) && resolver.getJoinStmt().equals(joinStmt);returnresolver.isInterestGiven()&&resolver.getResolvedAccessPath().equals(accPath)&&resolver.getJoinStmt().equals(joinStmt); }} }}}}








test/heros/alias/EdgeBuilder.java








View file @ 3398e46f






......@@ -32,43 +32,44 @@ public abstract class EdgeBuilder {




















 public static class CallSiteBuilder extends EdgeBuilder {





















 private Statement callSite;










 private TestStatement callSite;





















 public CallSiteBuilder(Statement callSite) {










 public CallSiteBuilder(TestStatement callSite) {










 this.callSite = callSite;










 }





















 public CallSiteBuilder calls(String method, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.CallEdge(callSite, new Method(method), flows));










 edges.add(new TestHelper.CallEdge(callSite, new TestMethod(method), flows));










 return this;










 }










 










 public CallSiteBuilder retSite(String returnSite, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new Statement(returnSite), flows));










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new TestStatement(returnSite), flows));










 return this;










 }










 }










 










 public static class NormalStmtBuilder extends EdgeBuilder {





















 private Statement stmt;










 private TestStatement stmt;










 private ExpectedFlowFunction[] flowFunctions;





















 public NormalStmtBuilder(Statement stmt) {










 public NormalStmtBuilder(TestStatement stmt, ExpectedFlowFunction[] flowFunctions) {










 this.stmt = stmt;










 this.flowFunctions = flowFunctions;










 }





















 public NormalStmtBuilder succ(String succ, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.NormalEdge(stmt, new Statement(succ), flows));










 public NormalStmtBuilder succ(String succ) {










 edges.add(new TestHelper.NormalEdge(stmt, new TestStatement(succ), flowFunctions));










 return this;










 }










 










 }










 










 public static class ExitStmtBuilder extends EdgeBuilder {





















 private Statement exitStmt;










 private TestStatement exitStmt;





















 public ExitStmtBuilder(Statement exitStmt) {










 public ExitStmtBuilder(TestStatement exitStmt) {










 this.exitStmt = exitStmt;










 }










 



......@@ -77,7 +78,7 @@ public abstract class EdgeBuilder {









 return this;










 }





















 public ExitStmtBuilder returns(Statement callSite, Statement returnSite, ExpectedFlowFunction... flows) {










 public ExitStmtBuilder returns(TestStatement callSite, TestStatement returnSite, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.ReturnEdge(callSite, exitStmt, returnSite, flows));










 return this;










 }



......












test/heros/alias/EdgeBuilder.java








View file @ 3398e46f








test/heros/alias/EdgeBuilder.java










View file @ 3398e46f


3398e46f



......@@ -32,43 +32,44 @@ public abstract class EdgeBuilder {




















 public static class CallSiteBuilder extends EdgeBuilder {





















 private Statement callSite;










 private TestStatement callSite;





















 public CallSiteBuilder(Statement callSite) {










 public CallSiteBuilder(TestStatement callSite) {










 this.callSite = callSite;










 }





















 public CallSiteBuilder calls(String method, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.CallEdge(callSite, new Method(method), flows));










 edges.add(new TestHelper.CallEdge(callSite, new TestMethod(method), flows));










 return this;










 }










 










 public CallSiteBuilder retSite(String returnSite, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new Statement(returnSite), flows));










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new TestStatement(returnSite), flows));










 return this;










 }










 }










 










 public static class NormalStmtBuilder extends EdgeBuilder {





















 private Statement stmt;










 private TestStatement stmt;










 private ExpectedFlowFunction[] flowFunctions;





















 public NormalStmtBuilder(Statement stmt) {










 public NormalStmtBuilder(TestStatement stmt, ExpectedFlowFunction[] flowFunctions) {










 this.stmt = stmt;










 this.flowFunctions = flowFunctions;










 }





















 public NormalStmtBuilder succ(String succ, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.NormalEdge(stmt, new Statement(succ), flows));










 public NormalStmtBuilder succ(String succ) {










 edges.add(new TestHelper.NormalEdge(stmt, new TestStatement(succ), flowFunctions));










 return this;










 }










 










 }










 










 public static class ExitStmtBuilder extends EdgeBuilder {





















 private Statement exitStmt;










 private TestStatement exitStmt;





















 public ExitStmtBuilder(Statement exitStmt) {










 public ExitStmtBuilder(TestStatement exitStmt) {










 this.exitStmt = exitStmt;










 }










 



......@@ -77,7 +78,7 @@ public abstract class EdgeBuilder {









 return this;










 }





















 public ExitStmtBuilder returns(Statement callSite, Statement returnSite, ExpectedFlowFunction... flows) {










 public ExitStmtBuilder returns(TestStatement callSite, TestStatement returnSite, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.ReturnEdge(callSite, exitStmt, returnSite, flows));










 return this;










 }



......






......@@ -32,43 +32,44 @@ public abstract class EdgeBuilder {




















 public static class CallSiteBuilder extends EdgeBuilder {





















 private Statement callSite;










 private TestStatement callSite;





















 public CallSiteBuilder(Statement callSite) {










 public CallSiteBuilder(TestStatement callSite) {










 this.callSite = callSite;










 }





















 public CallSiteBuilder calls(String method, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.CallEdge(callSite, new Method(method), flows));










 edges.add(new TestHelper.CallEdge(callSite, new TestMethod(method), flows));










 return this;










 }










 










 public CallSiteBuilder retSite(String returnSite, ExpectedFlowFunction...flows) {










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new Statement(returnSite), flows));










 edges.add(new TestHelper.Call2ReturnEdge(callSite, new TestStatement(returnSite), flows));










 return this;










 }










 }










 










 public static class NormalStmtBuilder extends EdgeBuilder {





















 private Statement stmt;










 private TestStatement stmt;










 private ExpectedFlowFunction[] flowFunctions;





















 public NormalStmtBuilder(Statement stmt) {










 public NormalStmtBuilder(TestStatement stmt, ExpectedFlowFunction[] flowFunctions) {










 this.stmt = stmt;










 this.flowFunctions = flowFunctions;










 }





















 public NormalStmtBuilder succ(String succ, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.NormalEdge(stmt, new Statement(succ), flows));










 public NormalStmtBuilder succ(String succ) {










 edges.add(new TestHelper.NormalEdge(stmt, new TestStatement(succ), flowFunctions));










 return this;










 }










 










 }










 










 public static class ExitStmtBuilder extends EdgeBuilder {





















 private Statement exitStmt;










 private TestStatement exitStmt;





















 public ExitStmtBuilder(Statement exitStmt) {










 public ExitStmtBuilder(TestStatement exitStmt) {










 this.exitStmt = exitStmt;










 }










 



......@@ -77,7 +78,7 @@ public abstract class EdgeBuilder {









 return this;










 }





















 public ExitStmtBuilder returns(Statement callSite, Statement returnSite, ExpectedFlowFunction... flows) {










 public ExitStmtBuilder returns(TestStatement callSite, TestStatement returnSite, ExpectedFlowFunction... flows) {










 edges.add(new TestHelper.ReturnEdge(callSite, exitStmt, returnSite, flows));










 return this;










 }



......


 public static class CallSiteBuilder extends EdgeBuilder {publicstaticclassCallSiteBuilderextendsEdgeBuilder{ private Statement callSite;privateStatementcallSite; private TestStatement callSite;privateTestStatementTestcallSite; public CallSiteBuilder(Statement callSite) {publicCallSiteBuilder(StatementcallSite){ public CallSiteBuilder(TestStatement callSite) {publicCallSiteBuilder(TestStatementTestcallSite){ this.callSite = callSite;this.callSite=callSite; }} public CallSiteBuilder calls(String method, ExpectedFlowFunction...flows) {publicCallSiteBuildercalls(Stringmethod,ExpectedFlowFunction...flows){ edges.add(new TestHelper.CallEdge(callSite, new Method(method), flows));edges.add(newTestHelper.CallEdge(callSite,newMethod(method),flows)); edges.add(new TestHelper.CallEdge(callSite, new TestMethod(method), flows));edges.add(newTestHelper.CallEdge(callSite,newTestMethodTest(method),flows)); return this;returnthis; }}  public CallSiteBuilder retSite(String returnSite, ExpectedFlowFunction...flows) {publicCallSiteBuilderretSite(StringreturnSite,ExpectedFlowFunction...flows){ edges.add(new TestHelper.Call2ReturnEdge(callSite, new Statement(returnSite), flows));edges.add(newTestHelper.Call2ReturnEdge(callSite,newStatement(returnSite),flows)); edges.add(new TestHelper.Call2ReturnEdge(callSite, new TestStatement(returnSite), flows));edges.add(newTestHelper.Call2ReturnEdge(callSite,newTestStatementTest(returnSite),flows)); return this;returnthis; }} }}  public static class NormalStmtBuilder extends EdgeBuilder {publicstaticclassNormalStmtBuilderextendsEdgeBuilder{ private Statement stmt;privateStatementstmt; private TestStatement stmt;privateTestStatementstmt; private ExpectedFlowFunction[] flowFunctions;privateExpectedFlowFunction[]flowFunctions; public NormalStmtBuilder(Statement stmt) {publicNormalStmtBuilder(Statementstmt){ public NormalStmtBuilder(TestStatement stmt, ExpectedFlowFunction[] flowFunctions) {publicNormalStmtBuilder(TestStatementTeststmt,, ExpectedFlowFunctionExpectedFlowFunction[][] flowFunctionsflowFunctions){ this.stmt = stmt;this.stmt=stmt; this.flowFunctions = flowFunctions;this.flowFunctions=flowFunctions; }} public NormalStmtBuilder succ(String succ, ExpectedFlowFunction... flows) {publicNormalStmtBuildersucc(Stringsucc,, ExpectedFlowFunctionExpectedFlowFunction...... flowsflows){ edges.add(new TestHelper.NormalEdge(stmt, new Statement(succ), flows));edges.add(newTestHelper.NormalEdge(stmt,newStatement(succ),flows)); public NormalStmtBuilder succ(String succ) {publicNormalStmtBuildersucc(Stringsucc){ edges.add(new TestHelper.NormalEdge(stmt, new TestStatement(succ), flowFunctions));edges.add(newTestHelper.NormalEdge(stmt,newTestStatementTest(succ),flowFunctionsFunction)); return this;returnthis; }}  }}  public static class ExitStmtBuilder extends EdgeBuilder {publicstaticclassExitStmtBuilderextendsEdgeBuilder{ private Statement exitStmt;privateStatementexitStmt; private TestStatement exitStmt;privateTestStatementTestexitStmt; public ExitStmtBuilder(Statement exitStmt) {publicExitStmtBuilder(StatementexitStmt){ public ExitStmtBuilder(TestStatement exitStmt) {publicExitStmtBuilder(TestStatementTestexitStmt){ this.exitStmt = exitStmt;this.exitStmt=exitStmt; }}  return this;returnthis; }} public ExitStmtBuilder returns(Statement callSite, Statement returnSite, ExpectedFlowFunction... flows) {publicExitStmtBuilderreturns(StatementcallSite,StatementreturnSite,ExpectedFlowFunction...flows){ public ExitStmtBuilder returns(TestStatement callSite, TestStatement returnSite, ExpectedFlowFunction... flows) {publicExitStmtBuilderreturns(TestStatementTestcallSite,TestStatementTestreturnSite,ExpectedFlowFunction...flows){ edges.add(new TestHelper.ReturnEdge(callSite, exitStmt, returnSite, flows));edges.add(newTestHelper.ReturnEdge(callSite,exitStmt,returnSite,flows)); return this;returnthis; }}








test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ 3398e46f





This diff is collapsed.
Click to expand it.











test/heros/alias/FieldSensitiveIFDSSolverTest.java








View file @ 3398e46f








test/heros/alias/FieldSensitiveIFDSSolverTest.java










View file @ 3398e46f


3398e46f


This diff is collapsed.
Click to expand it.




This diff is collapsed.
Click to expand it.


This diff is collapsed.
Click to expand it.









test/heros/alias/ReturnSiteResolverTest.java



0 → 100644







View file @ 3398e46f













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;





















import org.junit.Before;










import org.junit.Test;










import org.mockito.ArgumentMatcher;










import org.mockito.Mockito;










import org.mockito.invocation.InvocationOnMock;










import org.mockito.stubbing.Answer;










import org.mockito.verification.VerificationMode;





















public class ReturnSiteResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement returnSite;










 private ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 returnSite = new TestStatement("returnSite");










 sut = new ReturnSiteResolver<>(analyzer, returnSite);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);










 }





















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 verify(analyzer).scheduleEdgeTo(eq(new WrappedFactAtStatement<>(returnSite, new WrappedFact<>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver), callEdgeResolver, getDelta());










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }










 










 @Test










 public void resolveViaDelta() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }










 










 @Test










 public void resolveViaDeltaTwice() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a", "b"));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(innerCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));










 }










 










 @Test










 public void resolveViaDeltaAndThenViaCallSite() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(innerCallback).canBeResolvedEmpty();










 }





















 @Test










 public void resolveViaCallEdgeResolverAtCallSite() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).canBeResolvedEmpty();










 }










 










 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 @Test










 public void resolveViaResolverAtCallSiteTwice() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback innerCallback = (InterestCallback) invocation.getArguments()[1];










 innerCallback.interest(analyzer, nestedResolver);










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback innerCallback = (InterestCallback) invocation.getArguments()[1];










 innerCallback.interest(analyzer, nestedResolver);










 return null;










 }










 }).when(nestedResolver).resolve(eq(getDeltaConstraint("b")), any(InterestCallback.class));










 










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), secondCallback);










 return null;










 }










 










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(secondCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));










 }










 










 @Test










 public void resolveAsEmptyViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Delta<TestFieldRef> delta = new AccessPath<TestFieldRef>().getDeltaTo(new AccessPath<TestFieldRef>().appendExcludedFieldReference(new TestFieldRef("a")));










 










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback innerCallback = (InterestCallback) invocation.getArguments()[1];










 innerCallback.canBeResolvedEmpty();










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));





















 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, delta);










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback, never()).canBeResolvedEmpty();










 verify(callback, never()).interest(any(PerAccessPathMethodAnalyzer.class), any(Resolver.class));










 }










 










 @Test










 public void resolveViaCallSiteResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 private class ReturnSiteResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;





















 public ReturnSiteResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 this.accPath = accPath;










 }





















 @Override










 public boolean matches(Object argument) {










 ReturnSiteResolver resolver = (ReturnSiteResolver) argument;










 return resolver.isInterestGiven() && resolver.getResolvedAccessPath().equals(accPath) && resolver.getReturnSite().equals(returnSite);










 }










 }










}












test/heros/alias/ReturnSiteResolverTest.java



0 → 100644







View file @ 3398e46f








test/heros/alias/ReturnSiteResolverTest.java



0 → 100644









View file @ 3398e46f


3398e46f










/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;





















import org.junit.Before;










import org.junit.Test;










import org.mockito.ArgumentMatcher;










import org.mockito.Mockito;










import org.mockito.invocation.InvocationOnMock;










import org.mockito.stubbing.Answer;










import org.mockito.verification.VerificationMode;





















public class ReturnSiteResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement returnSite;










 private ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 returnSite = new TestStatement("returnSite");










 sut = new ReturnSiteResolver<>(analyzer, returnSite);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);










 }





















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 verify(analyzer).scheduleEdgeTo(eq(new WrappedFactAtStatement<>(returnSite, new WrappedFact<>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver), callEdgeResolver, getDelta());










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }










 










 @Test










 public void resolveViaDelta() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }










 










 @Test










 public void resolveViaDeltaTwice() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a", "b"));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(innerCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));










 }










 










 @Test










 public void resolveViaDeltaAndThenViaCallSite() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(innerCallback).canBeResolvedEmpty();










 }





















 @Test










 public void resolveViaCallEdgeResolverAtCallSite() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).canBeResolvedEmpty();










 }










 










 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 @Test










 public void resolveViaResolverAtCallSiteTwice() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback innerCallback = (InterestCallback) invocation.getArguments()[1];










 innerCallback.interest(analyzer, nestedResolver);










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback innerCallback = (InterestCallback) invocation.getArguments()[1];










 innerCallback.interest(analyzer, nestedResolver);










 return null;










 }










 }).when(nestedResolver).resolve(eq(getDeltaConstraint("b")), any(InterestCallback.class));










 










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), secondCallback);










 return null;










 }










 










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(secondCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));










 }










 










 @Test










 public void resolveAsEmptyViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Delta<TestFieldRef> delta = new AccessPath<TestFieldRef>().getDeltaTo(new AccessPath<TestFieldRef>().appendExcludedFieldReference(new TestFieldRef("a")));










 










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback innerCallback = (InterestCallback) invocation.getArguments()[1];










 innerCallback.canBeResolvedEmpty();










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));





















 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, delta);










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback, never()).canBeResolvedEmpty();










 verify(callback, never()).interest(any(PerAccessPathMethodAnalyzer.class), any(Resolver.class));










 }










 










 @Test










 public void resolveViaCallSiteResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 private class ReturnSiteResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;





















 public ReturnSiteResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 this.accPath = accPath;










 }





















 @Override










 public boolean matches(Object argument) {










 ReturnSiteResolver resolver = (ReturnSiteResolver) argument;










 return resolver.isInterestGiven() && resolver.getResolvedAccessPath().equals(accPath) && resolver.getReturnSite().equals(returnSite);










 }










 }










}













/*******************************************************************************










 * Copyright (c) 2015 Johannes Lerch.










 * All rights reserved. This program and the accompanying materials










 * are made available under the terms of the GNU Lesser Public License v2.1










 * which accompanies this distribution, and is available at










 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html










 * 










 * Contributors:










 *     Johannes Lerch - initial API and implementation










 ******************************************************************************/










package heros.alias;





















import static org.junit.Assert.assertTrue;










import static org.mockito.Mockito.*;










import heros.alias.AccessPath.Delta;





















import org.junit.Before;










import org.junit.Test;










import org.mockito.ArgumentMatcher;










import org.mockito.Mockito;










import org.mockito.invocation.InvocationOnMock;










import org.mockito.stubbing.Answer;










import org.mockito.verification.VerificationMode;





















public class ReturnSiteResolverTest {





















 private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {










 return new DeltaConstraint<>(getDelta(fieldRefs));










 }





















 private static Delta<TestFieldRef> getDelta(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);










 return new AccessPath<TestFieldRef>().getDeltaTo(accPath);










 }





















 protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {










 AccessPath<TestFieldRef> accPath = new AccessPath<>();










 for (String fieldRef : fieldRefs) {










 accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));










 }










 return accPath;










 }





















 private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;










 private TestStatement returnSite;










 private ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;










 private TestFact fact;










 private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;










 private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;





















 @Before










 public void before() {










 analyzer = mock(PerAccessPathMethodAnalyzer.class);










 returnSite = new TestStatement("returnSite");










 sut = new ReturnSiteResolver<>(analyzer, returnSite);










 fact = new TestFact("value");










 callback = mock(InterestCallback.class);










 callEdgeResolver = mock(CallEdgeResolver.class);










 }





















 @Test










 public void emptyIncomingFact() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 verify(analyzer).scheduleEdgeTo(eq(new WrappedFactAtStatement<>(returnSite, new WrappedFact<>(fact, createAccessPath(), sut))));










 assertTrue(sut.isInterestGiven());










 }





















 @Test










 public void resolveViaIncomingFact() {










 sut.resolve(getDeltaConstraint("a"), callback);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver), callEdgeResolver, getDelta());










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }





















 @Test










 public void registerCallbackAtIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 @Test










 public void resolveViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 Mockito.doAnswer(new Answer(){










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = 










 (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 argCallback.interest(null, nestedResolver);










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }










 










 @Test










 public void resolveViaDelta() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 }










 










 @Test










 public void resolveViaDeltaTwice() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a", "b"));










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(innerCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));










 }










 










 @Test










 public void resolveViaDeltaAndThenViaCallSite() {










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), innerCallback);










 return null;










 }










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(innerCallback).canBeResolvedEmpty();










 }





















 @Test










 public void resolveViaCallEdgeResolverAtCallSite() {










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(callback).canBeResolvedEmpty();










 }










 










 @Test










 public void resolveViaResolverAtCallSite() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 @Test










 public void resolveViaResolverAtCallSiteTwice() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback innerCallback = (InterestCallback) invocation.getArguments()[1];










 innerCallback.interest(analyzer, nestedResolver);










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback innerCallback = (InterestCallback) invocation.getArguments()[1];










 innerCallback.interest(analyzer, nestedResolver);










 return null;










 }










 }).when(nestedResolver).resolve(eq(getDeltaConstraint("b")), any(InterestCallback.class));










 










 final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];










 resolver.resolve(getDeltaConstraint("b"), secondCallback);










 return null;










 }










 










 }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(secondCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));










 }










 










 @Test










 public void resolveAsEmptyViaIncomingResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 Delta<TestFieldRef> delta = new AccessPath<TestFieldRef>().getDeltaTo(new AccessPath<TestFieldRef>().appendExcludedFieldReference(new TestFieldRef("a")));










 










 doAnswer(new Answer() {










 @Override










 public Object answer(InvocationOnMock invocation) throws Throwable {










 InterestCallback innerCallback = (InterestCallback) invocation.getArguments()[1];










 innerCallback.canBeResolvedEmpty();










 return null;










 }










 }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));





















 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, delta);










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(callback, never()).canBeResolvedEmpty();










 verify(callback, never()).interest(any(PerAccessPathMethodAnalyzer.class), any(Resolver.class));










 }










 










 @Test










 public void resolveViaCallSiteResolver() {










 Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);










 










 sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());










 sut.resolve(getDeltaConstraint("a"), callback);










 










 verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));










 }










 










 private class ReturnSiteResolverArgumentMatcher extends










 ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {





















 private AccessPath<TestFieldRef> accPath;





















 public ReturnSiteResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {










 this.accPath = accPath;










 }





















 @Override










 public boolean matches(Object argument) {










 ReturnSiteResolver resolver = (ReturnSiteResolver) argument;










 return resolver.isInterestGiven() && resolver.getResolvedAccessPath().equals(accPath) && resolver.getReturnSite().equals(returnSite);










 }










 }










}


/*******************************************************************************/******************************************************************************* * Copyright (c) 2015 Johannes Lerch. * Copyright (c) 2015 Johannes Lerch. * All rights reserved. This program and the accompanying materials * All rights reserved. This program and the accompanying materials * are made available under the terms of the GNU Lesser Public License v2.1 * are made available under the terms of the GNU Lesser Public License v2.1 * which accompanies this distribution, and is available at * which accompanies this distribution, and is available at * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html *  *  * Contributors: * Contributors: *     Johannes Lerch - initial API and implementation *     Johannes Lerch - initial API and implementation ******************************************************************************/ ******************************************************************************/package heros.alias;packageheros.alias;import static org.junit.Assert.assertTrue;importstaticorg.junit.Assert.assertTrue;import static org.mockito.Mockito.*;importstaticorg.mockito.Mockito.*;import heros.alias.AccessPath.Delta;importheros.alias.AccessPath.Delta;import org.junit.Before;importorg.junit.Before;import org.junit.Test;importorg.junit.Test;import org.mockito.ArgumentMatcher;importorg.mockito.ArgumentMatcher;import org.mockito.Mockito;importorg.mockito.Mockito;import org.mockito.invocation.InvocationOnMock;importorg.mockito.invocation.InvocationOnMock;import org.mockito.stubbing.Answer;importorg.mockito.stubbing.Answer;import org.mockito.verification.VerificationMode;importorg.mockito.verification.VerificationMode;public class ReturnSiteResolverTest {publicclassReturnSiteResolverTest{ private static DeltaConstraint<TestFieldRef> getDeltaConstraint(String... fieldRefs) {privatestaticDeltaConstraint<TestFieldRef>getDeltaConstraint(String...fieldRefs){ return new DeltaConstraint<>(getDelta(fieldRefs));returnnewDeltaConstraint<>(getDelta(fieldRefs)); }} private static Delta<TestFieldRef> getDelta(String... fieldRefs) {privatestaticDelta<TestFieldRef>getDelta(String...fieldRefs){ AccessPath<TestFieldRef> accPath = createAccessPath(fieldRefs);AccessPath<TestFieldRef>accPath=createAccessPath(fieldRefs); return new AccessPath<TestFieldRef>().getDeltaTo(accPath);returnnewAccessPath<TestFieldRef>().getDeltaTo(accPath); }} protected static AccessPath<TestFieldRef> createAccessPath(String... fieldRefs) {protectedstaticAccessPath<TestFieldRef>createAccessPath(String...fieldRefs){ AccessPath<TestFieldRef> accPath = new AccessPath<>();AccessPath<TestFieldRef>accPath=newAccessPath<>(); for (String fieldRef : fieldRefs) {for(StringfieldRef:fieldRefs){ accPath = accPath.addFieldReference(new TestFieldRef(fieldRef));accPath=accPath.addFieldReference(newTestFieldRef(fieldRef)); }} return accPath;returnaccPath; }} private PerAccessPathMethodAnalyzer<TestFieldRef, TestFact, TestStatement, TestMethod> analyzer;privatePerAccessPathMethodAnalyzer<TestFieldRef,TestFact,TestStatement,TestMethod>analyzer; private TestStatement returnSite;privateTestStatementreturnSite; private ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> sut;privateReturnSiteResolver<TestFieldRef,TestFact,TestStatement,TestMethod>sut; private TestFact fact;privateTestFactfact; private InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> callback;privateInterestCallback<TestFieldRef,TestFact,TestStatement,TestMethod>callback; private Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> callEdgeResolver;privateResolver<TestFieldRef,TestFact,TestStatement,TestMethod>callEdgeResolver; @Before@Before public void before() {publicvoidbefore(){ analyzer = mock(PerAccessPathMethodAnalyzer.class);analyzer=mock(PerAccessPathMethodAnalyzer.class); returnSite = new TestStatement("returnSite");returnSite=newTestStatement("returnSite"); sut = new ReturnSiteResolver<>(analyzer, returnSite);sut=newReturnSiteResolver<>(analyzer,returnSite); fact = new TestFact("value");fact=newTestFact("value"); callback = mock(InterestCallback.class);callback=mock(InterestCallback.class); callEdgeResolver = mock(CallEdgeResolver.class);callEdgeResolver=mock(CallEdgeResolver.class); }} @Test@Test public void emptyIncomingFact() {publicvoidemptyIncomingFact(){ sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),callEdgeResolver),callEdgeResolver,getDelta()); verify(analyzer).scheduleEdgeTo(eq(new WrappedFactAtStatement<>(returnSite, new WrappedFact<>(fact, createAccessPath(), sut))));verify(analyzer).scheduleEdgeTo(eq(newWrappedFactAtStatement<>(returnSite,newWrappedFact<>(fact,createAccessPath(),sut)))); assertTrue(sut.isInterestGiven());assertTrue(sut.isInterestGiven()); }} @Test@Test public void resolveViaIncomingFact() {publicvoidresolveViaIncomingFact(){ sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback); sut.addIncoming(new WrappedFact<>(fact, createAccessPath("a"), callEdgeResolver), callEdgeResolver, getDelta());sut.addIncoming(newWrappedFact<>(fact,createAccessPath("a"),callEdgeResolver),callEdgeResolver,getDelta()); verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));verify(callback).interest(eq(analyzer),argThat(newReturnSiteResolverArgumentMatcher(createAccessPath("a")))); }} @Test@Test public void registerCallbackAtIncomingResolver() {publicvoidregisterCallbackAtIncomingResolver(){ Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<TestFieldRef,TestFact,TestStatement,TestMethod>resolver=mock(Resolver.class); sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),resolver),callEdgeResolver,getDelta()); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback); verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));verify(resolver).resolve(eq(getDeltaConstraint("a")),any(InterestCallback.class)); }}  @Test@Test public void resolveViaIncomingResolver() {publicvoidresolveViaIncomingResolver(){ Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<TestFieldRef,TestFact,TestStatement,TestMethod>resolver=mock(Resolver.class); final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);finalResolver<TestFieldRef,TestFact,TestStatement,TestMethod>nestedResolver=mock(Resolver.class); Mockito.doAnswer(new Answer(){Mockito.doAnswer(newAnswer(){ @Override@Override public Object answer(InvocationOnMock invocation) throws Throwable {publicObjectanswer(InvocationOnMockinvocation)throwsThrowable{ InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> argCallback = InterestCallback<TestFieldRef,TestFact,TestStatement,TestMethod>argCallback= (InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];(InterestCallback<TestFieldRef,TestFact,TestStatement,TestMethod>)invocation.getArguments()[1]; argCallback.interest(null, nestedResolver);argCallback.interest(null,nestedResolver); return null;returnnull; }} }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));}).when(resolver).resolve(eq(getDeltaConstraint("a")),any(InterestCallback.class));  sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, getDelta());sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),resolver),callEdgeResolver,getDelta()); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback);  verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));verify(callback).interest(eq(analyzer),argThat(newReturnSiteResolverArgumentMatcher(createAccessPath("a")))); }}  @Test@Test public void resolveViaDelta() {publicvoidresolveViaDelta(){ sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),callEdgeResolver),callEdgeResolver,getDelta("a")); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback); verify(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));verify(callback).interest(eq(analyzer),argThat(newReturnSiteResolverArgumentMatcher(createAccessPath("a")))); }}  @Test@Test public void resolveViaDeltaTwice() {publicvoidresolveViaDeltaTwice(){ final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);finalInterestCallback<TestFieldRef,TestFact,TestStatement,TestMethod>innerCallback=mock(InterestCallback.class); doAnswer(new Answer() {doAnswer(newAnswer(){ @Override@Override public Object answer(InvocationOnMock invocation) throws Throwable {publicObjectanswer(InvocationOnMockinvocation)throwsThrowable{ ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];ReturnSiteResolver<TestFieldRef,TestFact,TestStatement,TestMethod>resolver=(ReturnSiteResolver<TestFieldRef,TestFact,TestStatement,TestMethod>)invocation.getArguments()[1]; resolver.resolve(getDeltaConstraint("b"), innerCallback);resolver.resolve(getDeltaConstraint("b"),innerCallback); return null;returnnull; }} }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));}).when(callback).interest(eq(analyzer),argThat(newReturnSiteResolverArgumentMatcher(createAccessPath("a"))));  sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a", "b"));sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),callEdgeResolver),callEdgeResolver,getDelta("a","b")); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback);  verify(innerCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));verify(innerCallback).interest(eq(analyzer),argThat(newReturnSiteResolverArgumentMatcher(createAccessPath("a","b")))); }}  @Test@Test public void resolveViaDeltaAndThenViaCallSite() {publicvoidresolveViaDeltaAndThenViaCallSite(){ final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> innerCallback = mock(InterestCallback.class);finalInterestCallback<TestFieldRef,TestFact,TestStatement,TestMethod>innerCallback=mock(InterestCallback.class); doAnswer(new Answer() {doAnswer(newAnswer(){ @Override@Override public Object answer(InvocationOnMock invocation) throws Throwable {publicObjectanswer(InvocationOnMockinvocation)throwsThrowable{ ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>) invocation.getArguments()[1];ReturnSiteResolver<TestFieldRef,TestFact,TestStatement,TestMethod>resolver=(ReturnSiteResolver<TestFieldRef,TestFact,TestStatement,TestMethod>)invocation.getArguments()[1]; resolver.resolve(getDeltaConstraint("b"), innerCallback);resolver.resolve(getDeltaConstraint("b"),innerCallback); return null;returnnull; }} }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));}).when(callback).interest(eq(analyzer),argThat(newReturnSiteResolverArgumentMatcher(createAccessPath("a"))));  sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta("a"));sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),callEdgeResolver),callEdgeResolver,getDelta("a")); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback); verify(innerCallback).canBeResolvedEmpty();verify(innerCallback).canBeResolvedEmpty(); }} @Test@Test public void resolveViaCallEdgeResolverAtCallSite() {publicvoidresolveViaCallEdgeResolverAtCallSite(){ sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), callEdgeResolver, getDelta());sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),callEdgeResolver),callEdgeResolver,getDelta()); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback); verify(callback).canBeResolvedEmpty();verify(callback).canBeResolvedEmpty(); }}  @Test@Test public void resolveViaResolverAtCallSite() {publicvoidresolveViaResolverAtCallSite(){ Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<TestFieldRef,TestFact,TestStatement,TestMethod>resolver=mock(Resolver.class); sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),callEdgeResolver),resolver,getDelta()); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback); verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));verify(resolver).resolve(eq(getDeltaConstraint("a")),any(InterestCallback.class)); }}  @Test@Test public void resolveViaResolverAtCallSiteTwice() {publicvoidresolveViaResolverAtCallSiteTwice(){ Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<TestFieldRef,TestFact,TestStatement,TestMethod>resolver=mock(Resolver.class); final Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> nestedResolver = mock(Resolver.class);finalResolver<TestFieldRef,TestFact,TestStatement,TestMethod>nestedResolver=mock(Resolver.class); doAnswer(new Answer() {doAnswer(newAnswer(){ @Override@Override public Object answer(InvocationOnMock invocation) throws Throwable {publicObjectanswer(InvocationOnMockinvocation)throwsThrowable{ InterestCallback innerCallback = (InterestCallback) invocation.getArguments()[1];InterestCallbackinnerCallback=(InterestCallback)invocation.getArguments()[1]; innerCallback.interest(analyzer, nestedResolver);innerCallback.interest(analyzer,nestedResolver); return null;returnnull; }} }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));}).when(resolver).resolve(eq(getDeltaConstraint("a")),any(InterestCallback.class)); doAnswer(new Answer() {doAnswer(newAnswer(){ @Override@Override public Object answer(InvocationOnMock invocation) throws Throwable {publicObjectanswer(InvocationOnMockinvocation)throwsThrowable{ InterestCallback innerCallback = (InterestCallback) invocation.getArguments()[1];InterestCallbackinnerCallback=(InterestCallback)invocation.getArguments()[1]; innerCallback.interest(analyzer, nestedResolver);innerCallback.interest(analyzer,nestedResolver); return null;returnnull; }} }).when(nestedResolver).resolve(eq(getDeltaConstraint("b")), any(InterestCallback.class));}).when(nestedResolver).resolve(eq(getDeltaConstraint("b")),any(InterestCallback.class));  final InterestCallback<TestFieldRef, TestFact, TestStatement, TestMethod> secondCallback = mock(InterestCallback.class);finalInterestCallback<TestFieldRef,TestFact,TestStatement,TestMethod>secondCallback=mock(InterestCallback.class); doAnswer(new Answer() {doAnswer(newAnswer(){ @Override@Override public Object answer(InvocationOnMock invocation) throws Throwable {publicObjectanswer(InvocationOnMockinvocation)throwsThrowable{ ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = (ReturnSiteResolver) invocation.getArguments()[1];ReturnSiteResolver<TestFieldRef,TestFact,TestStatement,TestMethod>resolver=(ReturnSiteResolver)invocation.getArguments()[1]; resolver.resolve(getDeltaConstraint("b"), secondCallback);resolver.resolve(getDeltaConstraint("b"),secondCallback); return null;returnnull; }}  }).when(callback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a"))));}).when(callback).interest(eq(analyzer),argThat(newReturnSiteResolverArgumentMatcher(createAccessPath("a"))));  sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),callEdgeResolver),resolver,getDelta()); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback);  verify(secondCallback).interest(eq(analyzer), argThat(new ReturnSiteResolverArgumentMatcher(createAccessPath("a", "b"))));verify(secondCallback).interest(eq(analyzer),argThat(newReturnSiteResolverArgumentMatcher(createAccessPath("a","b")))); }}  @Test@Test public void resolveAsEmptyViaIncomingResolver() {publicvoidresolveAsEmptyViaIncomingResolver(){ Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<TestFieldRef,TestFact,TestStatement,TestMethod>resolver=mock(Resolver.class); Delta<TestFieldRef> delta = new AccessPath<TestFieldRef>().getDeltaTo(new AccessPath<TestFieldRef>().appendExcludedFieldReference(new TestFieldRef("a")));Delta<TestFieldRef>delta=newAccessPath<TestFieldRef>().getDeltaTo(newAccessPath<TestFieldRef>().appendExcludedFieldReference(newTestFieldRef("a")));  doAnswer(new Answer() {doAnswer(newAnswer(){ @Override@Override public Object answer(InvocationOnMock invocation) throws Throwable {publicObjectanswer(InvocationOnMockinvocation)throwsThrowable{ InterestCallback innerCallback = (InterestCallback) invocation.getArguments()[1];InterestCallbackinnerCallback=(InterestCallback)invocation.getArguments()[1]; innerCallback.canBeResolvedEmpty();innerCallback.canBeResolvedEmpty(); return null;returnnull; }} }).when(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));}).when(resolver).resolve(eq(getDeltaConstraint("a")),any(InterestCallback.class)); sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), resolver), callEdgeResolver, delta);sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),resolver),callEdgeResolver,delta); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback);  verify(callback, never()).canBeResolvedEmpty();verify(callback,never()).canBeResolvedEmpty(); verify(callback, never()).interest(any(PerAccessPathMethodAnalyzer.class), any(Resolver.class));verify(callback,never()).interest(any(PerAccessPathMethodAnalyzer.class),any(Resolver.class)); }}  @Test@Test public void resolveViaCallSiteResolver() {publicvoidresolveViaCallSiteResolver(){ Resolver<TestFieldRef, TestFact, TestStatement, TestMethod> resolver = mock(Resolver.class);Resolver<TestFieldRef,TestFact,TestStatement,TestMethod>resolver=mock(Resolver.class);  sut.addIncoming(new WrappedFact<>(fact, createAccessPath(), callEdgeResolver), resolver, getDelta());sut.addIncoming(newWrappedFact<>(fact,createAccessPath(),callEdgeResolver),resolver,getDelta()); sut.resolve(getDeltaConstraint("a"), callback);sut.resolve(getDeltaConstraint("a"),callback);  verify(resolver).resolve(eq(getDeltaConstraint("a")), any(InterestCallback.class));verify(resolver).resolve(eq(getDeltaConstraint("a")),any(InterestCallback.class)); }}  private class ReturnSiteResolverArgumentMatcher extendsprivateclassReturnSiteResolverArgumentMatcherextends ArgumentMatcher<ReturnSiteResolver<TestFieldRef, TestFact, TestStatement, TestMethod>> {ArgumentMatcher<ReturnSiteResolver<TestFieldRef,TestFact,TestStatement,TestMethod>>{ private AccessPath<TestFieldRef> accPath;privateAccessPath<TestFieldRef>accPath; public ReturnSiteResolverArgumentMatcher(AccessPath<TestFieldRef> accPath) {publicReturnSiteResolverArgumentMatcher(AccessPath<TestFieldRef>accPath){ this.accPath = accPath;this.accPath=accPath; }} @Override@Override public boolean matches(Object argument) {publicbooleanmatches(Objectargument){ ReturnSiteResolver resolver = (ReturnSiteResolver) argument;ReturnSiteResolverresolver=(ReturnSiteResolver)argument; return resolver.isInterestGiven() && resolver.getResolvedAccessPath().equals(accPath) && resolver.getReturnSite().equals(returnSite);returnresolver.isInterestGiven()&&resolver.getResolvedAccessPath().equals(accPath)&&resolver.getReturnSite().equals(returnSite); }} }}}}



Prev


1


2


3


Next





Prev

1

2

3

Next











Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel





Please register or sign in to comment









Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Finish editing this message first!



Cancel







Write




Preview


































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel










You are about to add

0
people

to the discussion. Proceed with caution.





Write




Preview

























Write



Preview

















































Supports Markdown






0%










Try again


or


attach a new file


.



Cancel












Supports Markdown






0%










Try again


or


attach a new file


.



Cancel




Supports Markdown





0%










Try again


or


attach a new file


.



Cancel






0%


0%







Try again


or


attach a new file


.




Try again

attach a new file

Cancel



You are about to add

0
people

to the discussion. Proceed with caution.



You are about to add

0
people

to the discussion. Proceed with caution.
0

Finish editing this message first!



Cancel



Finish editing this message first!

Cancel


Please register or sign in to comment






